# ğŸ“… CRUD, Validaciones y serializaciÃ³n.

| Semana | Objetivos principales                                             |
| ------ | ----------------------------------------------------------------- |
| 3      | ğŸ”„ CRUD de depÃ³sitos y productos                                  |
|        | ğŸ§± Validaciones y serializaciÃ³n con Pydantic                      |
|        | ğŸ“¥ Operaciones bÃ¡sicas desde la consola                           |


### 1. CRUD de DepÃ³sito

-   **Repositorio o servicio** con funciones:
    
    -   `create_deposito(deposito_in: DepositoCreate) -> DepositoOut`
        
    -   `get_deposito(id: int) -> DepositoOut`
        
    -   `update_deposito(id: int, deposito_in: DepositoUpdate) -> DepositoOut`
        
    -   `delete_deposito(id: int) -> None`
        
-   Usar modelos ORM para persistencia y schemas Pydantic para validar y serializar entrada/salida.
    

----------

### 2. CRUD de Producto

-   Lo mismo que con depÃ³sito.
    
-   Validar **SKU Ãºnico**: en el repositorio verificar que no exista otro producto con el mismo SKU antes de crear o actualizar.
    

----------

### 3. Validaciones

-   Definidas en schemas Pydantic (ej: `min_length=1` en nombre y sku).
    
-   Pueden ampliarse segÃºn reglas de negocio.
    

----------

### 4. Consola

-   Crear un script que muestre un menÃº con opciones:
    
    ```
    1. Crear depÃ³sito
    2. Consultar depÃ³sito
    3. Actualizar depÃ³sito
    4. Eliminar depÃ³sito
    5. Crear producto
    6. ...
    0. Salir
    
    ```
    
---------

Perfecto, vamos a construir el **repositorio de DepÃ³sito** paso a paso usando:

-   âœ… **Modelo ORM** (`DepositoORM`)
    
-   âœ… **Schemas Pydantic**: `DepositoCreate`, `DepositoUpdate`, `DepositoOut`
    
-   âœ… **Mapper** entre ORM â†” dominio
    
-   âœ… SQLAlchemy para acceder a la DB
    

----------

### ğŸ“ Estructura sugerida

```
app/
â”œâ”€â”€ db/
â”‚   â””â”€â”€ models/
â”‚       â””â”€â”€ deposito.py  # ORM
â”œâ”€â”€ repositories/
â”‚   â””â”€â”€ deposito_repository.py  âœ… acÃ¡ trabajaremos
â”œâ”€â”€ schemas/
â”‚   â””â”€â”€ deposito.py  # Pydantic schemas
â”œâ”€â”€ domain/
â”‚   â””â”€â”€ models/
â”‚       â””â”€â”€ deposito.py  # Modelo de dominio

```

----------

### âœ… `app/schemas/deposito.py`

Asegurate de tener algo asÃ­:

```python
from pydantic import BaseModel, Field
from typing import Optional
from pydantic import ConfigDict

class DepositoBase(BaseModel):
    nombre: str = Field(..., min_length=1)
    ubicacion: Optional[str] = None

class DepositoCreate(DepositoBase):
    pass

class DepositoUpdate(BaseModel):
    nombre: Optional[str] = Field(default=None, min_length=1)
    ubicacion: Optional[str] = None

class DepositoOut(DepositoBase):
    id: int
    model_config = ConfigDict(from_attributes=True)

```

----------

### âœ… `app/repositories/deposito_repository.py`

```python
from sqlalchemy.orm import Session
from sqlalchemy.exc import NoResultFound

from app.db.models.deposito import DepositoORM
from app.schemas.deposito import DepositoCreate, DepositoUpdate
from domain.models.deposito import Deposito
from mappers.deposito_mapper import deposito_orm_to_domain

class DepositoRepository:

    def __init__(self, db: Session):
        self.db = db

    def create(self, deposito_in: DepositoCreate) -> Deposito:
        orm = DepositoORM(**deposito_in.dict())
        self.db.add(orm)
        self.db.commit()
        self.db.refresh(orm)
        return deposito_orm_to_domain(orm)

    def get(self, deposito_id: int) -> Deposito:
        orm = self.db.query(DepositoORM).filter_by(id=deposito_id).first()
        if orm is None:
            raise NoResultFound(f"DepÃ³sito con ID {deposito_id} no encontrado")
        return deposito_orm_to_domain(orm)

    def update(self, deposito_id: int, deposito_in: DepositoUpdate) -> Deposito:
        orm = self.db.query(DepositoORM).filter_by(id=deposito_id).first()
        if orm is None:
            raise NoResultFound(f"DepÃ³sito con ID {deposito_id} no encontrado")

        for attr, value in deposito_in.dict(exclude_unset=True).items():
            setattr(orm, attr, value)

        self.db.commit()
        self.db.refresh(orm)
        return deposito_orm_to_domain(orm)

    def delete(self, deposito_id: int) -> None:
        orm = self.db.query(DepositoORM).filter_by(id=deposito_id).first()
        if orm is None:
            raise NoResultFound(f"DepÃ³sito con ID {deposito_id} no encontrado")

        self.db.delete(orm)
        self.db.commit()

```

----------

### Â¿QuÃ© sigue?

Podemos ahora:

1.  âœ… Probar este repositorio desde un script o consola.
    
2.  ğŸ”„ Hacer lo mismo para `Producto`.
    
3.  ğŸ§ª Crear una interfaz de consola para probar CRUD de depÃ³sitos.
    
------

Â¡SÃ­, vamos muy bien para la semana 3! ğŸ¯

Te detallo el avance segÃºn los objetivos planteados:

----------

### âœ… **CRUD de depÃ³sitos y productos**

-   Ya implementaste el repositorio de depÃ³sitos (`DepositoRepository`) y sus mÃ©todos `create`, `get`, `get_all`.
    
-   El CRUD de productos tambiÃ©n estÃ¡ listo segÃºn lo que avanzaste anteriormente.
    
-   Ambos CRUD ya operan con mapeadores entre ORM â†” dominio.
    

----------

### âœ… **ğŸ§± Validaciones y serializaciÃ³n con Pydantic**

-   Ya tenÃ©s esquemas Pydantic para `Producto` y `Deposito` en `app/schemas/`.
    
-   Los estÃ¡s utilizando correctamente como DTOs de entrada y salida (`ProductoCreate`, `DepositoCreate`, etc.).
    

----------

### âœ… **ğŸ“¥ Operaciones bÃ¡sicas desde la consola**

-   TenÃ©s `deposito_console.py` operativo, incluyendo opciones como `crear` y `listar`.
    
-   Ya resolviste errores comunes y el flujo bÃ¡sico de entrada del usuario estÃ¡ funcionando.
    

----------

### ğŸ”œ Â¿QuÃ© sigue para cerrar la semana 3 con broche de oro?

Si querÃ©s afianzar aÃºn mÃ¡s lo trabajado:

1.  âœ”ï¸ AgregÃ¡ `update` y `delete` a los repositorios y sus llamadas desde consola.
    
2.  ğŸ§ª ProbÃ¡ entradas invÃ¡lidas para ver si Pydantic lanza las validaciones esperadas.
    
3.  ğŸ”„ ProbÃ¡ persistir algunos datos de prueba y hacer listados cruzados (por ejemplo, productos por depÃ³sito si tenÃ©s esa relaciÃ³n).
    

----------
Vamos paso a paso para probar la consola de `Producto`. Asegurate de tener los siguientes puntos listos antes de ejecutar:

----------

### âœ… 1. Archivos verificados

**Estructura esperada:**

```
app/
â”œâ”€â”€ console/
â”‚   â””â”€â”€ producto_console.py
â”œâ”€â”€ db/
â”‚   â””â”€â”€ models/
â”‚       â”œâ”€â”€ __init__.py   # Debe importar ProductoORM
â”‚       â””â”€â”€ producto.py
â”œâ”€â”€ domain/
â”‚   â””â”€â”€ models/
â”‚       â””â”€â”€ producto.py
â”œâ”€â”€ domain/
â”‚   â””â”€â”€ mappers/
â”‚       â””â”€â”€ producto_mapper.py
â”œâ”€â”€ repositories/
â”‚   â””â”€â”€ producto_repository.py
â”œâ”€â”€ schemas/
â”‚   â””â”€â”€ producto.py

```

----------

### âœ… 2. Probar consola

Desde tu terminal, ejecutÃ¡:

```bash
python -m app.console.producto_console

```

DeberÃ­as ver:

```
1. Crear producto
2. Listar productos
3. Salir
Ingrese opciÃ³n:

```

ProbÃ¡ lo siguiente:

-   OpciÃ³n `1`: ingresÃ¡ un nombre y una descripciÃ³n.
    
-   OpciÃ³n `2`: deberÃ­as ver listado de productos creados.
    
-   OpciÃ³n `3`: sale del programa.
    

----------

### âš ï¸ Si falla

Enviame el traceback y revisamos juntos. En particular:

-   Si da error al importar modelos.
    
-   Si falla la conexiÃ³n a la base de datos.
    
-   Si no se lista nada aunque se crea.
    

----
Â¡Excelente que todo estÃ© funcionando! ğŸ’ª
Con respecto a si dar por cerrada la **semana 3**, te hago un cierre profesional con mirada a futuro:

---

### âœ… Semana 3: Â¿EstÃ¡ realmente completa?

Tuviste como foco:

| Objetivo Semana 3                         | Â¿Completado? |
| ----------------------------------------- | ------------ |
| CRUD de productos y depÃ³sitos             | âœ… SÃ­         |
| Validaciones y serializaciÃ³n con Pydantic | âœ… SÃ­         |
| Operaciones desde consola                 | âœ… SÃ­         |

**Extras cumplidos:**

* RevisiÃ³n de errores reales en consola (input vacÃ­o, validaciÃ³n faltante)
* ImplementaciÃ³n de `update`, que suele quedar sin testear
* Flujo completo: ORM â†” dominio â†” Pydantic â†” consola

---

### ğŸ” Â¿Algo mÃ¡s sugerido antes de cerrar?

Solo **dos mejoras opcionales** podrÃ­an considerarse, pero **no son bloqueantes**:

#### 1. **Listado desde consola ordenado o con paginado simple (si hay muchos registros)**

Ejemplo: mostrar los productos con numeraciÃ³n.

#### 2. **ValidaciÃ³n de unicidad (SKU, nombre) antes del insert**

Aunque la base de datos lanza error por `unique=True`, podrÃ­as agregar validaciones previas para evitar romper consola al insertar repetidos.

```python
# Ejemplo en repositorio:
if self.db.query(ProductoORM).filter_by(sku=producto_in.sku).first():
    raise ValueError("SKU ya existente")
```

---

### âœ… ConclusiÃ³n

> **SÃ­, podÃ©s dar por cerrada la Semana 3.**
> Todo lo crÃ­tico estÃ¡ implementado y probado. Lo sugerido arriba es puramente para mejorar experiencia de usuario y evitar errores, pero puede resolverse mÃ¡s adelante sin impacto tÃ©cnico fuerte.

---
Perfecto. AquÃ­ va el bloque de **Objetivo cumplido - Semana 3**, en el mismo estilo que venÃ­amos utilizando:

----------

### ğŸ¯ Objetivo cumplido: Semana 3 â€“ CRUD de Productos funcionando desde consola

Durante la semana 3 se implementÃ³ exitosamente el CRUD completo para la entidad **Producto**, con una arquitectura organizada en tres capas (ORM, dominio y esquemas Pydantic).  
Se integrÃ³ una consola interactiva que permite operar sobre productos desde lÃ­nea de comandos, manteniendo buenas prÃ¡cticas de separaciÃ³n de responsabilidades y validaciÃ³n de datos.

#### âœ… Lo que se logrÃ³:

-   ğŸ§± Modelo ORM (`ProductoORM`), modelo de dominio (`Producto`) y esquemas Pydantic (`ProductoCreate`, `ProductoUpdate`)
    
-   ğŸ” Mapeadores entre ORM y dominio: `producto_orm_to_domain` y `producto_domain_to_orm`
    
-   ğŸ—ƒï¸ Repositorio con mÃ©todos `create`, `get_all`, `update`, `delete` e integraciÃ³n de validaciÃ³n de unicidad (`nombre`, `sku`)
    
-   ğŸ–¥ï¸ Consola (`producto_console.py`) con menÃº funcional:
    
    -   Crear producto
        
    -   Listar productos (numerado)
        
    -   Listar productos paginados
        
    -   Actualizar producto
        
    -   Eliminar producto
        
    -   Seed de productos de prueba
        
-   ğŸ§ª ValidaciÃ³n de entrada y manejo de errores (e.g. ID invÃ¡lido, duplicados)
    
-   â™»ï¸ ReutilizaciÃ³n de funciones a travÃ©s de `ProductoRepository` y entrada desacoplada desde consola
    




<!--stackedit_data:
eyJoaXN0b3J5IjpbLTcxNDE4OTg1MCwtMTI1NTk4NDMzLC0xNj
IyNzE0MDY1LC0xNDg2ODI3NzcxLC03NTU4ODMyNjMsLTkxNTE1
ODM0NywtMTA5NDU5NDAzNV19
-->