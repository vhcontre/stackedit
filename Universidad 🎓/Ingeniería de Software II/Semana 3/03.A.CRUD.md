# ðŸ“… Semana 3 â€“ CRUD, Validaciones y serializaciÃ³n.

| Semana | Objetivos principales                                             |
| ------ | ----------------------------------------------------------------- |
| 3      | ðŸ”„ CRUD de depÃ³sitos y productos                                  |
|        | ðŸ§± Validaciones y serializaciÃ³n con Pydantic                      |
|        | ðŸ“¥ Operaciones bÃ¡sicas desde la consola                           |


### 1. CRUD de DepÃ³sito

-   **Repositorio o servicio** con funciones:
    
    -   `create_deposito(deposito_in: DepositoCreate) -> DepositoOut`
        
    -   `get_deposito(id: int) -> DepositoOut`
        
    -   `update_deposito(id: int, deposito_in: DepositoUpdate) -> DepositoOut`
        
    -   `delete_deposito(id: int) -> None`
        
-   Usar modelos ORM para persistencia y schemas Pydantic para validar y serializar entrada/salida.
    

----------

### 2. CRUD de Producto

-   Lo mismo que con depÃ³sito.
    
-   Validar **SKU Ãºnico**: en el repositorio verificar que no exista otro producto con el mismo SKU antes de crear o actualizar.
    

----------

### 3. Validaciones

-   Definidas en schemas Pydantic (ej: `min_length=1` en nombre y sku).
    
-   Pueden ampliarse segÃºn reglas de negocio.
    

----------

### 4. Consola

-   Crear un script que muestre un menÃº con opciones:
    
    ```
    1. Crear depÃ³sito
    2. Consultar depÃ³sito
    3. Actualizar depÃ³sito
    4. Eliminar depÃ³sito
    5. Crear producto
    6. ...
    0. Salir
    
    ```
    
---------

Perfecto, vamos a construir el **repositorio de DepÃ³sito** paso a paso usando:

-   âœ… **Modelo ORM** (`DepositoORM`)
    
-   âœ… **Schemas Pydantic**: `DepositoCreate`, `DepositoUpdate`, `DepositoOut`
    
-   âœ… **Mapper** entre ORM â†” dominio
    
-   âœ… SQLAlchemy para acceder a la DB
    

----------

### ðŸ“ Estructura sugerida

```
app/
â”œâ”€â”€ db/
â”‚   â””â”€â”€ models/
â”‚       â””â”€â”€ deposito.py  # ORM
â”œâ”€â”€ repositories/
â”‚   â””â”€â”€ deposito_repository.py  âœ… acÃ¡ trabajaremos
â”œâ”€â”€ schemas/
â”‚   â””â”€â”€ deposito.py  # Pydantic schemas
â”œâ”€â”€ domain/
â”‚   â””â”€â”€ models/
â”‚       â””â”€â”€ deposito.py  # Modelo de dominio

```

----------

### âœ… `app/schemas/deposito.py`

Asegurate de tener algo asÃ­:

```python
from pydantic import BaseModel, Field
from typing import Optional
from pydantic import ConfigDict

class DepositoBase(BaseModel):
    nombre: str = Field(..., min_length=1)
    ubicacion: Optional[str] = None

class DepositoCreate(DepositoBase):
    pass

class DepositoUpdate(BaseModel):
    nombre: Optional[str] = Field(default=None, min_length=1)
    ubicacion: Optional[str] = None

class DepositoOut(DepositoBase):
    id: int
    model_config = ConfigDict(from_attributes=True)

```

----------

### âœ… `app/repositories/deposito_repository.py`

```python
from sqlalchemy.orm import Session
from sqlalchemy.exc import NoResultFound

from app.db.models.deposito import DepositoORM
from app.schemas.deposito import DepositoCreate, DepositoUpdate
from domain.models.deposito import Deposito
from mappers.deposito_mapper import deposito_orm_to_domain

class DepositoRepository:

    def __init__(self, db: Session):
        self.db = db

    def create(self, deposito_in: DepositoCreate) -> Deposito:
        orm = DepositoORM(**deposito_in.dict())
        self.db.add(orm)
        self.db.commit()
        self.db.refresh(orm)
        return deposito_orm_to_domain(orm)

    def get(self, deposito_id: int) -> Deposito:
        orm = self.db.query(DepositoORM).filter_by(id=deposito_id).first()
        if orm is None:
            raise NoResultFound(f"DepÃ³sito con ID {deposito_id} no encontrado")
        return deposito_orm_to_domain(orm)

    def update(self, deposito_id: int, deposito_in: DepositoUpdate) -> Deposito:
        orm = self.db.query(DepositoORM).filter_by(id=deposito_id).first()
        if orm is None:
            raise NoResultFound(f"DepÃ³sito con ID {deposito_id} no encontrado")

        for attr, value in deposito_in.dict(exclude_unset=True).items():
            setattr(orm, attr, value)

        self.db.commit()
        self.db.refresh(orm)
        return deposito_orm_to_domain(orm)

    def delete(self, deposito_id: int) -> None:
        orm = self.db.query(DepositoORM).filter_by(id=deposito_id).first()
        if orm is None:
            raise NoResultFound(f"DepÃ³sito con ID {deposito_id} no encontrado")

        self.db.delete(orm)
        self.db.commit()

```

----------

### Â¿QuÃ© sigue?

Podemos ahora:

1.  âœ… Probar este repositorio desde un script o consola.
    
2.  ðŸ”„ Hacer lo mismo para `Producto`.
    
3.  ðŸ§ª Crear una interfaz de consola para probar CRUD de depÃ³sitos.
    

Â¿QuerÃ©s que armemos un ejemplo de script de consola para usar este repositorio?
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTkxNTE1ODM0NywtMTA5NDU5NDAzNV19
-->