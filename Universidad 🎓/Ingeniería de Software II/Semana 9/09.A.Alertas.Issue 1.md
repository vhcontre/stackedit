## ğŸ“… MÃ³dulo de alertas/reportes

| Semana | Objetivos principales                                             |
| ------ | ----------------------------------------------------------------- |
| 9      | ğŸ“Š MÃ³dulo de alertas/reportes (HTML o CSV)                     |
|        | âœ… NavegaciÃ³n entre vistas (productos / movimientos / reportes) |
|        | ğŸ§ª Pruebas backend y formularios web                           |
|        | ğŸŒ¿ Flujo Git: crear rama + PR para integrar mÃ³dulo             |

### ğŸ§© **Issue #1: Crear reporte de productos con stock bajo**

#### ğŸ“Œ Objetivo:

Mostrar una **tabla web** con los productos cuyo `stock < stock_mÃ­nimo`.

#### âœ… ImplementaciÃ³n paso a paso:

1. **Ruta nueva en `web_interface.py`:**

```python
@router.get("/web/alerta_stock", response_class=HTMLResponse)
def low_stock_report(request: Request, db: Session = Depends(get_db)):
    repo = ProductoRepository(db)
    low_stock_products = repo.get_low_stock_products()
    return templates.TemplateResponse("alerta_stock.html", {
        "request": request,
        "productos": low_stock_products
    })
```

2. **MÃ©todo en `ProductoRepository`:**

```python
def get_low_stock_products(self) -> list[Producto]:
    productos = self.db.query(ProductoORM).filter(ProductoORM.stock < ProductoORM.stock_minimo).all()
    return [producto_orm_to_domain(p) for p in productos]
```

3. **Template `alerta_stock.html`:**

```html
{% extends "base.html" %}
{% block content %}
<h2>ğŸš¨ Productos con stock bajo</h2>
<table>
  <tr><th>ID</th><th>Nombre</th><th>Stock</th><th>MÃ­nimo</th></tr>
  {% for p in productos %}
    <tr>
      <td>{{ p.id }}</td>
      <td>{{ p.nombre }}</td>
      <td>{{ p.stock }}</td>
      <td>{{ p.stock_minimo }}</td>
    </tr>
  {% endfor %}
</table>
{% endblock %}
```

---

### ğŸ§© **Issue #2: Crear vista de movimientos recientes**

#### ğŸ“Œ Objetivo:

Mostrar los Ãºltimos **10 movimientos**, ordenados por fecha.

#### âœ… ImplementaciÃ³n paso a paso:

1. **Nueva ruta:**

```python
@router.get("/web/movimientos_recientes", response_class=HTMLResponse)
def recent_movements_view(request: Request, db: Session = Depends(get_db)):
    repo = MovimientoRepository(db)
    recent = repo.get_recent_movements(limit=10)
    return templates.TemplateResponse("movimientos_recientes.html", {
        "request": request,
        "movimientos": recent
    })
```

2. **MÃ©todo en `MovimientoRepository`:**

```python
def get_recent_movements(self, limit: int = 10) -> list[Movimiento]:
    movimientos = self.db.query(MovimientoORM).order_by(MovimientoORM.timestamp.desc()).limit(limit).all()
    return [movimiento_orm_to_domain(m) for m in movimientos]
```

3. **Template `movimientos_recientes.html`:**

```html
{% extends "base.html" %}
{% block content %}
<h2>ğŸ“„ Movimientos recientes</h2>
<table>
  <tr><th>ID</th><th>Producto</th><th>Tipo</th><th>Cantidad</th><th>Fecha</th></tr>
  {% for m in movimientos %}
    <tr>
      <td>{{ m.id }}</td>
      <td>{{ m.producto_id }}</td>
      <td>{{ m.tipo }}</td>
      <td>{{ m.cantidad }}</td>
      <td>{{ m.fecha }}</td>
    </tr>
  {% endfor %}
</table>
{% endblock %}
```

---

### ğŸ§© **Issue #3: Exportar movimientos a CSV**

#### ğŸ“Œ Objetivo:

Permitir que se descargue un archivo `.csv` con los movimientos.

#### âœ… ImplementaciÃ³n:

1. **Nueva ruta en `web_interface.py`:**

```python
@router.get("/web/exportar_movimientos_csv")
def export_csv(db: Session = Depends(get_db)):
    repo = MovimientoRepository(db)
    movimientos = repo.get_all_movements()

    output = io.StringIO()
    writer = csv.writer(output)
    writer.writerow(["ID", "Producto", "Tipo", "Cantidad", "Fecha"])
    for m in movimientos:
        writer.writerow([m.id, m.producto_id, m.tipo, m.cantidad, m.fecha])

    response = StreamingResponse(iter([output.getvalue()]),
                                 media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=movimientos.csv"
    return response
```

2. **Agregar mÃ©todo si no existe aÃºn en el repositorio:**

```python
def get_all_movements(self) -> list[Movimiento]:
    movimientos = self.db.query(MovimientoORM).order_by(MovimientoORM.fecha.desc()).all()
    return [movimiento_orm_to_domain(m) for m in movimientos]
```

---

### ğŸ§© **Issue #4: NavegaciÃ³n entre vistas**

#### ğŸ“Œ Objetivo:

Mejorar la usabilidad con enlaces entre secciones.

#### âœ… ImplementaciÃ³n:

1. **Editar `base.html` para tener navegaciÃ³n:**

```html
<nav>
  <a href="/web/productos">ğŸ“¦ Productos</a> |
  <a href="/web/movimientos">â• Registrar Movimiento</a> |
  <a href="/web/alerta_stock">ğŸš¨ Stock Bajo</a> |
  <a href="/web/movimientos_recientes">ğŸ“„ Movimientos Recientes</a> |
  <a href="/web/exportar_movimientos_csv">â¬‡ï¸ Exportar CSV</a>
</nav>
<hr>
```

---

## âœ… Paso 1: Implementar el cÃ³digo del Issue #1

### 1.1. **Agregar ruta en `web_interface.py`**

UbicaciÃ³n: `app/routers/web_interface.py`

```python
@router.get("/web/alerta_stock", response_class=HTMLResponse)
def low_stock_report(request: Request, db: Session = Depends(get_db)):
    repo = ProductoRepository(db)
    low_stock_products = repo.get_low_stock_products()
    return templates.TemplateResponse("alerta_stock.html", {
        "request": request,
        "productos": low_stock_products
    })
```

---

### 1.2. **Agregar mÃ©todo en `ProductoRepository`**

UbicaciÃ³n: `app/repositories/producto_repository.py`

```python
def get_low_stock_products(self) -> list[Producto]:
    productos = self.db.query(ProductoORM).filter(ProductoORM.stock < ProductoORM.stock_minimo).all()
    return [producto_orm_to_domain(p) for p in productos]
```

---

### 1.3. **Crear template `alerta_stock.html`**

UbicaciÃ³n sugerida: `app/templates/alerta_stock.html`

```html
{% extends "base.html" %}

{% block content %}
<h2>ğŸš¨ Productos con stock bajo</h2>

{% if productos %}
<table border="1">
  <tr>
    <th>ID</th><th>Nombre</th><th>Stock</th><th>Stock mÃ­nimo</th>
  </tr>
  {% for p in productos %}
  <tr>
    <td>{{ p.id }}</td>
    <td>{{ p.nombre }}</td>
    <td>{{ p.stock }}</td>
    <td>{{ p.stock_minimo }}</td>
  </tr>
  {% endfor %}
</table>
{% else %}
<p>No hay productos con stock bajo âœ…</p>
{% endif %}

{% endblock %}
```

---

## âœ… Paso 2: Probar localmente

1. IniciÃ¡ el servidor:

```bash
uvicorn app.main:app --reload
```

2. IngresÃ¡ en tu navegador a:

```
http://localhost:8000/web/alerta_stock
```

VerificÃ¡ que se muestre la tabla con productos cuyo stock estÃ© por debajo del mÃ­nimo.

---

## âœ… Paso 3: Hacer el commit vinculado al issue

Para que GitHub **automÃ¡ticamente relacione el commit con el Issue #1** y lo marque como terminado si estÃ¡ en un *Project* o *Board*, usÃ¡ este formato de mensaje de commit:

```bash
git add .
git commit -m "feat: add low stock product report view

- Added /web/alerta_stock route
- Created repository method to fetch products with stock < stock_minimo
- New Jinja2 template for visualizing the alert

Closes #24"
```


### ğŸ” Flujo correcto que estÃ¡s usando (Â¡y es excelente!):

1. ğŸ§  **TrabajÃ¡s un Issue a la vez.**
2. ğŸ’» HacÃ©s los cambios en la rama del milestone (por ejemplo `semana-9`).
3. ğŸ’¬ HacÃ©s un **commit claro** con un mensaje que incluya `Closes #XX`.
   Ejemplo:

   ```bash
   git commit -m "feat: show low stock products in table - Closes #24"
   ```
4. ğŸš€ HacÃ©s `git push origin semana-9`.
5. âœ… GitHub:

   * Cierra el issue automÃ¡ticamente.
   * Mueve la tarjeta a "Done" si estÃ¡s usando GitHub Projects.

---

### ğŸ’¡ Â¿Por quÃ© es una buena prÃ¡ctica?

* **Claridad:** cada commit estÃ¡ relacionado con una tarea puntual.
* **AutomatizaciÃ³n:** los issues se cierran solos, sin que tengas que entrar a marcarlos.
* **Historial limpio:** si un profesor, revisor o compaÃ±ero ve el PR, puede entender de un vistazo quÃ© se hizo y por quÃ©.

---
### âœ… 1. **Â¿Por quÃ© no se dispararon los GitHub Actions?**

Esto puede pasar por dos razones comunes:

#### a. **EstÃ¡s trabajando en una rama (por ejemplo `semana-9`) y no en `main`**

GitHub Actions por defecto se disparan solo en ciertas ramas (como `main` o `master`), a menos que lo hayas configurado para que escuche otras ramas.

ğŸ” **SoluciÃ³n**:
VerificÃ¡ el archivo `.github/workflows/ci.yml` (o como se llame tu workflow). Asegurate de que tenga algo asÃ­:

```yaml
on:
  push:
    branches:
      - main
      - semana-9  # AgregÃ¡ esta lÃ­nea si estÃ¡s trabajando en esa rama
```

ğŸ’¡ Si eso no estÃ¡, los `push` a `semana-9` **no ejecutan Actions**.

---

### âœ… 2. **Â¿Por quÃ© te pide un Pull Request?**

Porque **estÃ¡s trabajando en una rama**, y para que el cambio se integre en `main`, GitHub te sugiere hacer un **Pull Request**.

ğŸŸ¢ Â¡Esto es correcto! Es lo que querÃ­amos practicar para el flujo real de desarrollo:

> Hacemos una rama por Milestone â†’ trabajamos en ella â†’ hacemos push â†’ y cuando terminamos, hacemos un **Pull Request a `main`**.

ğŸ” Luego, al aprobar y hacer merge, se dispara la action en `main`.

---

### âœ… 3. **Â¿Por quÃ© el Issue no se cerrÃ³ automÃ¡ticamente?**

Para que se cierre el issue **automÃ¡ticamente** al hacer merge del PR, el **mensaje de commit o PR** debe tener una palabra clave reconocida por GitHub.

### ğŸ”‘ Ejemplo correcto:

En el **mensaje del commit** o del **Pull Request**, ponÃ©:

```
Closes #24
```

(ğŸ§  Donde `#24` es el nÃºmero real del issue que querÃ©s cerrar).

ğŸ“Œ GitHub va a cerrar el issue **cuando el PR se fusione a `main`**, **no antes**. Por eso todavÃ­a lo ves como â€œen progresoâ€.

---

### ğŸ›  QuÃ© podÃ©s hacer ahora:

1. **VerificÃ¡ tu archivo `.yml` de Actions** y agregÃ¡ tu rama (`semana-9`) al `on.push.branches`.
2. **HacÃ© un Pull Request de `semana-9` hacia `main`**.
3. En el **mensaje del PR**, escribÃ­:

   ```
   Closes #24
   ```
4. AprobÃ¡ y hacÃ© el merge del PR.
5. VerificÃ¡ que se dispara el workflow y que el issue queda cerrado automÃ¡ticamente.

---


### ğŸ§© **1. Â¿Tenemos que hacer el Pull Request ahora que el issue estÃ¡ resuelto?**

âœ… **SÃ­, es el paso correcto.**
Aunque el issue estÃ© â€œfuncionalmenteâ€ resuelto, **el flujo moderno de trabajo** dice:

> ğŸ” El desarrollo ocurre en una rama â†’
> ğŸŸ¢ Se hace commit del cambio relacionado â†’
> ğŸ”ƒ **Se abre un Pull Request hacia `main`** â†’
> âœ… Se revisa, se mergea, y reciÃ©n ahÃ­ se considera "cerrado oficialmente".

ğŸ§  **El issue no se cierra automÃ¡ticamente** hasta que el PR sea mergeado a `main`.

> ğŸ’¬ Por eso es importante que el PR diga:
> `Closes #24` (o el nÃºmero del issue correspondiente)

---

### âš™ï¸ **2. Â¿Se van a ejecutar las GitHub Actions cuando se haga el PR o merge a `main`?**

SÃ­, **pero depende del archivo `.yml`** que tengas en `.github/workflows/`.

#### ğŸ” CASO A:

Si en tu `.yml` tenÃ©s algo como:

```yaml
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
```

ğŸ‘‰ Entonces:

* âœ… Se ejecuta cuando haces push a `main`
* âœ… Se ejecuta cuando haces PR hacia `main`
* âŒ **No se ejecuta en `semana-9` automÃ¡ticamente**

#### ğŸ’¡ RECOMENDACIÃ“N:

Para asegurar que tambiÃ©n se ejecuten mientras trabajÃ¡s en la rama (`semana-9`), podÃ©s agregarla asÃ­:

```yaml
on:
  push:
    branches:
      - main
      - semana-9
  pull_request:
    branches:
      - main
```

AsÃ­:

* PodÃ©s **ver errores antes del merge**
* Te asegurÃ¡s que todo estÃ¡ funcionando **sin romper `main`**

---

### âœ… En resumen:

| Tarea                     | Â¿Es necesaria? | Comentario                                                   |
| ------------------------- | -------------- | ------------------------------------------------------------ |
| Hacer Pull Request        | âœ… SÃ­           | Es lo que cierra el ciclo del issue                          |
| Incluir `Closes #XX`      | âœ… SÃ­           | Cierra el issue automÃ¡ticamente al merge                     |
| Editar `.yml` para rama   | ğŸŸ¡ Recomendado | No es obligatorio, pero Ãºtil para probar antes del merge     |
| Actions al merge a `main` | âœ… AutomÃ¡tico   | Si tenÃ©s bien configurado el `on.push` y/o `on.pull_request` |

---

<!--stackedit_data:
eyJoaXN0b3J5IjpbNTIxNDYzNjkzXX0=
-->