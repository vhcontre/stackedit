
# ğŸ“… Semana 2 â€“ DiseÃ±o del modelo de dominio

| Semana | Objetivos principales                                             |
| ------ | ----------------------------------------------------------------- |
| 2      | âš™ï¸ DiseÃ±o del modelo de dominio                                   |
|        | ğŸ“ Estructura inicial del backend (FastAPI + SQLAlchemy + SQLite) |
|        | ğŸ§ª Primeras pruebas unitarias simples                             |

### âœ… Â¿Es conveniente usar **SQLite** en lugar de MySQL?

**SÃ­, absolutamente.** Para un entorno educativo y de prÃ¡ctica como el tuyo, **SQLite es ideal** por varias razones:

### ğŸ”¹ Ventajas de usar SQLite

| Beneficio                          | Por quÃ© es Ãºtil en tu caso                         |
| ---------------------------------- | -------------------------------------------------- |
| ğŸ§± Sin servidor externo            | No necesita instalar ni levantar MySQL/PostgreSQL. |
| âš¡ FÃ¡cil de iniciar                 | Se crea como un simple archivo `.db`.              |
| ğŸ’ Ligero y portÃ¡til               | Funciona igual en cualquier sistema operativo.     |
| ğŸ’» Menos dependencias              | Solo necesitÃ¡s `sqlite3` y `SQLAlchemy`.           |
| ğŸ“š Ideal para FastAPI + SQLAlchemy | Se integra muy bien y rÃ¡pido para pruebas.         |

### ğŸ”» Â¿Y las desventajas?

| LimitaciÃ³n                                   | Â¿Importa en tu caso?          |
| -------------------------------------------- | ----------------------------- |
| No sirve para alta concurrencia              | âŒ No es necesario             |
| No soporta todas las funciones SQL avanzadas | âŒ No las usarÃ¡s probablemente |
| No se usa en producciÃ³n real                 | âœ… Pero no es el objetivo      |

âœ… **ConclusiÃ³n:** Usar **SQLite en desarrollo** es **totalmente recomendable**. Si querÃ©s, podÃ©s dejar la base preparada para cambiar a MySQL mÃ¡s adelante (con configuraciÃ³n en `.env`).

---

## ğŸ“˜ Contenido en Markdown: Modelo de Dominio y Casos de Uso

### ğŸ“„ `docs/semana-01/modelo-dominio.md`

```markdown
# ğŸ§© Modelo de Dominio - Sistema de Inventario

## Entidades principales

### ğŸ›’ Producto
- `id` (int)
- `nombre` (str)
- `sku` (str, Ãºnico)
- `descripcion` (str, opcional)
- `stock_global` (int, calculado)

### ğŸ¢ DepÃ³sito
- `id` (int)
- `nombre` (str)
- `ubicacion` (str)

### ğŸ” Movimiento de Stock
- `id` (int)
- `producto_id` (FK Producto)
- `deposito_origen_id` (FK DepÃ³sito, opcional)
- `deposito_destino_id` (FK DepÃ³sito, opcional)
- `cantidad` (int)
- `fecha` (datetime)
- `tipo` (str: 'ingreso', 'egreso', 'traslado')

## Relaciones

- Un `Producto` puede tener movimientos de stock (ingresos, egresos, traslados).
- Un `Movimiento` puede estar vinculado a uno o dos depÃ³sitos.
```

---

### ğŸ“„ `docs/semana-01/casos-de-uso.md`

```markdown
# âœ… Casos de Uso - Sistema de Inventario

## ğŸ§â€â™‚ï¸ Actores
- **Administrador**: gestiona productos y depÃ³sitos.
- **Operario**: realiza movimientos de stock.

## ğŸ”¹ Casos de uso

### 1. Registrar producto
- Actor: Administrador
- DescripciÃ³n: Crea un nuevo producto en el sistema.
- Flujo: Ingresar nombre, SKU, descripciÃ³n.

---

### 2. Registrar depÃ³sito
- Actor: Administrador
- DescripciÃ³n: Crea un nuevo depÃ³sito para almacenar productos.

---

### 3. Ingresar stock
- Actor: Operario
- DescripciÃ³n: Registra el ingreso de cierto producto a un depÃ³sito.

---

### 4. Egresar stock
- Actor: Operario
- DescripciÃ³n: Registra la salida de un producto desde un depÃ³sito.

---

### 5. Trasladar producto
- Actor: Operario
- DescripciÃ³n: Mueve stock entre depÃ³sitos.

---

### 6. Consultar inventario
- Actor: Todos
- DescripciÃ³n: Muestra el stock total por producto y por depÃ³sito.
```

---



## ğŸ§© **Modelo de clases: Sistema de Inventario + Seguridad**

Incluye:

* Clases para:

  * `Producto`, `Deposito`, `Movimiento`
  * `Usuario`, `Rol` y `AsociaciÃ³n Usuario-Rol`
* Relaciones completas y buenas prÃ¡cticas con SQLAlchemy ORM
* Listo para usar con SQLite y escalar a cualquier RDBMS

---

### ğŸ“ Estructura sugerida

```bash
backend/
â””â”€â”€ app/
    â””â”€â”€ db/
        â””â”€â”€ models/
            â”œâ”€â”€ base.py
            â”œâ”€â”€ producto.py
            â”œâ”€â”€ deposito.py
            â”œâ”€â”€ movimiento.py
            â”œâ”€â”€ usuario.py
            â””â”€â”€ __init__.py
```

---

## âœ… `base.py` â€“ Base comÃºn

Perfecto. AquÃ­ tenÃ©s el contenido completo y profesional de tu archivo `base.py`, con los mÃ©todos adicionales Ãºtiles para depuraciÃ³n, comparaciÃ³n, hashing y serializaciÃ³n. Listo para copiar y usar en tu proyecto educativo.

---

### âœ… `app/db/models/base.py`

```python
# app/db/models/base.py

from sqlalchemy.orm import DeclarativeBase
from sqlalchemy import Column, Integer
import json

class Base(DeclarativeBase):
    """Clase base para todos los modelos, con atributos y mÃ©todos comunes."""

    id = Column(Integer, primary_key=True, index=True)

    def __repr__(self):
        return f"<{self.__class__.__name__}(id={self.id})>"

    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return self.id == other.id
        return False

    def __hash__(self):
        return hash((self.__class__, self.id))

    def to_dict(self):
        """Devuelve una representaciÃ³n en diccionario del modelo."""
        return {
            column.name: getattr(self, column.name)
            for column in self.__table__.columns
        }

    def to_json(self):
        """Devuelve una representaciÃ³n JSON del modelo."""
        return json.dumps(self.to_dict(), default=str)
```

---

### ğŸ§  Â¿QuÃ© resuelve?

| FunciÃ³n     | Para quÃ© sirve                                |
| ----------- | --------------------------------------------- |
| `id`        | ID comÃºn para todas las tablas                |
| `__repr__`  | Te muestra algo Ãºtil en logs o consola        |
| `__eq__`    | Compara objetos por clase e ID                |
| `__hash__`  | Permite usar objetos como claves en sets/maps |
| `to_dict()` | Muy Ãºtil para debugging o APIs                |
| `to_json()` | ConvertÃ­ modelos a JSON fÃ¡cilmente            |

---

Con esto ya tenÃ©s una **clase base profesional, clara y Ãºtil**, ideal para enseÃ±ar buenas prÃ¡cticas en ingenierÃ­a de software. Â¿QuerÃ©s que te genere ahora los `schemas` Pydantic correspondientes o los primeros endpoints con FastAPI?


---

## âœ… `producto.py`

```python
# app/db/models/producto.py
from sqlalchemy import Column, Integer, String
from app.db.models.base import Base

class Producto(Base):
    __tablename__ = "productos"
    
    nombre = Column(String, nullable=False)
    sku = Column(String, unique=True, nullable=False)
    descripcion = Column(String)
```

---

## âœ… `deposito.py`

```python
# app/db/models/deposito.py
from sqlalchemy import Column, Integer, String
from app.db.models.base import Base

class Deposito(Base):
    __tablename__ = "depositos"
    
    nombre = Column(String, nullable=False)
    ubicacion = Column(String)
```

---

## âœ… `movimiento.py`

```python
# app/db/models/movimiento.py
from sqlalchemy import Column, Integer, ForeignKey, DateTime, Enum
from sqlalchemy.orm import relationship
from datetime import datetime
from enum import Enum as PyEnum

from app.db.models.base import Base

class TipoMovimiento(PyEnum):
    ingreso = "ingreso"
    egreso = "egreso"
    traslado = "traslado"

class Movimiento(Base):
    __tablename__ = "movimientos"
    
    producto_id = Column(Integer, ForeignKey("productos.id"), nullable=False)
    deposito_origen_id = Column(Integer, ForeignKey("depositos.id"), nullable=True)
    deposito_destino_id = Column(Integer, ForeignKey("depositos.id"), nullable=True)
    cantidad = Column(Integer, nullable=False)
    fecha = Column(DateTime, default=datetime.utcnow)
    tipo = Column(Enum(TipoMovimiento), nullable=False)

    producto = relationship("Producto")
    deposito_origen = relationship("Deposito", foreign_keys=[deposito_origen_id])
    deposito_destino = relationship("Deposito", foreign_keys=[deposito_destino_id])
```

---

## âœ… `usuario.py` (seguridad)

```python
# app/db/models/usuario.py
from sqlalchemy import Column, Integer, String, Boolean, Table, ForeignKey
from sqlalchemy.orm import relationship
from app.db.models.base import Base

# Tabla intermedia Usuario-Rol
usuario_rol = Table(
    "usuario_rol",
    Base.metadata,
    Column("usuario_id", ForeignKey("usuarios.id"), primary_key=True),
    Column("rol_id", ForeignKey("roles.id"), primary_key=True)
)

class Usuario(Base):
    __tablename__ = "usuarios"

    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True, nullable=False)
    email = Column(String, unique=True, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)

    roles = relationship("Rol", secondary=usuario_rol, back_populates="usuarios")

class Rol(Base):
    __tablename__ = "roles"

    id = Column(Integer, primary_key=True)
    nombre = Column(String, unique=True, nullable=False)

    usuarios = relationship("Usuario", secondary=usuario_rol, back_populates="roles")
```

---

## ğŸ›¡ï¸ Seguridad adicional (opcional futuro)

MÃ¡s adelante podÃ©s usar FastAPI con OAuth2/JWT y esta estructura ya se adapta fÃ¡cilmente.

---

Perfecto, vamos paso a paso. Como ya tenÃ©s el modelo de clases listo, ahora te voy a ayudar a completar lo necesario para que **puedas probar todo eso y ver cÃ³mo se crea la base de datos automÃ¡ticamente con SQLite.**

---

## ğŸ¯ Objetivo inmediato

1. Crear automÃ¡ticamente las tablas en SQLite.
2. Tener un script inicial que puedas ejecutar con Python.
3. Entender cÃ³mo probar que todo funciona.

---

## âœ… Paso 1: AsegurÃ¡ dependencias en `requirements.txt`

Si todavÃ­a no lo hiciste, tu archivo `requirements.txt` debe incluir al menos esto:

```txt
fastapi
uvicorn
sqlalchemy
pydantic
python-dotenv
```

Y si vas a usar SQLite (no hace falta instalar nada mÃ¡s porque viene con Python).

---

## âœ… Paso 2: Archivo `create_db.py`

CreÃ¡ este archivo en `backend/app/create_db.py`:

```python
# app/create_db.py

from app.db.models.base import Base
from app.db.models import producto, deposito, movimiento, usuario
from sqlalchemy import create_engine
import os

# Si usÃ¡s dotenv (.env), esto tambiÃ©n puede venir de allÃ­.
DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///./test.db")

engine = create_engine(DATABASE_URL, echo=True)

def create_database():
    print("Creando base de datos...")
    Base.metadata.create_all(bind=engine)
    print("Listo âœ…")

if __name__ == "__main__":
    create_database()
```

---

## âœ… Paso 3: Archivo `.env`

Ubicado en `backend/.env`:

```env
DATABASE_URL=sqlite:///./test.db
```

---

## âœ… Paso 4: Ejecutar

AbrÃ­ una terminal en `backend/` y ejecutÃ¡:

```bash
python -m app.create_db
```

Esto deberÃ­a:

* Crear un archivo `test.db` (base de datos SQLite).
* Mostrar en consola cÃ³mo SQLAlchemy crea todas las tablas (`productos`, `depositos`, etc).

---

## âœ… Paso 5: VerificÃ¡ con DB Browser for SQLite

Si querÃ©s ver visualmente el resultado:

1. Instalar [DB Browser for SQLite](https://sqlitebrowser.org/dl/)
2. AbrÃ­s `test.db` desde ahÃ­ y vas a ver las tablas creadas con los campos que definiste.

---
### Clases
```mermaid
classDiagram
    class Usuario {
        +int id
        +string username
        +string email
        +string hashed_password
        +bool is_active
    }
    class Rol {
        +int id
        +string nombre
    }
    class UsuarioRol {
        +int usuario_id
        +int rol_id
    }
    class Producto {
        +int id
        +string nombre
        +string sku
        +string descripcion
    }
    class Deposito {
        +int id
        +string nombre
        +string ubicacion
    }
    class Movimiento {
        +int id
        +int producto_id
        +int deposito_origen_id
        +int deposito_destino_id
        +int cantidad
        +datetime fecha
        +string tipo
    }

    Usuario "1" -- "*" UsuarioRol : tiene
    Rol "1" -- "*" UsuarioRol : tiene

    Producto "1" -- "*" Movimiento : relacionado
    Deposito "1" -- "*" Movimientoorigen"
    Deposito "1" -- "*" M : ovimient- : destino
```

### DER
```mermaid

erDiagram

USUARIO {

int  id  PK

string  username

string  email

string  hashed_password

bool  is_active

}

ROL {

int  id  PK

string  nombre

}

USUARIO_ROL {

int  usuario_id  FK

int  rol_id  FK

}

PRODUCTO {

int  id  PK

string  nombre

string  sku

string  descripcion

}

DEPOSITO {

int  id  PK

string  nombre

string  ubicacion

}

MOVIMIENTO {

int  id  PK

int  producto_id  FK

int  deposito_origen_id  FK

int  deposito_destino_id  FK

int  usuario_id  FK

int  cantidad

datetime  fecha

enum  tipo

}

  

USUARIO ||--o{ USUARIO_ROL : "posee"

ROL ||--o{ USUARIO_ROL : "asignado  a"

USUARIO ||--o{ MOVIMIENTO : "realiza"

PRODUCTO ||--o{ MOVIMIENTO : "registrado  en"

DEPOSITO ||--o{ MOVIMIENTO : "origen"

DEPOSITO ||--o{ MOVIMIENTO : "destino"

```



----------

### âœ… **Ãšltimo estado conocido del proyecto**

-   Ya tienes armada tu **base de datos** con **SQLAlchemy ORM**.
    
-   Todos los modelos estÃ¡n en `app/db/models/` y se ven asÃ­: `Producto`, `Movimiento`, `Usuario`, etc.
    
-   Probablemente el archivo `init_db()` ya te creÃ³ las tablas correctamente.
    

----------

### ğŸ§± Â¿QuÃ© es lo que sigue?

Ahora vas a **separar las capas del modelo** para tener un diseÃ±o limpio y mantenible:

#### 1. **ORM** (`app/db/models/`)

-   Define cÃ³mo se almacenan los datos en la base de datos (ya lo tenÃ©s).
    
-   Son clases que heredan de `Base`, usan `Column`, `ForeignKey`, `relationship`, etc.
    
-   Ejemplo: `ProductoORM`, `MovimientoORM`, etc.
    

#### 2. **Domain models (entidades)** (`app/domain/models/`)

-   Representan el modelo de negocio **sin acoplamiento a SQLAlchemy**.
    
-   No tienen decoradores ni columnas; son clases simples de Python (POPOs).
    
-   Se usan para aplicar lÃ³gica de negocio pura.
    
-   Ejemplo: `Producto`, `Movimiento`, `Usuario`, etc.
    

#### 3. **Schemas (DTOs)** (`app/schemas/`)

-   Son modelos **Pydantic** que se usan para validar y serializar datos de entrada/salida (API, formularios, etc.).
    
-   Ayudan a definir quÃ© campos esperamos recibir o enviar.
    
-   Se pueden basar en el domain model o directamente en el ORM si es necesario.
    

----------

### ğŸ”„ RelaciÃ³n entre las capas

```plaintext
       Entrada/Salida (FastAPI, API, consola)
                       â¬‡
                   [ Pydantic ]
                      Schemas
                       â¬‡
       [ Dominio / Entidades de negocio ]
                 (clases puras)
                       â¬‡
               [ ORM / Persistencia ]
         (SQLAlchemy: db/models/*.py)

```

----------

### âœ… Â¿QuÃ© necesitamos ahora?

Si querÃ©s, pasame la estructura del modelo de base de datos que tenÃ©s (las clases ORM), asÃ­ armamos:

1.  Las entidades de dominio (`domain/models/`)
    
2.  Los esquemas Pydantic (`schemas/`)
    
3.  Y los _mappers_ para convertir entre capas
    

### ğŸ“ Estructura sugerida

```
project/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ db/
â”‚   â”‚   â””â”€â”€ models/          â† Modelos ORM (SQLAlchemy)
â”‚   â”œâ”€â”€ domain/
â”‚   â”‚   â””â”€â”€ models/          â† Modelos de dominio (sin decoradores ni ORM)
â”‚   â””â”€â”€ schemas/             â† Esquemas Pydantic (para entrada/salida de datos)

```

----------

### âœ… Â¿QuÃ© es un modelo de dominio?

Un modelo de dominio representa **la lÃ³gica del negocio** en su forma mÃ¡s limpia, sin preocuparse por cÃ³mo se guarda en la base de datos (ORM) ni cÃ³mo se valida/transfiere (Pydantic).

----------

### ğŸ› ï¸ Vamos a crear el modelo de dominio `Producto`

#### ORM (`app/db/models/producto.py`)

```python
class ProductoORM(Base):
    __tablename__ = "productos"
    
    nombre = Column(String, nullable=False)
    sku = Column(String, unique=True, nullable=False)
    descripcion = Column(String)

    movimientos = relationship("Movimiento", back_populates="producto")

```

#### Dominio (`app/domain/models/producto.py`)

```python
from dataclasses import dataclass

@dataclass
class Producto:
    id: int
    nombre: str
    sku: str
    descripcion: str | None = None

```

----------

Perfecto, gracias por confirmar. Si ya tenemos todas las entidades con sus tres capas completas (ORM, domain y Pydantic schemas), te propongo hacer un **resumen de lo que tenÃ©s armado** y verificar que estÃ© todo listo para trabajar sobre los servicios (casos de uso) o la API.

----------

### ğŸ“¦ Estructura completa actual

#### 1. **Modelos ORM** â€“ `app/db/models/`

Estos representan la estructura de la base de datos usando SQLAlchemy:

-   `ProductoORM`
    
-   `MovimientoORM`
    
-   `DepositoORM`
    
-   `UsuarioORM`
    
-   `RolORM`
    

#### 2. **Modelos de dominio** â€“ `domain/models/`

Representan las entidades "limpias", desacopladas de frameworks y DB:

-   `Producto`
    
-   `Movimiento`
    
-   `Deposito`
    
-   `Usuario`
    
-   `Rol`
    

#### 3. **Schemas Pydantic** â€“ `app/schemas/`

Se usan para validaciÃ³n, entrada/salida de datos y serializaciÃ³n:

-   `ProductoCreate`, `ProductoRead`
    
-   `MovimientoCreate`, `MovimientoRead`
    
-   `DepositoCreate`, `DepositoRead`
    
-   `UsuarioCreate`, `UsuarioRead`, `UsuarioWithRoles`
    
-   `RolCreate`, `RolRead`
    

----------

### âœ… Siguientes pasos posibles

Ahora que tenÃ©s el modelo completo, podÃ©s avanzar con:

1.  **Casos de uso / lÃ³gica de negocio**  
    En `services/` o `use_cases/`, donde usÃ¡s los modelos de `domain/models/`.
    
2.  **Repositorios / Persistencia**  
    Implementaciones que traducen entre domain y ORM (usando mappers).
    
3.  **Rutas FastAPI (API)**  
    Usan los schemas Pydantic para definir entrada/salida y llaman a los servicios.
    
4.  **Testeo**  
    PodÃ©s testear cada capa por separado: dominio, persistencia, API, etc.
    

----------

Â¡Perfecto! Entonces estÃ¡s en una etapa muy bien definida del desarrollo.  
Con lo que ya tenemos hecho, podemos marcar lo siguiente:

----------

### âœ… Estado actual segÃºn tu planificaciÃ³n

Etapa

Estado

âš™ï¸ DiseÃ±o del modelo de dominio

âœ… Completo (con `domain/models/`)

ğŸ“ Estructura inicial del backend (FastAPI + SQLAlchemy + SQLite)

âœ… Completo (ya podÃ©s crear la DB y tenÃ©s modelos ORM)

ğŸ§ª Primeras pruebas unitarias simples

ğŸ”œ PrÃ³ximo paso

----------

### ğŸ”œ Siguiente sugerencia: pruebas unitarias simples

Ahora podrÃ­amos:

#### 1. **Definir el entorno de testing**

-   Usar `pytest`
    
-   Crear un archivo `tests/conftest.py` para configurar una base de datos SQLite en memoria
    
-   Usar `TestClient` de FastAPI si querÃ©s testear endpoints (mÃ¡s adelante)
    

#### 2. **Crear tests para el dominio**

Por ejemplo, en `tests/test_producto.py`:

```python
from domain.models.producto import Producto

def test_producto_creacion():
    producto = Producto(id=1, nombre="Coca", sku="COC-123", descripcion="Bebida gaseosa")
    assert producto.nombre == "Coca"
    assert producto.sku == "COC-123"

```

#### 3. **Tests para esquemas Pydantic**

PodÃ©s verificar validaciones automÃ¡ticas:

```python
from app.schemas.producto import ProductoCreate
import pytest

def test_producto_create_valido():
    data = ProductoCreate(nombre="Pepsi", sku="PEP-001", descripcion="Bebida")
    assert data.nombre == "Pepsi"

def test_producto_create_invalido():
    with pytest.raises(ValueError):
        ProductoCreate(nombre="", sku="")  # nombre vacÃ­o no deberÃ­a pasar

```

----------
Perfecto. Vamos a preparar un entorno de pruebas profesional y reutilizable con `pytest`, incluyendo un `conftest.py` para inicializar una base de datos de pruebas en memoria.

----------

## âœ… Paso 1: Instalar dependencias necesarias

Si no las tenÃ©s todavÃ­a:

```bash
pip install pytest pytest-asyncio httpx

```

Para manejar una base de datos SQLite temporal:

```bash
pip install sqlalchemy aiosqlite

```

----------

## âœ… Paso 2: Crear estructura de pruebas

Asegurate de tener esta estructura mÃ­nima:

```
backend/
â”œâ”€â”€ app/
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ conftest.py
â”‚   â”œâ”€â”€ db/
â”‚   â”œâ”€â”€ api/
â”‚   â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ domain/
â”‚   â””â”€â”€ schemas/

```

----------

## âœ… Paso 3: `conftest.py`

Crearemos una base de datos en memoria, con una sesiÃ³n de SQLAlchemy temporal y opcionalmente una instancia de la app FastAPI si vas a testear la API.

```python
# tests/conftest.py

import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.pool import StaticPool

from app.db.models.base import Base
from app.db import base as db_base  # init_db, get_engine, etc.
from fastapi.testclient import TestClient
from app.main import app  # Asumimos que tenÃ©s un app/main.py con FastAPI

# âš™ï¸ Engine de prueba en memoria
TEST_DATABASE_URL = "sqlite:///:memory:"

engine_test = create_engine(
    TEST_DATABASE_URL,
    connect_args={"check_same_thread": False},
    poolclass=StaticPool,
)

# SesiÃ³n de prueba
TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine_test)


# ğŸ”§ Setup inicial de base de datos de prueba
@pytest.fixture(scope="session", autouse=True)
def setup_test_db():
    Base.metadata.create_all(bind=engine_test)
    yield
    Base.metadata.drop_all(bind=engine_test)


# ğŸ§ª Fixture de sesiÃ³n para los tests
@pytest.fixture()
def db_session():
    session = TestingSessionLocal()
    try:
        yield session
    finally:
        session.close()


# ğŸš€ Cliente para probar la API
@pytest.fixture()
def client():
    def override_get_db():
        db = TestingSessionLocal()
        try:
            yield db
        finally:
            db.close()

    # Sobreescribimos la dependencia de DB de FastAPI
    app.dependency_overrides[db_base.get_db] = override_get_db

    with TestClient(app) as c:
        yield c

```

----------

## âœ… Paso 4: Asegurate que `app/main.py` tenga esta estructura mÃ­nima

```python
# app/main.py
from fastapi import FastAPI
from app.db.base import get_db

app = FastAPI()

# Tus routers se incluirÃ¡n aquÃ­...
# app.include_router(...)


```

----------
Â¡Genial! Para ejecutar tus pruebas con **pytest**, seguÃ­ estos pasos:

----------

### âœ… 1. Asegurate de tener `pytest` instalado

EjecutÃ¡ en tu terminal:

```bash
pip install pytest

```

----------

### âœ… 2. Estructura recomendada del proyecto

Tu proyecto debe tener esta estructura mÃ­nima para que `pytest` funcione correctamente:

```
backend/
â”œâ”€â”€ app/
â”‚   â””â”€â”€ ...
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ api/
â”‚   â”œâ”€â”€ db/
â”‚   â””â”€â”€ schemas/
â”œâ”€â”€ conftest.py
â”œâ”€â”€ pytest.ini  â† (opcional pero recomendado)
â””â”€â”€ ...

```

----------

### âœ… 3. Crear archivo `pytest.ini` (opcional pero Ãºtil)

En la raÃ­z del proyecto (donde estÃ¡ `tests/`), creÃ¡ `pytest.ini` con este contenido:

```ini
# pytest.ini
[pytest]
minversion = 6.0
addopts = -ra -q
testpaths = 
    tests
python_files = test_*.py

```

----------

### âœ… 4. Ejecutar las pruebas

Desde la raÃ­z del proyecto (donde estÃ¡ la carpeta `tests/`), corrÃ©:

```bash
pytest

```

O para ejecutar solo un archivo de prueba, por ejemplo:

```bash
pytest tests/schemas/test_producto_schema.py

```

----------

### âœ… 5. Si te tira error de `ModuleNotFoundError`

EjecutÃ¡ con el flag `PYTHONPATH`:

```bash
PYTHONPATH=./ pytest

```

En Windows:

```cmd
set PYTHONPATH=.
pytest

```



----------

### ğŸ¯ Objetivo del trabajo realizado

> **DiseÃ±ar y validar los esquemas de datos (schemas) para la entidad `Producto` utilizando Pydantic, como parte de una arquitectura en capas para un sistema de inventario.**
> 
> Se definieron modelos de entrada (`ProductoCreate`), de salida (`ProductoOut`) y de actualizaciÃ³n parcial (`ProductoUpdate`) con validaciones explÃ­citas, como longitud mÃ­nima y tipos de datos. AdemÃ¡s, se desarrollaron pruebas unitarias con `pytest` para asegurar la integridad de estos esquemas y su compatibilidad con objetos ORM.

----------

### âœ… Resultado

-   Modelos Pydantic organizados y validados.
    
-   Soporte para entradas tipo API y ORM.
    
-   Pruebas automÃ¡ticas que cubren:
    
    -   Casos vÃ¡lidos.
        
    -   Errores por datos incompletos o mal tipados.
        
    -   Restricciones como campos vacÃ­os.
        

----------

## Entidad **`Deposito`**.

Vamos a generar:

1.  ğŸ“„ Modelos **Pydantic**: `DepositoCreate`, `DepositoUpdate`, `DepositoOut`.
    
2.  âœ… Validaciones mÃ­nimas (campos obligatorios, tipo, longitud).
    
3.  ğŸ§ª Tests en `tests/schemas/test_deposito_schema.py`.
    
4.  ğŸ§¾ Bloque de **objetivo** al finalizar.
    

----------

### ğŸ“„ `app/schemas/deposito.py`

```python
from pydantic import BaseModel, ConfigDict, Field
from typing import Optional


class DepositoBase(BaseModel):
    nombre: str = Field(..., min_length=1)
    direccion: Optional[str] = None


class DepositoCreate(DepositoBase):
    pass


class DepositoUpdate(BaseModel):
    nombre: Optional[str] = Field(default=None, min_length=1)
    direccion: Optional[str] = None


class DepositoOut(DepositoBase):
    id: int
    model_config = ConfigDict(from_attributes=True)

```

----------

### ğŸ§ª `tests/schemas/test_deposito_schema.py`

```python
import pytest
from pydantic import ValidationError
from app.schemas.deposito import DepositoCreate, DepositoUpdate, DepositoOut


def test_deposito_create_valido():
    data = {"nombre": "DepÃ³sito Central", "direccion": "Av. Siempre Viva 123"}
    deposito = DepositoCreate(**data)
    assert deposito.nombre == data["nombre"]
    assert deposito.direccion == data["direccion"]


def test_deposito_create_invalido_faltan_campos():
    with pytest.raises(ValidationError):
        DepositoCreate()


def test_deposito_create_nombre_vacio():
    with pytest.raises(ValidationError):
        DepositoCreate(nombre="", direccion="Calle Falsa")


def test_deposito_update_parcial_valido():
    deposito = DepositoUpdate(nombre="Nuevo Nombre")
    assert deposito.nombre == "Nuevo Nombre"
    assert deposito.direccion is None


def test_deposito_update_nombre_vacio():
    with pytest.raises(ValidationError):
        DepositoUpdate(nombre="")


def test_deposito_out_from_orm():
    class DummyDeposito:
        def __init__(self, id, nombre, direccion):
            self.id = id
            self.nombre = nombre
            self.direccion = direccion

    orm_obj = DummyDeposito(1, "DepÃ³sito Norte", "Ruta 8")
    deposito_out = DepositoOut.model_validate(orm_obj)
    assert deposito_out.id == 1
    assert deposito_out.nombre == "DepÃ³sito Norte"
    assert deposito_out.direccion == "Ruta 8"

```

----------

### ğŸ§¾ Objetivo del trabajo realizado â€“ `Deposito`

> **DiseÃ±ar y validar los esquemas de datos (schemas) para la entidad `Deposito` utilizando Pydantic, dentro de la arquitectura en capas del sistema de inventario.**
> 
> Se implementaron modelos para creaciÃ³n (`DepositoCreate`), actualizaciÃ³n (`DepositoUpdate`) y salida (`DepositoOut`), con validaciones mÃ­nimas como longitud de nombre y tipos requeridos. Se crearon pruebas unitarias que aseguran la correcta validaciÃ³n de datos y la compatibilidad con objetos ORM.

----------

Â¿Seguimos con `Movimiento` ahora?


<!--stackedit_data:
eyJoaXN0b3J5IjpbMjA1MTczMjI4NSwtMzc1NDk2MzMsLTU3OD
M1ODg1MiwxMjQ0NjU5NDQyLDMwODEzNjUwMywtMTIwNTc5OTMz
LC0xMTEwNjc2NTUsNTk4MTE0MjYyXX0=
-->