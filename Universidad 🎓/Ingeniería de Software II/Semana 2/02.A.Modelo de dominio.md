
# üìÖ Semana 2 ‚Äì Dise√±o del modelo de dominio

## ‚úÖ ¬øEs conveniente usar **SQLite** en lugar de MySQL?

**S√≠, absolutamente.** Para un entorno educativo y de pr√°ctica como el tuyo, **SQLite es ideal** por varias razones:

### üîπ Ventajas de usar SQLite

| Beneficio                          | Por qu√© es √∫til en tu caso                         |
| ---------------------------------- | -------------------------------------------------- |
| üß± Sin servidor externo            | No necesita instalar ni levantar MySQL/PostgreSQL. |
| ‚ö° F√°cil de iniciar                 | Se crea como un simple archivo `.db`.              |
| üéí Ligero y port√°til               | Funciona igual en cualquier sistema operativo.     |
| üíª Menos dependencias              | Solo necesit√°s `sqlite3` y `SQLAlchemy`.           |
| üìö Ideal para FastAPI + SQLAlchemy | Se integra muy bien y r√°pido para pruebas.         |

### üîª ¬øY las desventajas?

| Limitaci√≥n                                   | ¬øImporta en tu caso?          |
| -------------------------------------------- | ----------------------------- |
| No sirve para alta concurrencia              | ‚ùå No es necesario             |
| No soporta todas las funciones SQL avanzadas | ‚ùå No las usar√°s probablemente |
| No se usa en producci√≥n real                 | ‚úÖ Pero no es el objetivo      |

‚úÖ **Conclusi√≥n:** Usar **SQLite en desarrollo** es **totalmente recomendable**. Si quer√©s, pod√©s dejar la base preparada para cambiar a MySQL m√°s adelante (con configuraci√≥n en `.env`).

---

## üìò Contenido en Markdown: Modelo de Dominio y Casos de Uso

### üìÑ `docs/semana-01/modelo-dominio.md`

```markdown
# üß© Modelo de Dominio - Sistema de Inventario

## Entidades principales

### üõí Producto
- `id` (int)
- `nombre` (str)
- `sku` (str, √∫nico)
- `descripcion` (str, opcional)
- `stock_global` (int, calculado)

### üè¢ Dep√≥sito
- `id` (int)
- `nombre` (str)
- `ubicacion` (str)

### üîÅ Movimiento de Stock
- `id` (int)
- `producto_id` (FK Producto)
- `deposito_origen_id` (FK Dep√≥sito, opcional)
- `deposito_destino_id` (FK Dep√≥sito, opcional)
- `cantidad` (int)
- `fecha` (datetime)
- `tipo` (str: 'ingreso', 'egreso', 'traslado')

## Relaciones

- Un `Producto` puede tener movimientos de stock (ingresos, egresos, traslados).
- Un `Movimiento` puede estar vinculado a uno o dos dep√≥sitos.
```

---

### üìÑ `docs/semana-01/casos-de-uso.md`

```markdown
# ‚úÖ Casos de Uso - Sistema de Inventario

## üßç‚Äç‚ôÇÔ∏è Actores
- **Administrador**: gestiona productos y dep√≥sitos.
- **Operario**: realiza movimientos de stock.

## üîπ Casos de uso

### 1. Registrar producto
- Actor: Administrador
- Descripci√≥n: Crea un nuevo producto en el sistema.
- Flujo: Ingresar nombre, SKU, descripci√≥n.

---

### 2. Registrar dep√≥sito
- Actor: Administrador
- Descripci√≥n: Crea un nuevo dep√≥sito para almacenar productos.

---

### 3. Ingresar stock
- Actor: Operario
- Descripci√≥n: Registra el ingreso de cierto producto a un dep√≥sito.

---

### 4. Egresar stock
- Actor: Operario
- Descripci√≥n: Registra la salida de un producto desde un dep√≥sito.

---

### 5. Trasladar producto
- Actor: Operario
- Descripci√≥n: Mueve stock entre dep√≥sitos.

---

### 6. Consultar inventario
- Actor: Todos
- Descripci√≥n: Muestra el stock total por producto y por dep√≥sito.
```

---



## üß© **Modelo de clases: Sistema de Inventario + Seguridad**

Incluye:

* Clases para:

  * `Producto`, `Deposito`, `Movimiento`
  * `Usuario`, `Rol` y `Asociaci√≥n Usuario-Rol`
* Relaciones completas y buenas pr√°cticas con SQLAlchemy ORM
* Listo para usar con SQLite y escalar a cualquier RDBMS

---

### üìÅ Estructura sugerida

```bash
backend/
‚îî‚îÄ‚îÄ app/
    ‚îî‚îÄ‚îÄ db/
        ‚îî‚îÄ‚îÄ models/
            ‚îú‚îÄ‚îÄ base.py
            ‚îú‚îÄ‚îÄ producto.py
            ‚îú‚îÄ‚îÄ deposito.py
            ‚îú‚îÄ‚îÄ movimiento.py
            ‚îú‚îÄ‚îÄ usuario.py
            ‚îî‚îÄ‚îÄ __init__.py
```

---

## ‚úÖ `base.py` ‚Äì Base com√∫n

Perfecto. Aqu√≠ ten√©s el contenido completo y profesional de tu archivo `base.py`, con los m√©todos adicionales √∫tiles para depuraci√≥n, comparaci√≥n, hashing y serializaci√≥n. Listo para copiar y usar en tu proyecto educativo.

---

### ‚úÖ `app/db/models/base.py`

```python
# app/db/models/base.py

from sqlalchemy.orm import DeclarativeBase
from sqlalchemy import Column, Integer
import json

class Base(DeclarativeBase):
    """Clase base para todos los modelos, con atributos y m√©todos comunes."""

    id = Column(Integer, primary_key=True, index=True)

    def __repr__(self):
        return f"<{self.__class__.__name__}(id={self.id})>"

    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return self.id == other.id
        return False

    def __hash__(self):
        return hash((self.__class__, self.id))

    def to_dict(self):
        """Devuelve una representaci√≥n en diccionario del modelo."""
        return {
            column.name: getattr(self, column.name)
            for column in self.__table__.columns
        }

    def to_json(self):
        """Devuelve una representaci√≥n JSON del modelo."""
        return json.dumps(self.to_dict(), default=str)
```

---

### üß† ¬øQu√© resuelve?

| Funci√≥n     | Para qu√© sirve                                |
| ----------- | --------------------------------------------- |
| `id`        | ID com√∫n para todas las tablas                |
| `__repr__`  | Te muestra algo √∫til en logs o consola        |
| `__eq__`    | Compara objetos por clase e ID                |
| `__hash__`  | Permite usar objetos como claves en sets/maps |
| `to_dict()` | Muy √∫til para debugging o APIs                |
| `to_json()` | Convert√≠ modelos a JSON f√°cilmente            |

---

Con esto ya ten√©s una **clase base profesional, clara y √∫til**, ideal para ense√±ar buenas pr√°cticas en ingenier√≠a de software. ¬øQuer√©s que te genere ahora los `schemas` Pydantic correspondientes o los primeros endpoints con FastAPI?


---

## ‚úÖ `producto.py`

```python
# app/db/models/producto.py
from sqlalchemy import Column, Integer, String
from app.db.models.base import Base

class Producto(Base):
    __tablename__ = "productos"
    
    nombre = Column(String, nullable=False)
    sku = Column(String, unique=True, nullable=False)
    descripcion = Column(String)
```

---

## ‚úÖ `deposito.py`

```python
# app/db/models/deposito.py
from sqlalchemy import Column, Integer, String
from app.db.models.base import Base

class Deposito(Base):
    __tablename__ = "depositos"
    
    nombre = Column(String, nullable=False)
    ubicacion = Column(String)
```

---

## ‚úÖ `movimiento.py`

```python
# app/db/models/movimiento.py
from sqlalchemy import Column, Integer, ForeignKey, DateTime, Enum
from sqlalchemy.orm import relationship
from datetime import datetime
from enum import Enum as PyEnum

from app.db.models.base import Base

class TipoMovimiento(PyEnum):
    ingreso = "ingreso"
    egreso = "egreso"
    traslado = "traslado"

class Movimiento(Base):
    __tablename__ = "movimientos"
    
    producto_id = Column(Integer, ForeignKey("productos.id"), nullable=False)
    deposito_origen_id = Column(Integer, ForeignKey("depositos.id"), nullable=True)
    deposito_destino_id = Column(Integer, ForeignKey("depositos.id"), nullable=True)
    cantidad = Column(Integer, nullable=False)
    fecha = Column(DateTime, default=datetime.utcnow)
    tipo = Column(Enum(TipoMovimiento), nullable=False)

    producto = relationship("Producto")
    deposito_origen = relationship("Deposito", foreign_keys=[deposito_origen_id])
    deposito_destino = relationship("Deposito", foreign_keys=[deposito_destino_id])
```

---

## ‚úÖ `usuario.py` (seguridad)

```python
# app/db/models/usuario.py
from sqlalchemy import Column, Integer, String, Boolean, Table, ForeignKey
from sqlalchemy.orm import relationship
from app.db.models.base import Base

# Tabla intermedia Usuario-Rol
usuario_rol = Table(
    "usuario_rol",
    Base.metadata,
    Column("usuario_id", ForeignKey("usuarios.id"), primary_key=True),
    Column("rol_id", ForeignKey("roles.id"), primary_key=True)
)

class Usuario(Base):
    __tablename__ = "usuarios"

    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True, nullable=False)
    email = Column(String, unique=True, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)

    roles = relationship("Rol", secondary=usuario_rol, back_populates="usuarios")

class Rol(Base):
    __tablename__ = "roles"

    id = Column(Integer, primary_key=True)
    nombre = Column(String, unique=True, nullable=False)

    usuarios = relationship("Usuario", secondary=usuario_rol, back_populates="roles")
```

---

## üõ°Ô∏è Seguridad adicional (opcional futuro)

M√°s adelante pod√©s usar FastAPI con OAuth2/JWT y esta estructura ya se adapta f√°cilmente.

---

Perfecto, vamos paso a paso. Como ya ten√©s el modelo de clases listo, ahora te voy a ayudar a completar lo necesario para que **puedas probar todo eso y ver c√≥mo se crea la base de datos autom√°ticamente con SQLite.**

---

## üéØ Objetivo inmediato

1. Crear autom√°ticamente las tablas en SQLite.
2. Tener un script inicial que puedas ejecutar con Python.
3. Entender c√≥mo probar que todo funciona.

---

## ‚úÖ Paso 1: Asegur√° dependencias en `requirements.txt`

Si todav√≠a no lo hiciste, tu archivo `requirements.txt` debe incluir al menos esto:

```txt
fastapi
uvicorn
sqlalchemy
pydantic
python-dotenv
```

Y si vas a usar SQLite (no hace falta instalar nada m√°s porque viene con Python).

---

## ‚úÖ Paso 2: Archivo `create_db.py`

Cre√° este archivo en `backend/app/create_db.py`:

```python
# app/create_db.py

from app.db.models.base import Base
from app.db.models import producto, deposito, movimiento, usuario
from sqlalchemy import create_engine
import os

# Si us√°s dotenv (.env), esto tambi√©n puede venir de all√≠.
DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///./test.db")

engine = create_engine(DATABASE_URL, echo=True)

def create_database():
    print("Creando base de datos...")
    Base.metadata.create_all(bind=engine)
    print("Listo ‚úÖ")

if __name__ == "__main__":
    create_database()
```

---

## ‚úÖ Paso 3: Archivo `.env`

Ubicado en `backend/.env`:

```env
DATABASE_URL=sqlite:///./test.db
```

---

## ‚úÖ Paso 4: Ejecutar

Abr√≠ una terminal en `backend/` y ejecut√°:

```bash
python -m app.create_db
```

Esto deber√≠a:

* Crear un archivo `test.db` (base de datos SQLite).
* Mostrar en consola c√≥mo SQLAlchemy crea todas las tablas (`productos`, `depositos`, etc).

---

## ‚úÖ Paso 5: Verific√° con DB Browser for SQLite

Si quer√©s ver visualmente el resultado:

1. Instalar [DB Browser for SQLite](https://sqlitebrowser.org/dl/)
2. Abr√≠s `test.db` desde ah√≠ y vas a ver las tablas creadas con los campos que definiste.

---
### Clases
```mermaid
classDiagram
    class Usuario {
        +int id
        +string username
        +string email
        +string hashed_password
        +bool is_active
    }
    class Rol {
        +int id
        +string nombre
    }
    class UsuarioRol {
        +int usuario_id
        +int rol_id
    }
    class Producto {
        +int id
        +string nombre
        +string sku
        +string descripcion
    }
    class Deposito {
        +int id
        +string nombre
        +string ubicacion
    }
    class Movimiento {
        +int id
        +int producto_id
        +int deposito_origen_id
        +int deposito_destino_id
        +int cantidad
        +datetime fecha
        +string tipo
    }

    Usuario "1" -- "*" UsuarioRol : tiene
    Rol "1" -- "*" UsuarioRol : tiene

    Producto "1" -- "*" Movimiento : relacionado
    Deposito "1" -- "*" Movimientoorigen"
    Deposito "1" -- "*" M : ovimient- : destino
```

### DER
```mermaid

erDiagram

USUARIO {

int  id  PK

string  username

string  email

string  hashed_password

bool  is_active

}

ROL {

int  id  PK

string  nombre

}

USUARIO_ROL {

int  usuario_id  FK

int  rol_id  FK

}

PRODUCTO {

int  id  PK

string  nombre

string  sku

string  descripcion

}

DEPOSITO {

int  id  PK

string  nombre

string  ubicacion

}

MOVIMIENTO {

int  id  PK

int  producto_id  FK

int  deposito_origen_id  FK

int  deposito_destino_id  FK

int  usuario_id  FK

int  cantidad

datetime  fecha

enum  tipo

}

  

USUARIO ||--o{ USUARIO_ROL : "posee"

ROL ||--o{ USUARIO_ROL : "asignado  a"

USUARIO ||--o{ MOVIMIENTO : "realiza"

PRODUCTO ||--o{ MOVIMIENTO : "registrado  en"

DEPOSITO ||--o{ MOVIMIENTO : "origen"

DEPOSITO ||--o{ MOVIMIENTO : "destino"

```



----------

### ‚úÖ **√öltimo estado conocido del proyecto**

-   Ya tienes armada tu **base de datos** con **SQLAlchemy ORM**.
    
-   Todos los modelos est√°n en `app/db/models/` y se ven as√≠: `Producto`, `Movimiento`, `Usuario`, etc.
    
-   Probablemente el archivo `init_db()` ya te cre√≥ las tablas correctamente.
    

----------

### üß± ¬øQu√© es lo que sigue?

Ahora vas a **separar las capas del modelo** para tener un dise√±o limpio y mantenible:

#### 1. **ORM** (`app/db/models/`)

-   Define c√≥mo se almacenan los datos en la base de datos (ya lo ten√©s).
    
-   Son clases que heredan de `Base`, usan `Column`, `ForeignKey`, `relationship`, etc.
    
-   Ejemplo: `ProductoORM`, `MovimientoORM`, etc.
    

#### 2. **Domain models (entidades)** (`app/domain/models/`)

-   Representan el modelo de negocio **sin acoplamiento a SQLAlchemy**.
    
-   No tienen decoradores ni columnas; son clases simples de Python (POPOs).
    
-   Se usan para aplicar l√≥gica de negocio pura.
    
-   Ejemplo: `Producto`, `Movimiento`, `Usuario`, etc.
    

#### 3. **Schemas (DTOs)** (`app/schemas/`)

-   Son modelos **Pydantic** que se usan para validar y serializar datos de entrada/salida (API, formularios, etc.).
    
-   Ayudan a definir qu√© campos esperamos recibir o enviar.
    
-   Se pueden basar en el domain model o directamente en el ORM si es necesario.
    

----------

### üîÑ Relaci√≥n entre las capas

```plaintext
       Entrada/Salida (FastAPI, API, consola)
                       ‚¨á
                   [ Pydantic ]
                      Schemas
                       ‚¨á
       [ Dominio / Entidades de negocio ]
                 (clases puras)
                       ‚¨á
               [ ORM / Persistencia ]
         (SQLAlchemy: db/models/*.py)

```

----------

### ‚úÖ ¬øQu√© necesitamos ahora?

Si quer√©s, pasame la estructura del modelo de base de datos que ten√©s (las clases ORM), as√≠ armamos:

1.  Las entidades de dominio (`domain/models/`)
    
2.  Los esquemas Pydantic (`schemas/`)
    
3.  Y los _mappers_ para convertir entre capas
    

### üìÅ Estructura sugerida

```
project/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ db/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ models/          ‚Üê Modelos ORM (SQLAlchemy)
‚îÇ   ‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ models/          ‚Üê Modelos de dominio (sin decoradores ni ORM)
‚îÇ   ‚îî‚îÄ‚îÄ schemas/             ‚Üê Esquemas Pydantic (para entrada/salida de datos)

```

----------

### ‚úÖ ¬øQu√© es un modelo de dominio?

Un modelo de dominio representa **la l√≥gica del negocio** en su forma m√°s limpia, sin preocuparse por c√≥mo se guarda en la base de datos (ORM) ni c√≥mo se valida/transfiere (Pydantic).

----------

### üõ†Ô∏è Vamos a crear el modelo de dominio `Producto`

#### ORM (`app/db/models/producto.py`)

```python
class ProductoORM(Base):
    __tablename__ = "productos"
    
    nombre = Column(String, nullable=False)
    sku = Column(String, unique=True, nullable=False)
    descripcion = Column(String)

    movimientos = relationship("Movimiento", back_populates="producto")

```

#### Dominio (`app/domain/models/producto.py`)

```python
from dataclasses import dataclass

@dataclass
class Producto:
    id: int
    nombre: str
    sku: str
    descripcion: str | None = None

```

----------

¬øQuer√©s que avance generando todos los modelos de dominio (`Producto`, `Movimiento`, `Deposito`, `Usuario`, `Rol`) de esta forma?

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTExMTA2NzY1NSw1OTgxMTQyNjJdfQ==
-->