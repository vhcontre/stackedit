# ğŸ“… Semana 4 â€“ GestiÃ³n de movimientos, Reglas de negocio y pruebas.

| Semana | Objetivos principales                                             |
| ------ | ----------------------------------------------------------------- |
| 4      | ğŸ“ˆ GestiÃ³n de movimientos (entrada/salida)                        |
|        | ğŸ” Reglas de negocio: stock mÃ­nimo, trazabilidad                  |
|        | ğŸ§ª Pruebas unitarias con mÃ¡s lÃ³gica                               |

Desarrollo de la **Semana 4**:

---

### âœ… **Semana 4 â€“ Objetivos**

| Tarea                                      | Estado         |
| ------------------------------------------ | -------------- |
| ğŸ“¦ GestiÃ³n de movimientos (entrada/salida) | ğŸ”² A verificar |
| ğŸ“‰ Reglas de negocio: stock mÃ­nimo         | ğŸ”² A verificar |
| ğŸ” Reglas de negocio: trazabilidad         | ğŸ”² A verificar |
| ğŸ§ª Pruebas unitarias con mÃ¡s lÃ³gica        | ğŸ”² A verificar |

----
Excelente, gracias por compartir el cÃ³digo. Con esto ya tenÃ©s muy bien armadas las **tres capas** de la entidad `Movimiento`:

---

### âœ… Estado actual de `Movimiento` (Semana 4)

| Componente             | Estado  | Observaciones                                                |
| ---------------------- | ------- | ------------------------------------------------------------ |
| Modelo ORM             | âœ… Hecho | Listo en `MovimientoORM`, incluye relaciones, tipos y enums. |
| Modelo de Dominio      | âœ… Hecho | Correctamente definido con `@dataclass` y Enum propio.       |
| Mapper ORM <-> Dominio | âœ… Hecho | Implementado en `movimiento_mapper.py`.                      |
| Pydantic Schemas       | âœ… Hecho | `MovimientoCreate`, `MovimientoUpdate`, `MovimientoOut`.     |

---

### ğŸ“Œ Â¿QuÃ© falta para cerrar la Semana 4?

#### ğŸ“¦ GestiÃ³n de movimientos (entrada/salida)

* [ ] Repositorio con mÃ©todos `crear_movimiento`, `listar_movimientos`, `buscar_por_producto`, etc.
* [ ] Consola interactiva (`movimiento_console.py`) para operar desde CLI (alta, baja, listado).

#### ğŸ” Reglas de negocio

* [ ] **Stock mÃ­nimo**: Al intentar registrar un `egreso`, verificar que haya suficiente stock.
* [ ] **Trazabilidad**: Poder listar todos los movimientos asociados a un producto (por ejemplo, por SKU o ID).

#### ğŸ§ª Pruebas unitarias con lÃ³gica

* [ ] Pruebas para el repositorio de movimientos.
* [ ] Pruebas que verifiquen que no se puede hacer un egreso si no hay stock.
* [ ] Pruebas que aseguren que se guarda bien la trazabilidad de un producto.

---

### âœ… PrÃ³ximo paso recomendado

PodÃ©s empezar creando el **repositorio `MovimientoRepository`**, por ejemplo en:

```
app/repositories/movimiento_repository.py
```

Con mÃ©todos como:

* `create_movimiento`
* `get_all_movimientos`
* `get_movimientos_por_producto(producto_id)`
* Validaciones: stock disponible, tipo de movimiento, etc.

Perfecto. Vamos a crear el archivo `app/repositories/movimiento_repository.py` con una clase `MovimientoRepository`. Esta tendrÃ¡:

1.  MÃ©todo `create_movimiento()` con validaciÃ³n de stock en caso de egreso.
    
2.  MÃ©todo `get_all()` para listar todos los movimientos.
    
3.  MÃ©todo `get_by_producto(producto_id)` para trazabilidad por producto.
    

----------

### ğŸ“ `app/repositories/movimiento_repository.py`

```python
from sqlalchemy.orm import Session
from app.db.models.movimiento import MovimientoORM, TipoMovimiento
from app.db.models.producto import ProductoORM

from app.domain.mappers.movimiento_mapper import (
    movimiento_orm_to_domain,
    movimiento_domain_to_orm,
)
from domain.models.movimiento import Movimiento


class MovimientoRepository:
    def __init__(self, db: Session):
        self.db = db

    def create_movimiento(self, movimiento: Movimiento) -> Movimiento:
        # ValidaciÃ³n para egresos: debe haber stock suficiente
        if movimiento.tipo == TipoMovimiento.egreso:
            producto = self.db.query(ProductoORM).filter(ProductoORM.id == movimiento.producto_id).first()
            if not producto:
                raise ValueError("Producto no encontrado")
            if producto.stock < movimiento.cantidad:
                raise ValueError(f"Stock insuficiente. Disponible: {producto.stock}, Requerido: {movimiento.cantidad}")
            producto.stock -= movimiento.cantidad

        elif movimiento.tipo == TipoMovimiento.ingreso:
            producto = self.db.query(ProductoORM).filter(ProductoORM.id == movimiento.producto_id).first()
            if not producto:
                raise ValueError("Producto no encontrado")
            producto.stock += movimiento.cantidad

        orm_obj = movimiento_domain_to_orm(movimiento)
        self.db.add(orm_obj)
        self.db.commit()
        self.db.refresh(orm_obj)
        return movimiento_orm_to_domain(orm_obj)

    def get_all(self) -> list[Movimiento]:
        movimientos = self.db.query(MovimientoORM).order_by(MovimientoORM.fecha.desc()).all()
        return [movimiento_orm_to_domain(m) for m in movimientos]

    def get_by_producto(self, producto_id: int) -> list[Movimiento]:
        movimientos = self.db.query(MovimientoORM)\
            .filter(MovimientoORM.producto_id == producto_id)\
            .order_by(MovimientoORM.fecha.desc()).all()
        return [movimiento_orm_to_domain(m) for m in movimientos]

```

----------

### âœ… PrÃ³ximo paso

Podemos ahora crear el archivo de consola `movimiento_console.py` con opciones como:

1.  Registrar nuevo movimiento.
    
2.  Listar todos.
    
3.  Ver movimientos de un producto.
    

Â¿QuerÃ©s que te prepare ese archivo ahora?

<!--stackedit_data:
eyJoaXN0b3J5IjpbNTE1Mjc1NzQ4LDU5NzU2MTE3NCw5MDk4MD
Q0NDRdfQ==
-->