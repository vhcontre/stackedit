## ğŸ“¦ Semana 4 â€“ MÃ³dulo de Movimientos de Stock + Reglas de Negocio

| Semana | Objetivos principales                                                                          |
| ------ | ---------------------------------------------------------------------------------------------- |
| 4      | ğŸ“¦ Iniciar el CRUD de movimientos (entrada/salida)                                             |
|        | ğŸ”„ Establecer relaciones entre entidades (producto â†” depÃ³sito â†” movimiento)                    |
|        | ğŸ§ª Implementar y testear validaciones de stock                                                 |
|        | ğŸŒ (Opcional) Iniciar el primer formulario web con FastAPI + Jinja2 para registrar movimientos |

---

### ğŸ¯ Objetivos especÃ­ficos de la semana

* [x] Crear la **entidad Movimiento** en dominio y base de datos
* [x] Definir relaciones: `producto_id`, `deposito_id` (FK en ORM y dominio)
* [x] Implementar validaciones de lÃ³gica de negocio (stock positivo, existencia de entidades)
* [x] Crear consola de movimientos (o endpoint/form si se avanza con FastAPI)
* [x] Calcular stock acumulado a partir de los movimientos

---

### ğŸ§± Modelo de dominio: `Movimiento`

Se creÃ³ el modelo `Movimiento` en la capa de dominio, con atributos:

```python
class Movimiento:
    def __init__(self, id, tipo, cantidad, producto_id, deposito_id, fecha):
        self.id = id
        self.tipo = tipo  # "entrada" o "salida"
        self.cantidad = cantidad
        self.producto_id = producto_id
        self.deposito_id = deposito_id
        self.fecha = fecha
```

> ğŸ§  Se comienza a aplicar **DDD (Domain-Driven Design)**: la entidad contiene lÃ³gica de validaciÃ³n y no es solo un contenedor de datos.

---

### ğŸ—ƒï¸ ORM: tabla `movimientos`

```python
class MovimientoORM(Base):
    __tablename__ = "movimientos"

    id = Column(UUID, primary_key=True, default=uuid4)
    tipo = Column(String, nullable=False)
    cantidad = Column(Integer, nullable=False)
    producto_id = Column(UUID, ForeignKey("productos.id"))
    deposito_id = Column(UUID, ForeignKey("depositos.id"))
    fecha = Column(DateTime, default=datetime.utcnow)
```

> âœ… Se agregan claves forÃ¡neas a `productos` y `depositos`, consolidando las relaciones.

---

### ğŸ”„ Relaciones entre entidades

* Un **movimiento** siempre refiere a un producto y un depÃ³sito existentes.
* Se valida en consola o servicio que ambos existan antes de registrar.
* Para un **movimiento de salida**, debe haber stock suficiente en ese depÃ³sito.

---

### ğŸ§ª Validaciones de lÃ³gica de negocio

Desde la consola o el servicio se aplican:

* âŒ No se permite cantidad â‰¤ 0
* âŒ No se permite registrar una salida con stock insuficiente
* âŒ No se permite registrar si el producto o depÃ³sito no existen
* âœ… Se puede consultar stock acumulado por producto y depÃ³sito

---

### ğŸ“ˆ CÃ¡lculo de stock

Se implementa una funciÃ³n o servicio para calcular el stock:

```python
def calcular_stock(producto_id, deposito_id) -> int:
    entradas = sum(m.cantidad for m in movimientos if m.tipo == "entrada")
    salidas = sum(m.cantidad for m in movimientos if m.tipo == "salida")
    return entradas - salidas
```

> Se puede adaptar a un `StockService` en el dominio si se prefiere encapsular mejor esta lÃ³gica.

---

### ğŸ–¥ï¸ Consola de movimiento (si aplica)

```
1. Registrar movimiento
2. Listar movimientos
3. Consultar stock actual de producto en depÃ³sito
0. Volver al menÃº principal
```

---

### ğŸŒ (Opcional) Primer formulario web

Si el grupo avanzÃ³ con FastAPI + Jinja2, se creÃ³ una vista con formulario:

* Inputs: tipo (entrada/salida), producto, depÃ³sito, cantidad
* Validaciones en backend con Pydantic
* Al registrar, redirecciona a la lista o muestra confirmaciÃ³n

---

### ğŸ§ª Pruebas (si se implementaron)

* Se pueden escribir pruebas unitarias para:

  * Verificar que no se permite stock negativo
  * Verificar que se rechazan movimientos con IDs inexistentes
  * Confirmar que el stock acumulado se calcula correctamente

---

### ğŸ“š VinculaciÃ³n teÃ³rica (Somerville)

* **Unidad 3 / 4**: lÃ³gica de negocio â†’ reglas de consistencia
* **Unidad 5**: relaciones entre entidades, diseÃ±o robusto
* **Unidad 6**: modelo de datos, constraints, dominio orientado a reglas


<!--stackedit_data:
eyJoaXN0b3J5IjpbNzQxNjgzMzg1XX0=
-->