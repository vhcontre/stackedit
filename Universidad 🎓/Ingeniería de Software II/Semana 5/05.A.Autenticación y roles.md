# üìÖ Semana 5 ‚Äì Autenticaci√≥n y roles.

| Semana | Objetivos principales                                             |
| ------ | ----------------------------------------------------------------- |
| 5      | üîê Autenticaci√≥n y roles (JWT: admin y operador)                  |
|        | üß™ Pruebas de endpoints autenticados                              |
|        | üîê Middleware y autorizaci√≥n                                      |



-   ‚úÖ Modelos ORM de `Usuario` y `Rol` con relaci√≥n muchos a muchos.
    
-   ‚úÖ Esquemas Pydantic para `Usuario` y `Rol`.
    

----------

## üß© Paso 1: Implementar autenticaci√≥n con JWT (`/login`)

### üéØ Objetivo:

Crear un endpoint `/login` donde el usuario se autentica con `username` y `password`, y si es v√°lido, recibe un **JWT** con su informaci√≥n.

----------

### üì¶ Estructura sugerida

-   `app/security/auth.py` ‚Üí funciones de autenticaci√≥n y generaci√≥n/verificaci√≥n de JWT.
    
-   `app/routers/auth.py` ‚Üí rutas de login.
    

----------

### üîê 1.1. Instalar dependencia necesaria

Si no la ten√©s:

```bash
pip install python-jose[cryptography] passlib[bcrypt]

```

----------

### üîß 1.2. Crear archivo `app/security/auth.py`

```python
from datetime import datetime, timedelta
from jose import JWTError, jwt
from passlib.context import CryptContext
from app.db.models.usuario import UsuarioORM
from sqlalchemy.orm import Session

# Clave secreta para firmar el token (ponela segura en producci√≥n)
SECRET_KEY = "super-secret-key"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verificar_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def obtener_password_hash(password):
    return pwd_context.hash(password)

def autenticar_usuario(db: Session, username: str, password: str):
    usuario = db.query(UsuarioORM).filter(UsuarioORM.username == username).first()
    if not usuario:
        return None
    if not verificar_password(password, usuario.hashed_password):
        return None
    return usuario

def crear_token_acceso(data: dict, expires_delta: timedelta | None = None):
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

```

----------

### üìÑ 1.3. Crear `app/schemas/token.py`

```python
from pydantic import BaseModel

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: str | None = None

```

----------

### üì• 1.4. Crear endpoint de login en `app/routers/auth.py`

```python
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from app.db.session import get_db
from app.security import auth
from app.schemas.token import Token

router = APIRouter(prefix="/auth", tags=["auth"])

@router.post("/login", response_model=Token)
def login(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):
    usuario = auth.autenticar_usuario(db, form_data.username, form_data.password)
    if not usuario:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Usuario o contrase√±a incorrecta"
        )
    access_token = auth.crear_token_acceso(data={"sub": usuario.username})
    return {"access_token": access_token, "token_type": "bearer"}

```

üí° Este endpoint espera los datos como `application/x-www-form-urlencoded`, por eso usamos `OAuth2PasswordRequestForm`.

----------

### ‚öôÔ∏è 1.5. Montar el router

En `main.py` o el archivo principal de FastAPI:

```python
from app.routers import auth
app.include_router(auth.router)

```

----------

### ‚úÖ ¬øQu√© sigue?

Una vez que tengas este paso implementado y funcionando, probamos que puedas hacer login correctamente (por ejemplo desde Postman o cURL). Despu√©s avanzamos a:

-   Paso 2: Middleware/Dependencia para proteger endpoints.
    
-   Paso 3: Autorizaci√≥n por roles (admin vs operador).
    
-   Paso 4: Pruebas autom√°ticas.
    

----------


## ‚úÖ Paso 1: Cargar un usuario manualmente en la base de datos

Como a√∫n no tenemos un endpoint para registrar usuarios, hay que **crear uno a mano** en un script o directamente desde consola, usando `obtener_password_hash`.

### Ejemplo para precargar un usuario:

```python
# file: scripts/crear_usuario.py (ejec√∫talo una vez)

from sqlalchemy.orm import Session
from app.db.session import SessionLocal
from app.db.models.usuario import UsuarioORM
from app.security.auth import obtener_password_hash

db: Session = SessionLocal()

nuevo_usuario = UsuarioORM(
    username="admin",
    email="admin@email.com",
    hashed_password=obtener_password_hash("admin123"),
    is_active=True
)

db.add(nuevo_usuario)
db.commit()
db.close()
print("‚úÖ Usuario creado con √©xito.")
```

> ‚ö†Ô∏è Usa una contrase√±a real que despu√©s pruebes en Postman: `"admin123"` en este ejemplo.

---

## ‚úÖ Paso 2: Probar el endpoint `/auth/login` desde Postman

### 1. Abre Postman

Haz una solicitud `POST` a:

```
http://localhost:8000/auth/login
```

### 2. En **Body**, selecciona la opci√≥n **x-www-form-urlencoded** y completa:

| key      | value    |
| -------- | -------- |
| username | admin    |
| password | admin123 |

### 3. Click en **Send**

---

### ‚úÖ Si todo va bien, obtendr√°s una respuesta como:

```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR...",
  "token_type": "bearer"
}
```

Este token es lo que vas a usar luego para acceder a endpoints protegidos.

---

## üõ†Ô∏è ¬øQu√© hacer si falla?

* Si devuelve 401 ‚Üí revis√° que el `username` y la `password` sean correctos.
* Si lanza otro error ‚Üí pasame el traceback o error exacto que devuelve la API.

---

## üß™ ¬øQuer√©s que agreguemos ahora un endpoint protegido que use ese JWT?

Por ejemplo, un `/usuarios/me` que devuelva la info del usuario logueado. As√≠ prob√°s c√≥mo usar el token.

¬øAvanzamos con eso?


## ‚úÖ 1. Activar entorno virtual llamado `venv` (desde CMD)

Abr√≠ CMD y naveg√° a tu proyecto:

```cmd
cd D:\UNI\inventario-2025\backend
python -m venv venv
```

Activ√° el entorno virtual:

```cmd
venv\Scripts\activate.bat
```

Si se activa correctamente, vas a ver algo como:

```
(venv) D:\UNI\inventario-2025\backend>
```

---

## ‚úÖ 2. Instalar `python-jose` (si no est√° instalado)

Asegurate de estar en el entorno virtual y ejecut√°:

```cmd
pip install "python-jose[cryptography]"
```

```cmd
pip install passlib[bcrypt]
```

```cmd
pip install python-multipart
```
```cmd
pip install fastapi uvicorn
```


Esto instalar√° el paquete que necesit√°s para usar JWT (`from jose import jwt`).

---

## ‚úÖ 3. Ejecutar el script para crear el usuario admin

Ejecut√° el script con:

```cmd
python -m app.scripts.crear_usuario
```

Si todo est√° bien, ver√°s:

```
‚úÖ Usuario creado con √©xito.
```

---

## üß™ 4. (Opcional) Verificar si se cre√≥ el usuario en la base de datos

Si quer√©s verificarlo con SQLite desde consola, primero necesit√°s tener `sqlite3.exe` instalado (si no lo ten√©s, te explico c√≥mo instalarlo). Luego:

```cmd
sqlite3 inventario.db
```

Y dentro del CLI de SQLite:

```sql
SELECT * FROM usuarios;
```

---
"How-To"** para configurar correctamente el entorno de desarrollo del backend

---

# üõ†Ô∏è Gu√≠a T√©cnica: Instalaci√≥n y Configuraci√≥n del Entorno Backend

**Proyecto:** Sistema de Inventario
**Nivel:** Semana 5 (Autenticaci√≥n, Roles y JWT)
**Base asumida:** Tablas `Usuario` y `Rol` ya implementadas y funcionando.

---

## ‚úÖ 1. Herramientas Requeridas

| Herramienta       | Versi√≥n Recomendada   | Uso                                |
| ----------------- | --------------------- | ---------------------------------- |
| Python            | 3.10 o superior       | Lenguaje de backend                |
| pip               | √öltima                | Gestor de paquetes                 |
| virtualenv / venv | Incorporado en Python | Crear entornos aislados            |
| FastAPI           | >=0.104.1             | Framework web asincr√≥nico          |
| Uvicorn           | >=0.22.0              | Servidor ASGI para FastAPI         |
| SQLAlchemy        | >=2.0                 | ORM para base de datos relacional  |
| Alembic           | >=1.16                | Migraciones de esquemas SQLAlchemy |
| python-multipart  | >=0.0.6               | Manejo de formularios `FormData`   |
| python-jose       | >=3.3.0               | Codificaci√≥n y decodificaci√≥n JWT  |
| passlib\[bcrypt]  | >=1.7.4               | Hashing seguro de contrase√±as      |

---

## üß™ 2. Instalaci√≥n del Entorno

### üêç Crear un entorno virtual

```bash
# Desde la ra√≠z del proyecto
python -m venv venv
```

### ‚ñ∂Ô∏è Activar el entorno virtual

* En **Windows**:

```bash
venv\Scripts\activate
```

* En **Linux/macOS**:

```bash
source venv/bin/activate
```

---

## üì¶ 3. Instalaci√≥n de Dependencias

Instalar todas las dependencias necesarias con `pip`:

```bash
pip install fastapi uvicorn sqlalchemy alembic \
    python-jose[cryptography] passlib[bcrypt] \
    python-multipart
```

**Verificaci√≥n de paquetes instalados:**

```bash
pip freeze
```

Debe aparecer al menos:

```
fastapi==...
uvicorn==...
SQLAlchemy==...
alembic==...
python-jose==...
passlib==...
python-multipart==...
```

```bash
pip install -r requirements.txt
```

---

## üìÅ 4. Estructura del Proyecto (Recomendada)

```
backend/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ db/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ usuario.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ rol.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ session.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ base.py
‚îÇ   ‚îú‚îÄ‚îÄ schemas/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ usuario.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ token.py
‚îÇ   ‚îú‚îÄ‚îÄ security/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth.py
‚îÇ   ‚îú‚îÄ‚îÄ routers/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth.py
‚îÇ   ‚îî‚îÄ‚îÄ main.py
‚îú‚îÄ‚îÄ alembic.ini
‚îú‚îÄ‚îÄ venv/
‚îî‚îÄ‚îÄ requirements.txt
```

---

## ‚öôÔ∏è 5. Configuraci√≥n de FastAPI

### `main.py`

```python
from fastapi import FastAPI
from app.routers import auth

app = FastAPI()
app.include_router(auth.router)
```

### `auth.py` (Router de autenticaci√≥n)

```python
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from app.db.session import get_db
from app.security import auth
from app.schemas.token import Token

router = APIRouter(prefix="/auth", tags=["auth"])

@router.post("/login", response_model=Token)
def login(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):
    usuario = auth.autenticar_usuario(db, form_data.username, form_data.password)
    if not usuario:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Usuario o contrase√±a incorrecta")
    access_token = auth.crear_token_acceso(data={"sub": usuario.username})
    return {"access_token": access_token, "token_type": "bearer"}
```

### `token.py` (esquema de respuesta)

```python
from pydantic import BaseModel

class Token(BaseModel):
    access_token: str
    token_type: str
```

---

## üîë 6. Verificaci√≥n: Test del Endpoint `/auth/login`

### Usando `curl`:

```bash
curl -X POST "http://127.0.0.1:8000/auth/login" \
    -H "Content-Type: application/x-www-form-urlencoded" \
    -d "username=admin&password=1234"
```

Debe retornar:

```json
{
  "access_token": "eyJhbGciOi...",
  "token_type": "bearer"
}
```

---

## üß© 7. Errores Comunes y Soluci√≥n

| Error                                                 | Causa                     | Soluci√≥n                                      |
| ----------------------------------------------------- | ------------------------- | --------------------------------------------- |
| `RuntimeError: Form data requires "python-multipart"` | Falta el paquete          | `pip install python-multipart`                |
| `404 Not Found en /login`                             | No est√° montado el router | Confirmar que `main.py` incluya `auth.router` |
| `ModuleNotFoundError: app.routers`                    | Problema de importaci√≥n   | Ejecutar siempre desde ra√≠z del proyecto      |

---

## üß∑ 8. Iniciar servicios


```bash
venv\Scripts\python.exe -m uvicorn app.main:app --reload
```

----

Sigamos con:

-   üîê Pruebas de autorizaci√≥n con JWT en endpoints protegidos
    
-   üß™ Pruebas automatizadas (con `pytest` o desde Postman)
    
-   üîÑ Middleware para validaci√≥n de roles (admin/operador)
    
-   üìÅ Organizaci√≥n del router en carpetas por m√≥dulos
    
----------

# üîê Pruebas de autorizaci√≥n con JWT en endpoints protegidos


## 1. Protecci√≥n de endpoints con JWT

Para proteger un endpoint con autenticaci√≥n JWT, generalmente se usa una dependencia que extrae y valida el token de autorizaci√≥n. Ya ten√©s la creaci√≥n de tokens en `auth.py`; ahora implementamos la dependencia que extrae el usuario actual y valida el token.

### Ejemplo b√°sico de dependencia en `security/auth.py`:

```python
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from sqlalchemy.orm import Session
from app.db.session import get_db
from app.db.models.usuario import UsuarioORM
from app.schemas.usuario import UsuarioOut

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/auth/login")

SECRET_KEY = "tu_secreto_muy_secreto"
ALGORITHM = "HS256"

def obtener_usuario_actual(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)) -> UsuarioORM:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="No se pudo validar las credenciales",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    usuario = db.query(UsuarioORM).filter(UsuarioORM.username == username).first()
    if usuario is None:
        raise credentials_exception
    return usuario

```

### Uso en router protegido:

```python
from fastapi import APIRouter, Depends
from app.security.auth import obtener_usuario_actual

router = APIRouter()

@router.get("/usuario/me")
def leer_usuario_actual(usuario=Depends(obtener_usuario_actual)):
    return {"username": usuario.username, "email": usuario.email}

```

----------

# üß™ Pruebas automatizadas

----------

## 2. Pruebas con `pytest`

### Instalaci√≥n (si no est√°):

```bash
pip install pytest httpx

```

### Ejemplo b√°sico de test para login (`tests/test_auth.py`):

```python
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

def test_login():
    response = client.post("/auth/login", data={"username": "admin", "password": "1234"})
    assert response.status_code == 200
    data = response.json()
    assert "access_token" in data
    assert data["token_type"] == "bearer"

```

### Test para endpoint protegido:

```python
def test_usuario_actual():
    login_response = client.post("/auth/login", data={"username": "admin", "password": "1234"})
    token = login_response.json()["access_token"]

    response = client.get("/usuario/me", headers={"Authorization": f"Bearer {token}"})
    assert response.status_code == 200
    data = response.json()
    assert data["username"] == "admin"

```

----------

## 3. Pruebas con Postman

-   Crear una colecci√≥n con un request POST a `/auth/login` enviando `x-www-form-urlencoded` con `username` y `password`.
    
-   Guardar el token JWT de la respuesta.
    
-   En requests protegidos, agregar header:
    

```
Authorization: Bearer <token_obtenido>

```

----------

# üîÑ Middleware para validaci√≥n de roles (admin/operador)

## 4. Middleware personalizado para roles

Se puede crear un **dependency** que valide si el usuario tiene el rol adecuado.

### Ejemplo `security/roles.py`:

```python
from fastapi import Depends, HTTPException, status
from app.db.models.rol import RolORM
from app.security.auth import obtener_usuario_actual

def validar_rol(rol_requerido: str):
    def role_dependency(usuario=Depends(obtener_usuario_actual)):
        roles_usuario = [rol.nombre for rol in usuario.roles]  # suponiendo relaci√≥n
        if rol_requerido not in roles_usuario:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="No tiene permisos suficientes"
            )
        return usuario
    return role_dependency

```

### Uso en rutas:

```python
from fastapi import APIRouter, Depends
from app.security.roles import validar_rol

router = APIRouter()

@router.get("/admin/data", dependencies=[Depends(validar_rol("admin"))])
def datos_admin():
    return {"mensaje": "Solo admins pueden ver esto"}

@router.get("/operador/data", dependencies=[Depends(validar_rol("operador"))])
def datos_operador():
    return {"mensaje": "Solo operadores pueden ver esto"}

```

----------

# üìÅ Organizaci√≥n del router en carpetas por m√≥dulos



## 5. Organizaci√≥n recomendada de routers

Divide los routers por funcionalidad para mantener el c√≥digo limpio y escalable.

Ejemplo de estructura:

```
app/
‚îú‚îÄ‚îÄ routers/
‚îÇ   ‚îú‚îÄ‚îÄ auth.py
‚îÇ   ‚îú‚îÄ‚îÄ usuarios.py
‚îÇ   ‚îú‚îÄ‚îÄ productos.py
‚îÇ   ‚îú‚îÄ‚îÄ movimientos.py
‚îÇ   ‚îî‚îÄ‚îÄ roles.py

```

### En `main.py` solo import√°s e inclu√≠s routers:

```python
from fastapi import FastAPI
from app.routers import auth, usuarios, productos, movimientos, roles

app = FastAPI()

app.include_router(auth.router)
app.include_router(usuarios.router)
app.include_router(productos.router)
app.include_router(movimientos.router)
app.include_router(roles.router)

```

Esto permite trabajar m√≥dulos independientes y facilita mantenimiento.

----------

# Ejemplo completo con c√≥digo listo para cada componente 

Claro, vamos a armar un ejemplo completo y cohesivo con todo lo que pediste, adaptado a tu c√≥digo actual.

Te lo voy a dividir en 4 partes:

1.  **Dependencia para obtener usuario actual y validar JWT**
    
2.  **Middleware o dependencia para validaci√≥n de roles**
    
3.  **Ejemplos de endpoints protegidos**
    
4.  **Pruebas automatizadas con pytest**
    

----------

# 1. Obtener usuario actual y validar JWT

Archivo: `backend/app/security/auth.py`  
(Agregamos esta funci√≥n nueva para validar el token y obtener usuario)

```python
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from sqlalchemy.orm import Session
from app.db.session import get_db
from app.db.models.usuario import UsuarioORM

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/auth/login")

def obtener_usuario_actual(
    token: str = Depends(oauth2_scheme),
    db: Session = Depends(get_db)
) -> UsuarioORM:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="No se pudo validar las credenciales",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    
    usuario = db.query(UsuarioORM).filter(UsuarioORM.username == username).first()
    if usuario is None:
        raise credentials_exception
    return usuario

```

----------

# 2. Middleware / dependencia para validaci√≥n de roles

Archivo nuevo: `backend/app/security/roles.py`

```python
from fastapi import Depends, HTTPException, status
from app.security.auth import obtener_usuario_actual

def validar_rol(rol_requerido: str):
    def role_dependency(usuario=Depends(obtener_usuario_actual)):
        roles_usuario = [rol.nombre for rol in usuario.roles]  # asumiendo relaci√≥n many-to-many en ORM
        if rol_requerido not in roles_usuario:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="No tiene permisos suficientes"
            )
        return usuario
    return role_dependency

```

----------

# 3. Ejemplos de routers con endpoints protegidos

Archivo: `backend/app/routers/usuarios.py`

```python
from fastapi import APIRouter, Depends
from app.db.models.usuario import UsuarioORM
from app.security.auth import obtener_usuario_actual
from app.security.roles import validar_rol

router = APIRouter(prefix="/usuarios", tags=["usuarios"])

# Endpoint para usuario autenticado (cualquiera)
@router.get("/me")
def leer_usuario_actual(usuario: UsuarioORM = Depends(obtener_usuario_actual)):
    return {
        "username": usuario.username,
        "email": usuario.email,
        "roles": [rol.nombre for rol in usuario.roles]
    }

# Endpoint solo para admin
@router.get("/admin-only", dependencies=[Depends(validar_rol("admin"))])
def datos_admin():
    return {"mensaje": "Acceso solo para usuarios con rol admin"}

# Endpoint solo para operador
@router.get("/operador-only", dependencies=[Depends(validar_rol("operador"))])
def datos_operador():
    return {"mensaje": "Acceso solo para usuarios con rol operador"}

```

----------

# 4. Pruebas automatizadas b√°sicas con `pytest`

Archivo: `backend/tests/test_auth.py`

```python
import pytest
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

def test_login_ok():
    response = client.post("/auth/login", data={"username": "admin", "password": "admin_password"})
    assert response.status_code == 200
    data = response.json()
    assert "access_token" in data
    assert data["token_type"] == "bearer"

def test_login_fail():
    response = client.post("/auth/login", data={"username": "no_existe", "password": "1234"})
    assert response.status_code == 401

def test_endpoint_protegido():
    login_response = client.post("/auth/login", data={"username": "admin", "password": "admin_password"})
    token = login_response.json()["access_token"]
    headers = {"Authorization": f"Bearer {token}"}

    response = client.get("/usuarios/me", headers=headers)
    assert response.status_code == 200
    assert response.json()["username"] == "admin"

def test_endpoint_admin_role():
    login_response = client.post("/auth/login", data={"username": "admin", "password": "admin_password"})
    token = login_response.json()["access_token"]
    headers = {"Authorization": f"Bearer {token}"}

    response = client.get("/usuarios/admin-only", headers=headers)
    assert response.status_code == 200

def test_endpoint_operador_role_forbidden():
    # Login con usuario que NO es operador
    login_response = client.post("/auth/login", data={"username": "admin", "password": "admin_password"})
    token = login_response.json()["access_token"]
    headers = {"Authorization": f"Bearer {token}"}

    response = client.get("/usuarios/operador-only", headers=headers)
    assert response.status_code == 403

```

----------

# 5. Actualizaci√≥n en `app/main.py`

Para incluir el router nuevo:

```python
from fastapi import FastAPI
from app.routers import auth, usuarios  # importa tu router usuarios.py

app = FastAPI()

app.include_router(auth.router)
app.include_router(usuarios.router)

```

----------

# ¬øQu√© sigue?

-   Asegurarte que en la base de datos los usuarios tienen roles correctamente relacionados.
    
-   Reemplazar `"admin_password"` y `"admin"` en los tests por datos reales que tengas.
    
-   Ejecutar tests con:
    

```bash
pytest -v backend/tests/

```

Para mantener tu estructura organizada y coherente con buenas pr√°cticas, pod√©s ubicar el archivo `test_auth.py` dentro de una subcarpeta que represente la capa de seguridad o autenticaci√≥n, por ejemplo:

```
tests/
‚îú‚îÄ‚îÄ api/
‚îú‚îÄ‚îÄ db/
‚îú‚îÄ‚îÄ domain/
‚îú‚îÄ‚îÄ repository/
‚îú‚îÄ‚îÄ services/
‚îî‚îÄ‚îÄ security/
    ‚îî‚îÄ‚îÄ test_auth.py
```

### üìå Alternativas v√°lidas seg√∫n tu enfoque:

| Opci√≥n                  | Ubicaci√≥n sugerida            | Justificaci√≥n                                                                     |
| ----------------------- | ----------------------------- | --------------------------------------------------------------------------------- |
| ‚úÖ **Por funcionalidad** | `tests/security/test_auth.py` | Si est√°s probando autenticaci√≥n, JWT y roles, corresponde al m√≥dulo de seguridad. |
| üîÅ **Por endpoint/API** | `tests/api/test_auth.py`      | Si lo que teste√°s es c√≥mo se comportan los endpoints `/auth/*`.                   |
| üß™ **General**          | `tests/test_auth.py`          | Si el proyecto es peque√±o o quer√©s mantenerlo todo junto temporalmente.           |

---

### ‚úÖ Recomendaci√≥n (la m√°s ordenada):

Ya que tu archivo `auth.py` est√° dentro de `app/security/auth.py`, lo m√°s claro y mantenible es:

```
tests/security/test_auth.py
```

De esta forma queda bien mapeado: `app/security` ‚Üî `tests/security`.

---

### üëá C√≥mo lo corr√©s desde consola:

```bash
pip install pytest
pip install httpx
pytest -v tests/security/test_auth.py
```

O todos los tests juntos:

```bash
pytest -v tests/
```



<!--stackedit_data:
eyJoaXN0b3J5IjpbLTExMDQ4NTk0OTIsLTU2Mjg5ODg1OSwtMT
Q1ODE4NDQwNywtMjE1ODg4NzM4LDE1Mzg2NTI1OTgsLTUxNjA3
MjE1OCwtMTc3NTU3NTMzMiw0Nzc5NzAwMzIsLTIwMTIwODYwMj
YsLTIwMjg1MzA2MTQsNTMyMTYxNDAxLC0zNjI3OTMwMzYsLTE4
MDIwMDQ2MTIsOTQ2MDQ2NTYwXX0=
-->