# 📅 Semana 5 – Autenticación y roles.

| Semana | Objetivos principales                                             |
| ------ | ----------------------------------------------------------------- |
| 5      | 🔐 Autenticación y roles (JWT: admin y operador)                  |
|        | 🧪 Pruebas de endpoints autenticados                              |
|        | 🔐 Middleware y autorización                                      |



-   ✅ Modelos ORM de `Usuario` y `Rol` con relación muchos a muchos.
    
-   ✅ Esquemas Pydantic para `Usuario` y `Rol`.
    

----------

## 🧩 Paso 1: Implementar autenticación con JWT (`/login`)

### 🎯 Objetivo:

Crear un endpoint `/login` donde el usuario se autentica con `username` y `password`, y si es válido, recibe un **JWT** con su información.

----------

### 📦 Estructura sugerida

-   `app/security/auth.py` → funciones de autenticación y generación/verificación de JWT.
    
-   `app/routers/auth.py` → rutas de login.
    

----------

### 🔐 1.1. Instalar dependencia necesaria

Si no la tenés:

```bash
pip install python-jose[cryptography] passlib[bcrypt]

```

----------

### 🔧 1.2. Crear archivo `app/security/auth.py`

```python
from datetime import datetime, timedelta
from jose import JWTError, jwt
from passlib.context import CryptContext
from app.db.models.usuario import UsuarioORM
from sqlalchemy.orm import Session

# Clave secreta para firmar el token (ponela segura en producción)
SECRET_KEY = "super-secret-key"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verificar_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def obtener_password_hash(password):
    return pwd_context.hash(password)

def autenticar_usuario(db: Session, username: str, password: str):
    usuario = db.query(UsuarioORM).filter(UsuarioORM.username == username).first()
    if not usuario:
        return None
    if not verificar_password(password, usuario.hashed_password):
        return None
    return usuario

def crear_token_acceso(data: dict, expires_delta: timedelta | None = None):
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

```

----------

### 📄 1.3. Crear `app/schemas/token.py`

```python
from pydantic import BaseModel

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: str | None = None

```

----------

### 📥 1.4. Crear endpoint de login en `app/routers/auth.py`

```python
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from app.db.session import get_db
from app.security import auth
from app.schemas.token import Token

router = APIRouter(prefix="/auth", tags=["auth"])

@router.post("/login", response_model=Token)
def login(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):
    usuario = auth.autenticar_usuario(db, form_data.username, form_data.password)
    if not usuario:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Usuario o contraseña incorrecta"
        )
    access_token = auth.crear_token_acceso(data={"sub": usuario.username})
    return {"access_token": access_token, "token_type": "bearer"}

```

💡 Este endpoint espera los datos como `application/x-www-form-urlencoded`, por eso usamos `OAuth2PasswordRequestForm`.

----------

### ⚙️ 1.5. Montar el router

En `main.py` o el archivo principal de FastAPI:

```python
from app.routers import auth
app.include_router(auth.router)

```

----------

### ✅ ¿Qué sigue?

Una vez que tengas este paso implementado y funcionando, probamos que puedas hacer login correctamente (por ejemplo desde Postman o cURL). Después avanzamos a:

-   Paso 2: Middleware/Dependencia para proteger endpoints.
    
-   Paso 3: Autorización por roles (admin vs operador).
    
-   Paso 4: Pruebas automáticas.
    

----------


## ✅ Paso 1: Cargar un usuario manualmente en la base de datos

Como aún no tenemos un endpoint para registrar usuarios, hay que **crear uno a mano** en un script o directamente desde consola, usando `obtener_password_hash`.

### Ejemplo para precargar un usuario:

```python
# file: scripts/crear_usuario.py (ejecútalo una vez)

from sqlalchemy.orm import Session
from app.db.session import SessionLocal
from app.db.models.usuario import UsuarioORM
from app.security.auth import obtener_password_hash

db: Session = SessionLocal()

nuevo_usuario = UsuarioORM(
    username="admin",
    email="admin@email.com",
    hashed_password=obtener_password_hash("admin123"),
    is_active=True
)

db.add(nuevo_usuario)
db.commit()
db.close()
print("✅ Usuario creado con éxito.")
```

> ⚠️ Usa una contraseña real que después pruebes en Postman: `"admin123"` en este ejemplo.

---

## ✅ Paso 2: Probar el endpoint `/auth/login` desde Postman

### 1. Abre Postman

Haz una solicitud `POST` a:

```
http://localhost:8000/auth/login
```

### 2. En **Body**, selecciona la opción **x-www-form-urlencoded** y completa:

| key      | value    |
| -------- | -------- |
| username | admin    |
| password | admin123 |

### 3. Click en **Send**

---

### ✅ Si todo va bien, obtendrás una respuesta como:

```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR...",
  "token_type": "bearer"
}
```

Este token es lo que vas a usar luego para acceder a endpoints protegidos.

---

## 🛠️ ¿Qué hacer si falla?

* Si devuelve 401 → revisá que el `username` y la `password` sean correctos.
* Si lanza otro error → pasame el traceback o error exacto que devuelve la API.

---

## 🧪 ¿Querés que agreguemos ahora un endpoint protegido que use ese JWT?

Por ejemplo, un `/usuarios/me` que devuelva la info del usuario logueado. Así probás cómo usar el token.

¿Avanzamos con eso?


## ✅ 1. Activar entorno virtual llamado `venv` (desde CMD)

Abrí CMD y navegá a tu proyecto:

```cmd
cd D:\UNI\inventario-2025\backend
```

Activá el entorno virtual:

```cmd
venv\Scripts\activate.bat
```

Si se activa correctamente, vas a ver algo como:

```
(venv) D:\UNI\inventario-2025\backend>
```

---

## ✅ 2. Instalar `python-jose` (si no está instalado)

Asegurate de estar en el entorno virtual y ejecutá:

```cmd
pip install "python-jose[cryptography]"
```

```cmd
pip install passlib[bcrypt]
```

```cmd
pip install python-multipart
```
```cmd
pip install fastapi uvicorn
```


Esto instalará el paquete que necesitás para usar JWT (`from jose import jwt`).

---

## ✅ 3. Ejecutar el script para crear el usuario admin

Ejecutá el script con:

```cmd
python -m app.scripts.crear_usuario
```

Si todo está bien, verás:

```
✅ Usuario creado con éxito.
```

---

## 🧪 4. (Opcional) Verificar si se creó el usuario en la base de datos

Si querés verificarlo con SQLite desde consola, primero necesitás tener `sqlite3.exe` instalado (si no lo tenés, te explico cómo instalarlo). Luego:

```cmd
sqlite3 inventario.db
```

Y dentro del CLI de SQLite:

```sql
SELECT * FROM usuarios;
```

---
"How-To"** para configurar correctamente el entorno de desarrollo del backend

---

# 🛠️ Guía Técnica: Instalación y Configuración del Entorno Backend

**Proyecto:** Sistema de Inventario
**Nivel:** Semana 5 (Autenticación, Roles y JWT)
**Base asumida:** Tablas `Usuario` y `Rol` ya implementadas y funcionando.

---

## ✅ 1. Herramientas Requeridas

| Herramienta       | Versión Recomendada   | Uso                                |
| ----------------- | --------------------- | ---------------------------------- |
| Python            | 3.10 o superior       | Lenguaje de backend                |
| pip               | Última                | Gestor de paquetes                 |
| virtualenv / venv | Incorporado en Python | Crear entornos aislados            |
| FastAPI           | >=0.104.1             | Framework web asincrónico          |
| Uvicorn           | >=0.22.0              | Servidor ASGI para FastAPI         |
| SQLAlchemy        | >=2.0                 | ORM para base de datos relacional  |
| Alembic           | >=1.16                | Migraciones de esquemas SQLAlchemy |
| python-multipart  | >=0.0.6               | Manejo de formularios `FormData`   |
| python-jose       | >=3.3.0               | Codificación y decodificación JWT  |
| passlib\[bcrypt]  | >=1.7.4               | Hashing seguro de contraseñas      |

---

## 🧪 2. Instalación del Entorno

### 🐍 Crear un entorno virtual

```bash
# Desde la raíz del proyecto
python -m venv venv
```

### ▶️ Activar el entorno virtual

* En **Windows**:

```bash
venv\Scripts\activate
```

* En **Linux/macOS**:

```bash
source venv/bin/activate
```

---

## 📦 3. Instalación de Dependencias

Instalar todas las dependencias necesarias con `pip`:

```bash
pip install fastapi uvicorn sqlalchemy alembic \
    python-jose[cryptography] passlib[bcrypt] \
    python-multipart
```

**Verificación de paquetes instalados:**

```bash
pip freeze
```

Debe aparecer al menos:

```
fastapi==...
uvicorn==...
SQLAlchemy==...
alembic==...
python-jose==...
passlib==...
python-multipart==...
```

```bash
pip install -r requirements.txt
```

---

## 📁 4. Estructura del Proyecto (Recomendada)

```
backend/
├── app/
│   ├── db/
│   │   ├── models/
│   │   │   ├── usuario.py
│   │   │   └── rol.py
│   │   ├── session.py
│   │   └── base.py
│   ├── schemas/
│   │   ├── usuario.py
│   │   └── token.py
│   ├── security/
│   │   └── auth.py
│   ├── routers/
│   │   └── auth.py
│   └── main.py
├── alembic.ini
├── venv/
└── requirements.txt
```

---

## ⚙️ 5. Configuración de FastAPI

### `main.py`

```python
from fastapi import FastAPI
from app.routers import auth

app = FastAPI()
app.include_router(auth.router)
```

### `auth.py` (Router de autenticación)

```python
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from app.db.session import get_db
from app.security import auth
from app.schemas.token import Token

router = APIRouter(prefix="/auth", tags=["auth"])

@router.post("/login", response_model=Token)
def login(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):
    usuario = auth.autenticar_usuario(db, form_data.username, form_data.password)
    if not usuario:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Usuario o contraseña incorrecta")
    access_token = auth.crear_token_acceso(data={"sub": usuario.username})
    return {"access_token": access_token, "token_type": "bearer"}
```

### `token.py` (esquema de respuesta)

```python
from pydantic import BaseModel

class Token(BaseModel):
    access_token: str
    token_type: str
```

---

## 🔑 6. Verificación: Test del Endpoint `/auth/login`

### Usando `curl`:

```bash
curl -X POST "http://127.0.0.1:8000/auth/login" \
    -H "Content-Type: application/x-www-form-urlencoded" \
    -d "username=admin&password=1234"
```

Debe retornar:

```json
{
  "access_token": "eyJhbGciOi...",
  "token_type": "bearer"
}
```

---

## 🧩 7. Errores Comunes y Solución

| Error                                                 | Causa                     | Solución                                      |
| ----------------------------------------------------- | ------------------------- | --------------------------------------------- |
| `RuntimeError: Form data requires "python-multipart"` | Falta el paquete          | `pip install python-multipart`                |
| `404 Not Found en /login`                             | No está montado el router | Confirmar que `main.py` incluya `auth.router` |
| `ModuleNotFoundError: app.routers`                    | Problema de importación   | Ejecutar siempre desde raíz del proyecto      |

---

## 🧷 8. Iniciar servicios


```bash
venv\Scripts\python.exe -m uvicorn app.main:app --reload
```

----

sigamos con:

-   🔐 Pruebas de autorización con JWT en endpoints protegidos
    
-   🧪 Pruebas automatizadas (con `pytest` o desde Postman)
    
-   🔄 Middleware para validación de roles (admin/operador)
    
-   📁 Organización del router en carpetas por módulos
    


<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE3NzU1NzUzMzIsNDc3OTcwMDMyLC0yMD
EyMDg2MDI2LC0yMDI4NTMwNjE0LDUzMjE2MTQwMSwtMzYyNzkz
MDM2LC0xODAyMDA0NjEyLDk0NjA0NjU2MF19
-->