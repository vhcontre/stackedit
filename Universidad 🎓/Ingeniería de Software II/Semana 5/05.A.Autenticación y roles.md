# ğŸ“… Semana 5 â€“ AutenticaciÃ³n y roles.

| Semana | Objetivos principales                                             |
| ------ | ----------------------------------------------------------------- |
| 5      | ğŸ” AutenticaciÃ³n y roles (JWT: admin y operador)                  |
|        | ğŸ§ª Pruebas de endpoints autenticados                              |
|        | ğŸ” Middleware y autorizaciÃ³n                                      |



-   âœ… Modelos ORM de `Usuario` y `Rol` con relaciÃ³n muchos a muchos.
    
-   âœ… Esquemas Pydantic para `Usuario` y `Rol`.
    

----------

## ğŸ§© Paso 1: Implementar autenticaciÃ³n con JWT (`/login`)

### ğŸ¯ Objetivo:

Crear un endpoint `/login` donde el usuario se autentica con `username` y `password`, y si es vÃ¡lido, recibe un **JWT** con su informaciÃ³n.

----------

### ğŸ“¦ Estructura sugerida

-   `app/security/auth.py` â†’ funciones de autenticaciÃ³n y generaciÃ³n/verificaciÃ³n de JWT.
    
-   `app/routers/auth.py` â†’ rutas de login.
    

----------

### ğŸ” 1.1. Instalar dependencia necesaria

Si no la tenÃ©s:

```bash
pip install python-jose[cryptography] passlib[bcrypt]

```

----------

### ğŸ”§ 1.2. Crear archivo `app/security/auth.py`

```python
from datetime import datetime, timedelta
from jose import JWTError, jwt
from passlib.context import CryptContext
from app.db.models.usuario import UsuarioORM
from sqlalchemy.orm import Session

# Clave secreta para firmar el token (ponela segura en producciÃ³n)
SECRET_KEY = "super-secret-key"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verificar_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def obtener_password_hash(password):
    return pwd_context.hash(password)

def autenticar_usuario(db: Session, username: str, password: str):
    usuario = db.query(UsuarioORM).filter(UsuarioORM.username == username).first()
    if not usuario:
        return None
    if not verificar_password(password, usuario.hashed_password):
        return None
    return usuario

def crear_token_acceso(data: dict, expires_delta: timedelta | None = None):
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

```

----------

### ğŸ“„ 1.3. Crear `app/schemas/token.py`

```python
from pydantic import BaseModel

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: str | None = None

```

----------

### ğŸ“¥ 1.4. Crear endpoint de login en `app/routers/auth.py`

```python
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from app.db.session import get_db
from app.security import auth
from app.schemas.token import Token

router = APIRouter(prefix="/auth", tags=["auth"])

@router.post("/login", response_model=Token)
def login(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):
    usuario = auth.autenticar_usuario(db, form_data.username, form_data.password)
    if not usuario:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Usuario o contraseÃ±a incorrecta"
        )
    access_token = auth.crear_token_acceso(data={"sub": usuario.username})
    return {"access_token": access_token, "token_type": "bearer"}

```

ğŸ’¡ Este endpoint espera los datos como `application/x-www-form-urlencoded`, por eso usamos `OAuth2PasswordRequestForm`.

----------

### âš™ï¸ 1.5. Montar el router

En `main.py` o el archivo principal de FastAPI:

```python
from app.routers import auth
app.include_router(auth.router)

```

----------

### âœ… Â¿QuÃ© sigue?

Una vez que tengas este paso implementado y funcionando, probamos que puedas hacer login correctamente (por ejemplo desde Postman o cURL). DespuÃ©s avanzamos a:

-   Paso 2: Middleware/Dependencia para proteger endpoints.
    
-   Paso 3: AutorizaciÃ³n por roles (admin vs operador).
    
-   Paso 4: Pruebas automÃ¡ticas.
    

----------


## âœ… Paso 1: Cargar un usuario manualmente en la base de datos

Como aÃºn no tenemos un endpoint para registrar usuarios, hay que **crear uno a mano** en un script o directamente desde consola, usando `obtener_password_hash`.

### Ejemplo para precargar un usuario:

```python
# file: scripts/crear_usuario.py (ejecÃºtalo una vez)

from sqlalchemy.orm import Session
from app.db.session import SessionLocal
from app.db.models.usuario import UsuarioORM
from app.security.auth import obtener_password_hash

db: Session = SessionLocal()

nuevo_usuario = UsuarioORM(
    username="admin",
    email="admin@email.com",
    hashed_password=obtener_password_hash("admin123"),
    is_active=True
)

db.add(nuevo_usuario)
db.commit()
db.close()
print("âœ… Usuario creado con Ã©xito.")
```

> âš ï¸ Usa una contraseÃ±a real que despuÃ©s pruebes en Postman: `"admin123"` en este ejemplo.

---

## âœ… Paso 2: Probar el endpoint `/auth/login` desde Postman

### 1. Abre Postman

Haz una solicitud `POST` a:

```
http://localhost:8000/auth/login
```

### 2. En **Body**, selecciona la opciÃ³n **x-www-form-urlencoded** y completa:

| key      | value    |
| -------- | -------- |
| username | admin    |
| password | admin123 |

### 3. Click en **Send**

---

### âœ… Si todo va bien, obtendrÃ¡s una respuesta como:

```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR...",
  "token_type": "bearer"
}
```

Este token es lo que vas a usar luego para acceder a endpoints protegidos.

---

## ğŸ› ï¸ Â¿QuÃ© hacer si falla?

* Si devuelve 401 â†’ revisÃ¡ que el `username` y la `password` sean correctos.
* Si lanza otro error â†’ pasame el traceback o error exacto que devuelve la API.

---

## ğŸ§ª Â¿QuerÃ©s que agreguemos ahora un endpoint protegido que use ese JWT?

Por ejemplo, un `/usuarios/me` que devuelva la info del usuario logueado. AsÃ­ probÃ¡s cÃ³mo usar el token.

Â¿Avanzamos con eso?


## âœ… 1. Activar entorno virtual llamado `venv` (desde CMD)

AbrÃ­ CMD y navegÃ¡ a tu proyecto:

```cmd
cd D:\UNI\inventario-2025\backend
python -m venv venv
```

ActivÃ¡ el entorno virtual:

```cmd
venv\Scripts\activate.bat
```

Si se activa correctamente, vas a ver algo como:

```
(venv) D:\UNI\inventario-2025\backend>
```

---

## âœ… 2. Instalar `python-jose` (si no estÃ¡ instalado)

Asegurate de estar en el entorno virtual y ejecutÃ¡:

```cmd
pip install "python-jose[cryptography]"
```

```cmd
pip install passlib[bcrypt]
```

```cmd
pip install python-multipart
```
```cmd
pip install fastapi uvicorn
```


Esto instalarÃ¡ el paquete que necesitÃ¡s para usar JWT (`from jose import jwt`).

---

## âœ… 3. Ejecutar el script para crear el usuario admin

EjecutÃ¡ el script con:

```cmd
python -m app.scripts.crear_usuario
```

Si todo estÃ¡ bien, verÃ¡s:

```
âœ… Usuario creado con Ã©xito.
```

---

## ğŸ§ª 4. (Opcional) Verificar si se creÃ³ el usuario en la base de datos

Si querÃ©s verificarlo con SQLite desde consola, primero necesitÃ¡s tener `sqlite3.exe` instalado (si no lo tenÃ©s, te explico cÃ³mo instalarlo). Luego:

```cmd
sqlite3 inventario.db
```

Y dentro del CLI de SQLite:

```sql
SELECT * FROM usuarios;
```

---
"How-To"** para configurar correctamente el entorno de desarrollo del backend

---

# ğŸ› ï¸ GuÃ­a TÃ©cnica: InstalaciÃ³n y ConfiguraciÃ³n del Entorno Backend

**Proyecto:** Sistema de Inventario
**Nivel:** Semana 5 (AutenticaciÃ³n, Roles y JWT)
**Base asumida:** Tablas `Usuario` y `Rol` ya implementadas y funcionando.

---

## âœ… 1. Herramientas Requeridas

| Herramienta       | VersiÃ³n Recomendada   | Uso                                |
| ----------------- | --------------------- | ---------------------------------- |
| Python            | 3.10 o superior       | Lenguaje de backend                |
| pip               | Ãšltima                | Gestor de paquetes                 |
| virtualenv / venv | Incorporado en Python | Crear entornos aislados            |
| FastAPI           | >=0.104.1             | Framework web asincrÃ³nico          |
| Uvicorn           | >=0.22.0              | Servidor ASGI para FastAPI         |
| SQLAlchemy        | >=2.0                 | ORM para base de datos relacional  |
| Alembic           | >=1.16                | Migraciones de esquemas SQLAlchemy |
| python-multipart  | >=0.0.6               | Manejo de formularios `FormData`   |
| python-jose       | >=3.3.0               | CodificaciÃ³n y decodificaciÃ³n JWT  |
| passlib\[bcrypt]  | >=1.7.4               | Hashing seguro de contraseÃ±as      |

---

## ğŸ§ª 2. InstalaciÃ³n del Entorno

### ğŸ Crear un entorno virtual

```bash
# Desde la raÃ­z del proyecto
python -m venv venv
```

### â–¶ï¸ Activar el entorno virtual

* En **Windows**:

```bash
venv\Scripts\activate
```

* En **Linux/macOS**:

```bash
source venv/bin/activate
```

---

## ğŸ“¦ 3. InstalaciÃ³n de Dependencias

Instalar todas las dependencias necesarias con `pip`:

```bash
pip install fastapi uvicorn sqlalchemy alembic \
    python-jose[cryptography] passlib[bcrypt] \
    python-multipart
```

**VerificaciÃ³n de paquetes instalados:**

```bash
pip freeze
```

Debe aparecer al menos:

```
fastapi==...
uvicorn==...
SQLAlchemy==...
alembic==...
python-jose==...
passlib==...
python-multipart==...
```

```bash
pip install -r requirements.txt
```

---

## ğŸ“ 4. Estructura del Proyecto (Recomendada)

```
backend/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ db/
â”‚   â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”‚   â”œâ”€â”€ usuario.py
â”‚   â”‚   â”‚   â””â”€â”€ rol.py
â”‚   â”‚   â”œâ”€â”€ session.py
â”‚   â”‚   â””â”€â”€ base.py
â”‚   â”œâ”€â”€ schemas/
â”‚   â”‚   â”œâ”€â”€ usuario.py
â”‚   â”‚   â””â”€â”€ token.py
â”‚   â”œâ”€â”€ security/
â”‚   â”‚   â””â”€â”€ auth.py
â”‚   â”œâ”€â”€ routers/
â”‚   â”‚   â””â”€â”€ auth.py
â”‚   â””â”€â”€ main.py
â”œâ”€â”€ alembic.ini
â”œâ”€â”€ venv/
â””â”€â”€ requirements.txt
```

---

## âš™ï¸ 5. ConfiguraciÃ³n de FastAPI

### `main.py`

```python
from fastapi import FastAPI
from app.routers import auth

app = FastAPI()
app.include_router(auth.router)
```

### `auth.py` (Router de autenticaciÃ³n)

```python
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from app.db.session import get_db
from app.security import auth
from app.schemas.token import Token

router = APIRouter(prefix="/auth", tags=["auth"])

@router.post("/login", response_model=Token)
def login(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):
    usuario = auth.autenticar_usuario(db, form_data.username, form_data.password)
    if not usuario:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Usuario o contraseÃ±a incorrecta")
    access_token = auth.crear_token_acceso(data={"sub": usuario.username})
    return {"access_token": access_token, "token_type": "bearer"}
```

### `token.py` (esquema de respuesta)

```python
from pydantic import BaseModel

class Token(BaseModel):
    access_token: str
    token_type: str
```

---

## ğŸ”‘ 6. VerificaciÃ³n: Test del Endpoint `/auth/login`

### Usando `curl`:

```bash
curl -X POST "http://127.0.0.1:8000/auth/login" \
    -H "Content-Type: application/x-www-form-urlencoded" \
    -d "username=admin&password=1234"
```

Debe retornar:

```json
{
  "access_token": "eyJhbGciOi...",
  "token_type": "bearer"
}
```

---

## ğŸ§© 7. Errores Comunes y SoluciÃ³n

| Error                                                 | Causa                     | SoluciÃ³n                                      |
| ----------------------------------------------------- | ------------------------- | --------------------------------------------- |
| `RuntimeError: Form data requires "python-multipart"` | Falta el paquete          | `pip install python-multipart`                |
| `404 Not Found en /login`                             | No estÃ¡ montado el router | Confirmar que `main.py` incluya `auth.router` |
| `ModuleNotFoundError: app.routers`                    | Problema de importaciÃ³n   | Ejecutar siempre desde raÃ­z del proyecto      |

---

## ğŸ§· 8. Iniciar servicios


```bash
venv\Scripts\python.exe -m uvicorn app.main:app --reload
```

----

Sigamos con:

-   ğŸ” Pruebas de autorizaciÃ³n con JWT en endpoints protegidos
    
-   ğŸ§ª Pruebas automatizadas (con `pytest` o desde Postman)
    
-   ğŸ”„ Middleware para validaciÃ³n de roles (admin/operador)
    
-   ğŸ“ OrganizaciÃ³n del router en carpetas por mÃ³dulos
    
----------

# ğŸ” Pruebas de autorizaciÃ³n con JWT en endpoints protegidos


## 1. ProtecciÃ³n de endpoints con JWT

Para proteger un endpoint con autenticaciÃ³n JWT, generalmente se usa una dependencia que extrae y valida el token de autorizaciÃ³n. Ya tenÃ©s la creaciÃ³n de tokens en `auth.py`; ahora implementamos la dependencia que extrae el usuario actual y valida el token.

### Ejemplo bÃ¡sico de dependencia en `security/auth.py`:

```python
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from sqlalchemy.orm import Session
from app.db.session import get_db
from app.db.models.usuario import UsuarioORM
from app.schemas.usuario import UsuarioOut

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/auth/login")

SECRET_KEY = "tu_secreto_muy_secreto"
ALGORITHM = "HS256"

def obtener_usuario_actual(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)) -> UsuarioORM:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="No se pudo validar las credenciales",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    usuario = db.query(UsuarioORM).filter(UsuarioORM.username == username).first()
    if usuario is None:
        raise credentials_exception
    return usuario

```

### Uso en router protegido:

```python
from fastapi import APIRouter, Depends
from app.security.auth import obtener_usuario_actual

router = APIRouter()

@router.get("/usuario/me")
def leer_usuario_actual(usuario=Depends(obtener_usuario_actual)):
    return {"username": usuario.username, "email": usuario.email}

```

----------

# ğŸ§ª Pruebas automatizadas

----------

## 2. Pruebas con `pytest`

### InstalaciÃ³n (si no estÃ¡):

```bash
pip install pytest httpx

```

### Ejemplo bÃ¡sico de test para login (`tests/test_auth.py`):

```python
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

def test_login():
    response = client.post("/auth/login", data={"username": "admin", "password": "1234"})
    assert response.status_code == 200
    data = response.json()
    assert "access_token" in data
    assert data["token_type"] == "bearer"

```

### Test para endpoint protegido:

```python
def test_usuario_actual():
    login_response = client.post("/auth/login", data={"username": "admin", "password": "1234"})
    token = login_response.json()["access_token"]

    response = client.get("/usuario/me", headers={"Authorization": f"Bearer {token}"})
    assert response.status_code == 200
    data = response.json()
    assert data["username"] == "admin"

```

----------

## 3. Pruebas con Postman

-   Crear una colecciÃ³n con un request POST a `/auth/login` enviando `x-www-form-urlencoded` con `username` y `password`.
    
-   Guardar el token JWT de la respuesta.
    
-   En requests protegidos, agregar header:
    

```
Authorization: Bearer <token_obtenido>

```

----------

# ğŸ”„ Middleware para validaciÃ³n de roles (admin/operador)

## 4. Middleware personalizado para roles

Se puede crear un **dependency** que valide si el usuario tiene el rol adecuado.

### Ejemplo `security/roles.py`:

```python
from fastapi import Depends, HTTPException, status
from app.db.models.rol import RolORM
from app.security.auth import obtener_usuario_actual

def validar_rol(rol_requerido: str):
    def role_dependency(usuario=Depends(obtener_usuario_actual)):
        roles_usuario = [rol.nombre for rol in usuario.roles]  # suponiendo relaciÃ³n
        if rol_requerido not in roles_usuario:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="No tiene permisos suficientes"
            )
        return usuario
    return role_dependency

```

### Uso en rutas:

```python
from fastapi import APIRouter, Depends
from app.security.roles import validar_rol

router = APIRouter()

@router.get("/admin/data", dependencies=[Depends(validar_rol("admin"))])
def datos_admin():
    return {"mensaje": "Solo admins pueden ver esto"}

@router.get("/operador/data", dependencies=[Depends(validar_rol("operador"))])
def datos_operador():
    return {"mensaje": "Solo operadores pueden ver esto"}

```

----------

# ğŸ“ OrganizaciÃ³n del router en carpetas por mÃ³dulos



## 5. OrganizaciÃ³n recomendada de routers

Divide los routers por funcionalidad para mantener el cÃ³digo limpio y escalable.

Ejemplo de estructura:

```
app/
â”œâ”€â”€ routers/
â”‚   â”œâ”€â”€ auth.py
â”‚   â”œâ”€â”€ usuarios.py
â”‚   â”œâ”€â”€ productos.py
â”‚   â”œâ”€â”€ movimientos.py
â”‚   â””â”€â”€ roles.py

```

### En `main.py` solo importÃ¡s e incluÃ­s routers:

```python
from fastapi import FastAPI
from app.routers import auth, usuarios, productos, movimientos, roles

app = FastAPI()

app.include_router(auth.router)
app.include_router(usuarios.router)
app.include_router(productos.router)
app.include_router(movimientos.router)
app.include_router(roles.router)

```

Esto permite trabajar mÃ³dulos independientes y facilita mantenimiento.

----------

# Ejemplo completo con cÃ³digo listo para cada componente 

Claro, vamos a armar un ejemplo completo y cohesivo con todo lo que pediste, adaptado a tu cÃ³digo actual.

Te lo voy a dividir en 4 partes:

1.  **Dependencia para obtener usuario actual y validar JWT**
    
2.  **Middleware o dependencia para validaciÃ³n de roles**
    
3.  **Ejemplos de endpoints protegidos**
    
4.  **Pruebas automatizadas con pytest**
    

----------

# 1. Obtener usuario actual y validar JWT

Archivo: `backend/app/security/auth.py`  
(Agregamos esta funciÃ³n nueva para validar el token y obtener usuario)

```python
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from sqlalchemy.orm import Session
from app.db.session import get_db
from app.db.models.usuario import UsuarioORM

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/auth/login")

def obtener_usuario_actual(
    token: str = Depends(oauth2_scheme),
    db: Session = Depends(get_db)
) -> UsuarioORM:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="No se pudo validar las credenciales",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    
    usuario = db.query(UsuarioORM).filter(UsuarioORM.username == username).first()
    if usuario is None:
        raise credentials_exception
    return usuario

```

----------

# 2. Middleware / dependencia para validaciÃ³n de roles

Archivo nuevo: `backend/app/security/roles.py`

```python
from fastapi import Depends, HTTPException, status
from app.security.auth import obtener_usuario_actual

def validar_rol(rol_requerido: str):
    def role_dependency(usuario=Depends(obtener_usuario_actual)):
        roles_usuario = [rol.nombre for rol in usuario.roles]  # asumiendo relaciÃ³n many-to-many en ORM
        if rol_requerido not in roles_usuario:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="No tiene permisos suficientes"
            )
        return usuario
    return role_dependency

```

----------

# 3. Ejemplos de routers con endpoints protegidos

Archivo: `backend/app/routers/usuarios.py`

```python
from fastapi import APIRouter, Depends
from app.db.models.usuario import UsuarioORM
from app.security.auth import obtener_usuario_actual
from app.security.roles import validar_rol

router = APIRouter(prefix="/usuarios", tags=["usuarios"])

# Endpoint para usuario autenticado (cualquiera)
@router.get("/me")
def leer_usuario_actual(usuario: UsuarioORM = Depends(obtener_usuario_actual)):
    return {
        "username": usuario.username,
        "email": usuario.email,
        "roles": [rol.nombre for rol in usuario.roles]
    }

# Endpoint solo para admin
@router.get("/admin-only", dependencies=[Depends(validar_rol("admin"))])
def datos_admin():
    return {"mensaje": "Acceso solo para usuarios con rol admin"}

# Endpoint solo para operador
@router.get("/operador-only", dependencies=[Depends(validar_rol("operador"))])
def datos_operador():
    return {"mensaje": "Acceso solo para usuarios con rol operador"}

```

----------

# 4. Pruebas automatizadas bÃ¡sicas con `pytest`

Archivo: `backend/tests/test_auth.py`

```python
import pytest
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

def test_login_ok():
    response = client.post("/auth/login", data={"username": "admin", "password": "admin_password"})
    assert response.status_code == 200
    data = response.json()
    assert "access_token" in data
    assert data["token_type"] == "bearer"

def test_login_fail():
    response = client.post("/auth/login", data={"username": "no_existe", "password": "1234"})
    assert response.status_code == 401

def test_endpoint_protegido():
    login_response = client.post("/auth/login", data={"username": "admin", "password": "admin_password"})
    token = login_response.json()["access_token"]
    headers = {"Authorization": f"Bearer {token}"}

    response = client.get("/usuarios/me", headers=headers)
    assert response.status_code == 200
    assert response.json()["username"] == "admin"

def test_endpoint_admin_role():
    login_response = client.post("/auth/login", data={"username": "admin", "password": "admin_password"})
    token = login_response.json()["access_token"]
    headers = {"Authorization": f"Bearer {token}"}

    response = client.get("/usuarios/admin-only", headers=headers)
    assert response.status_code == 200

def test_endpoint_operador_role_forbidden():
    # Login con usuario que NO es operador
    login_response = client.post("/auth/login", data={"username": "admin", "password": "admin_password"})
    token = login_response.json()["access_token"]
    headers = {"Authorization": f"Bearer {token}"}

    response = client.get("/usuarios/operador-only", headers=headers)
    assert response.status_code == 403

```

----------

# 5. ActualizaciÃ³n en `app/main.py`

Para incluir el router nuevo:

```python
from fastapi import FastAPI
from app.routers import auth, usuarios  # importa tu router usuarios.py

app = FastAPI()

app.include_router(auth.router)
app.include_router(usuarios.router)

```

----------

# Â¿QuÃ© sigue?

-   Asegurarte que en la base de datos los usuarios tienen roles correctamente relacionados.
    
-   Reemplazar `"admin_password"` y `"admin"` en los tests por datos reales que tengas.
    
-   Ejecutar tests con:
    

```bash
pytest -v backend/tests/

```

Para mantener tu estructura organizada y coherente con buenas prÃ¡cticas, podÃ©s ubicar el archivo `test_auth.py` dentro de una subcarpeta que represente la capa de seguridad o autenticaciÃ³n, por ejemplo:

```
tests/
â”œâ”€â”€ api/
â”œâ”€â”€ db/
â”œâ”€â”€ domain/
â”œâ”€â”€ repository/
â”œâ”€â”€ services/
â””â”€â”€ security/
    â””â”€â”€ test_auth.py
```

### ğŸ“Œ Alternativas vÃ¡lidas segÃºn tu enfoque:

| OpciÃ³n                  | UbicaciÃ³n sugerida            | JustificaciÃ³n                                                                     |
| ----------------------- | ----------------------------- | --------------------------------------------------------------------------------- |
| âœ… **Por funcionalidad** | `tests/security/test_auth.py` | Si estÃ¡s probando autenticaciÃ³n, JWT y roles, corresponde al mÃ³dulo de seguridad. |
| ğŸ” **Por endpoint/API** | `tests/api/test_auth.py`      | Si lo que testeÃ¡s es cÃ³mo se comportan los endpoints `/auth/*`.                   |
| ğŸ§ª **General**          | `tests/test_auth.py`          | Si el proyecto es pequeÃ±o o querÃ©s mantenerlo todo junto temporalmente.           |

---

### âœ… RecomendaciÃ³n (la mÃ¡s ordenada):

Ya que tu archivo `auth.py` estÃ¡ dentro de `app/security/auth.py`, lo mÃ¡s claro y mantenible es:

```
tests/security/test_auth.py
```

De esta forma queda bien mapeado: `app/security` â†” `tests/security`.

---

### ğŸ‘‡ CÃ³mo lo corrÃ©s desde consola:

```bash
pip install pytest
pip install httpx
pytest -v tests/security/test_auth.py
```

---

# âœ… How-To: Testear autenticaciÃ³n con FastAPI y JWT usando SQLite en memoria

## ğŸ¯ Objetivo

Configurar un entorno de pruebas para verificar autenticaciÃ³n (`/auth/login`) y acceso con JWT en endpoints protegidos, usando SQLite en memoria y `pytest`.

---

## ğŸ“ Estructura esperada mÃ­nima

```
inventario-2025/
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ db/
â”‚   â”‚   â”‚   â”œâ”€â”€ session.py       â† Contiene `get_db`
â”‚   â”‚   â”‚   â””â”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ main.py              â† Crea el `app`
â”‚   â”‚   â””â”€â”€ security/
â”‚   â”‚       â””â”€â”€ auth.py          â† Maneja login y JWT
â”‚   â””â”€â”€ tests/
â”‚       â”œâ”€â”€ conftest.py          â† Configura test DB y cliente
â”‚       â””â”€â”€ security/
â”‚           â””â”€â”€ test_auth.py     â† Pruebas de login y roles
```

---

## ğŸ§ª Paso 1: Crear motor de pruebas en `conftest.py`

```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.pool import StaticPool
from app.db.models.base import EntityBase

# ğŸ”§ Motor SQLite en memoria
TEST_DATABASE_URL = "sqlite:///:memory:"
engine_test = create_engine(
    TEST_DATABASE_URL,
    connect_args={"check_same_thread": False},
    poolclass=StaticPool
)

TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine_test)
```

---

## ğŸ§ª Paso 2: Crear/limpiar la base antes y despuÃ©s de los tests

```python
import pytest

@pytest.fixture(scope="session", autouse=True)
def setup_test_db():
    EntityBase.metadata.create_all(bind=engine_test)
    yield
    EntityBase.metadata.drop_all(bind=engine_test)

@pytest.fixture(autouse=True)
def limpiar_tablas():
    yield
    for tabla in reversed(EntityBase.metadata.sorted_tables):
        engine_test.execute(tabla.delete())
```

---

## ğŸ§ª Paso 3: Sobrescribir la dependencia `get_db` de la app

> âœ… Esta es la parte donde mÃ¡s errores se cometen

```python
from fastapi.testclient import TestClient
from app.main import app
from app.db.session import get_db  # âš ï¸ Importar la funciÃ³n real, no el fixture

@pytest.fixture()
def client():
    def override_get_db():
        db = TestingSessionLocal()
        try:
            yield db
        finally:
            db.close()

    # â›³ Sobrescribimos correctamente la dependencia
    app.dependency_overrides[get_db] = override_get_db

    with TestClient(app) as c:
        yield c
```

---

## ğŸ§ª Paso 4: Escribir test de login y acceso protegido

```python
def test_login_ok(client):
    response = client.post("/auth/login", data={"username": "admin", "password": "admin_password"})
    assert response.status_code == 200
    assert "access_token" in response.json()

def test_endpoint_protegido(client):
    login = client.post("/auth/login", data={"username": "admin", "password": "admin_password"})
    token = login.json()["access_token"]
    headers = {"Authorization": f"Bearer {token}"}
    r = client.get("/admin/zona-segura", headers=headers)
    assert r.status_code == 200
```

---

## ğŸ’¡ Recomendaciones

* VerificÃ¡ que `admin` exista en la base al iniciar (podÃ©s crear uno directamente en el test).
* Si usÃ¡s roles, asegurate que estÃ©n correctamente relacionados con el usuario de prueba.
* UsÃ¡ fixtures por separado si querÃ©s poblar datos antes de los tests.



---

## ğŸ§ª Â¿QuÃ© ocurre cuando ejecutamos este comando?

```bash
pytest -v tests/security/test_auth.py
```



## âœ… Fase 1: Descubrimiento y configuraciÃ³n inicial

1. **Pytest busca archivos de configuraciÃ³n**, como `pytest.ini`, `conftest.py`, etc.
2. Encuentra `tests/conftest.py` y **carga todos los fixtures definidos** allÃ­.
3. Se reconoce `test_auth.py` como archivo de pruebas porque:

   * EstÃ¡ dentro de `tests/`
   * Empieza con `test_`
   * Contiene funciones que tambiÃ©n empiezan con `test_`

---

## âœ… Fase 2: Setup general antes de cualquier test

### 1. `setup_test_db()` se ejecuta automÃ¡ticamente

```python
@pytest.fixture(scope="session", autouse=True)
def setup_test_db():
    EntityBase.metadata.create_all(bind=engine_test)
    yield
    EntityBase.metadata.drop_all(bind=engine_test)
```

Esto hace lo siguiente:

* Crea todas las tablas en la **base en memoria (SQLite `:memory:`)**.
* Espera (`yield`) que terminen todos los tests.
* Luego borra todas las tablas (al final de la sesiÃ³n).

---

## âœ… Fase 3: PreparaciÃ³n **antes de cada test individual**

Cada funciÃ³n de test (como `test_login_ok`) activa automÃ¡ticamente estos fixtures:

### 2. `client()` se ejecuta:

```python
@pytest.fixture()
def client():
    def override_get_db():
        db = TestingSessionLocal()
        try:
            yield db
        finally:
            db.close()

    app.dependency_overrides[get_db] = override_get_db

    with TestClient(app) as c:
        yield c
```

ğŸ” AquÃ­ ocurre algo clave:

* Se reemplaza la dependencia `get_db` de FastAPI por `override_get_db`.
* Esto asegura que **cada test use una sesiÃ³n aislada en memoria**.
* Se instancia `TestClient(app)` para simular peticiones HTTP reales.

---

### 3. `limpiar_tablas()` tambiÃ©n se ejecuta antes de cada test

```python
@pytest.fixture(autouse=True)
def limpiar_tablas():
    yield
    for tabla in reversed(EntityBase.metadata.sorted_tables):
        engine_test.execute(tabla.delete())
```

Esto **limpia todas las tablas** despuÃ©s de cada test individual para que **el estado no se contamine entre tests**.

---

## âœ… Fase 4: EjecuciÃ³n del test propiamente dicho

Supongamos este test:

```python
def test_login_ok(client):
    response = client.post("/auth/login", data={"username": "admin", "password": "admin_password"})
    assert response.status_code == 200
```

1. Usa el fixture `client`, que ya tiene base en memoria y `get_db` reemplazado.
2. EnvÃ­a una solicitud `POST` al endpoint `/auth/login`.
3. EvalÃºa la respuesta.

ğŸ’¡ **Si el usuario `admin` no existe aÃºn en la base**, este test fallarÃ¡. Por eso, muchas veces se agregan pasos de inicializaciÃ³n de datos justo antes o con fixtures.

---

## âœ… Fase 5: Teardown y limpieza

* Finaliza el test â†’ `limpiar_tablas()` borra los datos.
* El siguiente test se ejecuta desde cero.
* Al terminar todos los tests del archivo, `setup_test_db()` borra las tablas y cierra la base en memoria.

---

## ğŸ”„ Flujo resumen grÃ¡fico

```text
START â†’ pytest detecta tests
   â”œâ”€ carga conftest.py
   â”œâ”€ setup_test_db() â†’ crea tablas (una vez)
   â””â”€ Por cada test:
       â”œâ”€ limpiar_tablas() (despuÃ©s del test)
       â”œâ”€ client() â†’ sobreescribe get_db + crea TestClient
       â””â”€ ejecuta el test â†’ hace peticiones
   â””â”€ Fin â†’ drop_all()
END
```

---


## ğŸ§­ Â¿CuÃ¡ndo y cÃ³mo se ejecutan estas pruebas?

Cuando corrÃ©s:

```bash
pytest -v tests/security/test_auth.py
```

esto pasa **paso por paso**:

---

## ğŸ§© ORDEN DE EJECUCIÃ“N DETALLADO

### 1. **Pytest inicia la ejecuciÃ³n**

* Busca automÃ¡ticamente funciones que empiecen con `test_`.
* Detecta el archivo `conftest.py` y carga todas las **fixtures** definidas.

---

### 2. **Fixtures globales del archivo `conftest.py`**

Ejemplo:

```python
@pytest.fixture()
def client():
```

* Pytest ve que `test_login_ok` pide un `client` y `db_session`.
* Entonces ejecuta primero las fixtures `db_session` y `client` antes del test.

---

### 3. **Se ejecuta `setup_test_db` (si existe)**

* Esta fixture, marcada con `autouse=True`, **crea la base de datos en memoria** antes de cualquier test, usando:

```python
EntityBase.metadata.create_all(bind=engine_test)
```

---

### 4. **`db_session` y `client` se inyectan**

Ejemplo de un test:

```python
def test_login_ok(client, db_session):
```

* **`db_session`**: crea una sesiÃ³n conectada a SQLite en memoria.
* **`client`**: crea una instancia de `TestClient(app)` para hacer peticiones simuladas a la API.

---

### 5. **Se ejecuta el cuerpo del test**

Ya con `client` y `db_session`, se corre:

```python
crear_usuario_admin(db_session)
response = client.post("/auth/login", data={"username": "admin", "password": "admin_password"})
```

Y se hacen las afirmaciones como:

```python
assert response.status_code == 200
```

---

## ğŸ¯ ORDEN DE LOS TESTS EN TU ARCHIVO `test_auth.py`

SegÃºn lo que pegaste (y considerando la duplicaciÃ³n accidental de `test_login_ok`), Pytest ejecutarÃ¡ en este orden:

1. `test_login_ok`  â† (el primero que aparece)
2. `test_endpoint_protegido`
3. `test_endpoint_admin_role`
4. `test_endpoint_operador_role_forbidden`
5. `test_login_ok` â† (el duplicado que deberÃ­as borrar o renombrar)

> âš ï¸ Tener dos funciones con el mismo nombre (`test_login_ok`) hace que **la segunda sobrescriba a la primera**, y solo se ejecute una de ellas. Te recomiendo dejar una sola.

---

## ğŸ” Â¿QuiÃ©n llama a quÃ©?

AquÃ­ te dejo el flujo simplificado:

```
pytest
 â””â”€â”€ busca test_auth.py
      â”œâ”€â”€ detecta funciones test_
      â”œâ”€â”€ detecta que usan fixtures
      â”‚    â””â”€â”€ ejecuta db_session y client
      â”œâ”€â”€ ejecuta el test con las fixtures inyectadas
      â””â”€â”€ valida los assert
```

---

## ğŸ’¬ Agregar `print()` para seguir la ejecuciÃ³n

PodÃ©s enriquecer cada test con `print()` para ver quÃ© pasa:

### âœ… Ejemplo: `test_login_ok`

```python
def test_login_ok(client, db_session):
    print("â–¶ï¸ Iniciando test_login_ok...")

    crear_usuario_admin(db_session)
    print("âœ… Usuario admin creado.")

    response = client.post("/auth/login", data={
        "username": "admin",
        "password": "admin_password"
    })
    print(f"ğŸ” Login response: {response.status_code}, {response.json()}")

    assert response.status_code == 200
    assert "access_token" in response.json()
```

---

### ğŸ§ª Ejemplo: `test_endpoint_admin_role`

```python
def test_endpoint_admin_role(client, db_session):
    print("â–¶ï¸ Test acceso a zona segura (rol admin)")
    crear_usuario_admin(db_session)
    print("âœ… Usuario admin creado.")

    login_response = client.post("/auth/login", data={"username": "admin", "password": "admin_password"})
    token = login_response.json()["access_token"]
    print(f"ğŸªª Token recibido: {token}")

    response = client.get("/admin/zona-segura", headers={"Authorization": f"Bearer {token}"})
    print(f"ğŸ” Acceso zona segura: {response.status_code}")

    assert response.status_code == 200
```

---

## âœ… Recomendaciones finales

1. âœ… AgregÃ¡ `print()` como apoyo didÃ¡ctico (pueden borrarse luego).
2. âœ… Asegurate de que las fixtures (`client`, `db_session`) estÃ¡n bien inyectadas.
3. âœ… PodÃ©s usar `-s` en `pytest` para ver los `print()`:

   ```bash
   pytest -v -s tests/security/test_auth.py
   ```

-----

> Resumen didÃ¡ctico de la Semana 5**, para que puedas incluirlo en tu manual docente como guÃ­a de trabajo para replicar el sistema de autenticaciÃ³n, JWT y roles con pruebas.
---

## ğŸ§© Semana 5 â€“ GuÃ­a de trabajo (How-to)

### ğŸ¯ Objetivos cumplidos

| Semana | Objetivos principales                            |
| ------ | ------------------------------------------------ |
| 5      | ğŸ” AutenticaciÃ³n y roles (JWT: admin y operador) |
|        | ğŸ§ª Pruebas de endpoints autenticados             |
|        | ğŸ” Middleware y autorizaciÃ³n                     |

---

## ğŸ› ï¸ Paso a paso: AutenticaciÃ³n y pruebas

### 1. **Crear la sesiÃ³n de base de datos y la funciÃ³n `get_db()`**

Archivo: `app/db/session.py`
Esta funciÃ³n se usa para inyectar la sesiÃ³n en los endpoints de FastAPI.

```python
from sqlalchemy.orm import sessionmaker, Session
from .engine import engine

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def get_db():
    db: Session = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

---

### 2. **Configurar los tests con `conftest.py`**

Archivo: `tests/conftest.py`

* Se define un motor de prueba con SQLite en memoria.
* Se crean fixtures para la sesiÃ³n y cliente.
* Se sobreescribe la dependencia de `get_db` para usar la base en memoria.

Puntos clave:

```python
@pytest.fixture()
def client():
    def override_get_db():
        db = TestingSessionLocal()
        try:
            yield db
        finally:
            db.close()

    # âš ï¸ Sobrescribe la dependencia real
    app.dependency_overrides[get_db] = override_get_db

    with TestClient(app) as c:
        yield c
```

> ğŸ” AdemÃ¡s, se limpia la base de datos antes de cada test con `limpiar_tablas()`.

---

### 3. **Agregar rutas protegidas**

Asegurarse de tener en `main.py` (o donde sea que estÃ© el router):

* `/auth/login` con autenticaciÃ³n JWT.
* `/usuarios/me` para obtener datos del usuario autenticado.
* `/admin/zona-segura` protegido con rol `"admin"`.

---

### 4. **Implementar las pruebas: `test_auth.py`**

Archivo: `tests/security/test_auth.py`

Incluye:

* Login correcto.
* Acceso a endpoint autenticado.
* Acceso restringido solo para admin.
* Rechazo de acceso a zona admin si el rol es operador.

Incluye `print()` para que el estudiante vea el paso a paso en consola.

```bash
pytest -v -s tests/security/test_auth.py
```

> âœ… El flag `-s` es clave para que se muestren los mensajes en pantalla.

---

### 5. **VerificaciÃ³n final**

* Usuario con rol "admin" puede loguearse y acceder a zonas protegidas.
* Usuario con rol "operador" puede loguearse pero recibe `403 Forbidden` si intenta acceder a zona admin.
* JWT es requerido para endpoints autenticados.

---

## ğŸ“¦ Archivos importantes en esta semana

| Archivo                            | PropÃ³sito                               |
| ---------------------------------- | --------------------------------------- |
| `app/db/session.py`                | ConexiÃ³n de base de datos + `get_db()`  |
| `tests/conftest.py`                | Setup de DB de prueba y cliente de test |
| `tests/security/test_auth.py`      | Pruebas automatizadas de login y roles  |
| `app/security/auth.py`             | Funciones de login y verificaciÃ³n JWT   |
| `app/routers/auth.py` (si aplica)  | Endpoints relacionados con login        |
| `app/routers/usuarios.py`          | Endpoint `/usuarios/me`                 |
| `app/routers/admin.py` (si aplica) | Endpoint `/admin/zona-segura`           |

---

## ğŸ ConclusiÃ³n de Semana 5

âœ”ï¸ Ya tenemos **autenticaciÃ³n JWT**, **gestiÃ³n de roles**, y **protecciÃ³n de rutas**.
âœ”ï¸ Las pruebas automÃ¡ticas nos garantizan que el sistema responde como se espera.
âœ”ï¸ El setup en `conftest.py` permite replicar este esquema para cualquier otro test del proyecto.

-----
---

## ğŸ“ Archivo: `app/utils/data_setup.py`

### âœ… Â¿QuÃ© hace `crear_usuario_con_rol`?

La funciÃ³n:

```python
def crear_usuario_con_rol(db, username: str, password: str, rol: str):
```

* **ğŸ” Busca** si existe un rol en la base de datos.
* **ğŸ§ª Si no existe**, lo crea.
* **ğŸ” Hashea** la contraseÃ±a.
* **ğŸ‘¤ Crea** un usuario con ese rol asignado.
* **ğŸ’¾ Guarda** los cambios en la base de datos y devuelve el usuario creado.

---

## ğŸ¯ Â¿Para quÃ© sirve?

Esta funciÃ³n estÃ¡ pensada principalmente para **tests automatizados**, pero tambiÃ©n puede usarse como parte del setup en desarrollo o scripts de inicializaciÃ³n.

Te ayuda a:

* Evitar repetir siempre la misma lÃ³gica de creaciÃ³n de usuario y rol.
* Tener una forma consistente y limpia de preparar datos para pruebas.
* Probar permisos (admin vs operador) fÃ¡cilmente.

---

## ğŸ“Œ Â¿DÃ³nde se invoca y cÃ³mo?

### ğŸ§ª 1. **En tests de autenticaciÃ³n**

Por ejemplo, en `tests/security/test_auth.py`:

```python
from app.utils.data_setup import crear_usuario_con_rol

def test_login_ok(client, db_session):
    # ğŸ§ª Setup: usuario admin
    crear_usuario_con_rol(db_session, "admin", "admin123", "admin")

    # ğŸ” Login
    response = client.post("/auth/login", data={"username": "admin", "password": "admin123"})
    assert response.status_code == 200
    assert "access_token" in response.json()
```

> ğŸ§ª Este enfoque asegura que cada test parte de una base consistente (usuario+rol creados).

---

### ğŸ§ª 2. **En otros tests o scripts de carga**

PodÃ©s usarla para cargar usuarios iniciales en modo desarrollo:

```python
# file: scripts/crear_usuarios_demo.py
from app.db.session import SessionLocal
from app.utils.data_setup import crear_usuario_con_rol

db = SessionLocal()
crear_usuario_con_rol(db, "operador", "operador123", "operador")
crear_usuario_con_rol(db, "admin", "admin123", "admin")
db.close()
```

---

## ğŸ§° Ventajas didÃ¡cticas

* Modulariza el cÃ³digo repetido.
* Fomenta **DRY** ("Don't Repeat Yourself").
* Los estudiantes pueden ver cÃ³mo se encapsula lÃ³gica de negocio comÃºn en funciones utilitarias.
* Mejora la legibilidad de los tests.

---


## âœ… VersiÃ³n mejorada con `print()`

ğŸ“„ **Archivo**: `app/utils/data_setup.py`

```python
from app.db.models.usuario import UsuarioORM
from app.db.models.rol import RolORM
from app.security.hashing import hashear_password


def crear_usuario_con_rol(db, username: str, password: str, rol: str):
    print(f"ğŸ” Verificando si existe el rol '{rol}'...")

    # Buscar o crear rol
    rol_obj = db.query(RolORM).filter_by(nombre=rol).first()
    if not rol_obj:
        print(f"â• Rol '{rol}' no existe. Creando nuevo rol...")
        rol_obj = RolORM(nombre=rol)
        db.add(rol_obj)
        db.commit()
        db.refresh(rol_obj)
    else:
        print(f"âœ… Rol '{rol}' ya existe.")

    print(f"ğŸ” Hasheando contraseÃ±a para usuario '{username}'...")
    hashed_pw = hashear_password(password)

    print(f"ğŸ‘¤ Creando usuario '{username}' con rol '{rol}'...")
    user = UsuarioORM(
        username=username,
        email=f"{username}@test.com",
        hashed_password=hashed_pw,
        is_active=True
    )
    user.roles.append(rol_obj)

    db.add(user)
    db.commit()
    db.refresh(user)
    
    print(f"âœ… Usuario '{username}' creado exitosamente con rol '{rol}'.\n")
    return user
```

---

## â–¶ï¸ CÃ³mo ejecutarlo en consola para que guarde en la base

### ğŸ§ª OpciÃ³n 1: En un **test**

Ya lo tenÃ©s integrado en `test_auth.py` asÃ­ que al correr:

```bash
pytest -v tests/security/test_auth.py
```

VerÃ¡s los mensajes en consola gracias a `print()`.

---

### ğŸ§ª OpciÃ³n 2: En un **script manual**

PodÃ©s crear un archivo como este para ejecutar desde consola:

ğŸ“„ `scripts/crear_usuarios_demo.py` (crear la carpeta `scripts/` si no existe)

```python
from app.db.session import SessionLocal
from app.utils.data_setup import crear_usuario_con_rol

# Creamos conexiÃ³n a la base
db = SessionLocal()

# Crear usuarios de prueba
crear_usuario_con_rol(db, "admin", "admin123", "admin")
crear_usuario_con_rol(db, "operador", "operador123", "operador")

# Cerramos la conexiÃ³n
db.close()
```

Y lo ejecutÃ¡s con:

```bash
python scripts/crear_usuarios_demo.py
```

---

## ğŸ§  Â¿QuÃ© aprendemos con esto?

Esto te permite mostrarles a los estudiantes cÃ³mo:

* Reutilizar cÃ³digo con funciones auxiliares.
* Manipular la base de datos en entornos reales y de test.
* Tener feedback visual para entender el flujo de ejecuciÃ³n.

-----

## âœ… **Resumen - Semana 5 completada**

| Tema                                   | Estado |
| -------------------------------------- | ------ |
| ğŸ” AutenticaciÃ³n con JWT               | âœ… OK   |
| ğŸ‘¥ Roles (`admin`, `operador`)         | âœ… OK   |
| ğŸ”’ Middleware de autorizaciÃ³n          | âœ… OK   |
| ğŸ§ª Tests de endpoints protegidos       | âœ… OK   |
| ğŸ”§ Fixtures y base de datos en memoria | âœ… OK   |
| ğŸ§° Utilidad `crear_usuario_con_rol`    | âœ… OK   |
| ğŸ“„ How-to explicativo                  | âœ… OK   |

Todo quedÃ³ integrado y listo para que puedas replicarlo, enseÃ±arlo o usarlo como base para continuar.







<!--stackedit_data:
eyJoaXN0b3J5IjpbMTI0NjAyMTgyNiwxMzgyMDUyNTY5LDcxMz
IzNjU1NCwtMTE2MjkyNTAyMSwyMTQwNzkzMTU1LC0xNTMyMzcy
NTI3LC0xMTA0ODU5NDkyLC01NjI4OTg4NTksLTE0NTgxODQ0MD
csLTIxNTg4ODczOCwxNTM4NjUyNTk4LC01MTYwNzIxNTgsLTE3
NzU1NzUzMzIsNDc3OTcwMDMyLC0yMDEyMDg2MDI2LC0yMDI4NT
MwNjE0LDUzMjE2MTQwMSwtMzYyNzkzMDM2LC0xODAyMDA0NjEy
LDk0NjA0NjU2MF19
-->