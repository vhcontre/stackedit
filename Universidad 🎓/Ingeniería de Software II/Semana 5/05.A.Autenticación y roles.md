# ğŸ“… Semana 5 â€“ AutenticaciÃ³n y roles.

| Semana | Objetivos principales                                             |
| ------ | ----------------------------------------------------------------- |
| 5      | ğŸ” AutenticaciÃ³n y roles (JWT: admin y operador)                  |
|        | ğŸ§ª Pruebas de endpoints autenticados                              |
|        | ğŸ” Middleware y autorizaciÃ³n                                      |



-   âœ… Modelos ORM de `Usuario` y `Rol` con relaciÃ³n muchos a muchos.
    
-   âœ… Esquemas Pydantic para `Usuario` y `Rol`.
    

----------

## ğŸ§© Paso 1: Implementar autenticaciÃ³n con JWT (`/login`)

### ğŸ¯ Objetivo:

Crear un endpoint `/login` donde el usuario se autentica con `username` y `password`, y si es vÃ¡lido, recibe un **JWT** con su informaciÃ³n.

----------

### ğŸ“¦ Estructura sugerida

-   `app/security/auth.py` â†’ funciones de autenticaciÃ³n y generaciÃ³n/verificaciÃ³n de JWT.
    
-   `app/routers/auth.py` â†’ rutas de login.
    

----------

### ğŸ” 1.1. Instalar dependencia necesaria

Si no la tenÃ©s:

```bash
pip install python-jose[cryptography] passlib[bcrypt]

```

----------

### ğŸ”§ 1.2. Crear archivo `app/security/auth.py`

```python
from datetime import datetime, timedelta
from jose import JWTError, jwt
from passlib.context import CryptContext
from app.db.models.usuario import UsuarioORM
from sqlalchemy.orm import Session

# Clave secreta para firmar el token (ponela segura en producciÃ³n)
SECRET_KEY = "super-secret-key"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verificar_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def obtener_password_hash(password):
    return pwd_context.hash(password)

def autenticar_usuario(db: Session, username: str, password: str):
    usuario = db.query(UsuarioORM).filter(UsuarioORM.username == username).first()
    if not usuario:
        return None
    if not verificar_password(password, usuario.hashed_password):
        return None
    return usuario

def crear_token_acceso(data: dict, expires_delta: timedelta | None = None):
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

```

----------

### ğŸ“„ 1.3. Crear `app/schemas/token.py`

```python
from pydantic import BaseModel

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: str | None = None

```

----------

### ğŸ“¥ 1.4. Crear endpoint de login en `app/routers/auth.py`

```python
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from app.db.session import get_db
from app.security import auth
from app.schemas.token import Token

router = APIRouter(prefix="/auth", tags=["auth"])

@router.post("/login", response_model=Token)
def login(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):
    usuario = auth.autenticar_usuario(db, form_data.username, form_data.password)
    if not usuario:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Usuario o contraseÃ±a incorrecta"
        )
    access_token = auth.crear_token_acceso(data={"sub": usuario.username})
    return {"access_token": access_token, "token_type": "bearer"}

```

ğŸ’¡ Este endpoint espera los datos como `application/x-www-form-urlencoded`, por eso usamos `OAuth2PasswordRequestForm`.

----------

### âš™ï¸ 1.5. Montar el router

En `main.py` o el archivo principal de FastAPI:

```python
from app.routers import auth
app.include_router(auth.router)

```

----------

### âœ… Â¿QuÃ© sigue?

Una vez que tengas este paso implementado y funcionando, probamos que puedas hacer login correctamente (por ejemplo desde Postman o cURL). DespuÃ©s avanzamos a:

-   Paso 2: Middleware/Dependencia para proteger endpoints.
    
-   Paso 3: AutorizaciÃ³n por roles (admin vs operador).
    
-   Paso 4: Pruebas automÃ¡ticas.
    

----------

## âœ… Paso 1: Cargar un usuario manualmente en la base de datos

Como aÃºn no tenemos un endpoint para registrar usuarios, hay que **crear uno a mano** en un script o directamente desde consola, usando `obtener_password_hash`.

### Ejemplo para precargar un usuario:

```python
# file: scripts/crear_usuario.py (ejecÃºtalo una vez)

from sqlalchemy.orm import Session
from app.db.session import SessionLocal
from app.db.models.usuario import UsuarioORM
from app.security.auth import obtener_password_hash

db: Session = SessionLocal()

nuevo_usuario = UsuarioORM(
    username="admin",
    email="admin@email.com",
    hashed_password=obtener_password_hash("admin123"),
    is_active=True
)

db.add(nuevo_usuario)
db.commit()
db.close()
print("âœ… Usuario creado con Ã©xito.")

```

> âš ï¸ Usa una contraseÃ±a real que despuÃ©s pruebes en Postman: `"admin123"` en este ejemplo.

----------

## âœ… Paso 2: Probar el endpoint `/auth/login` desde Postman

### 1. Abre Postman

Haz una solicitud `POST` a:

```
http://localhost:8000/auth/login

```

### 2. En **Body**, selecciona la opciÃ³n **x-www-form-urlencoded** y completa:

key

value

username

admin

password

admin123

### 3. Click en **Send**

----------

### âœ… Si todo va bien, obtendrÃ¡s una respuesta como:

```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR...",
  "token_type": "bearer"
}

```

Este token es lo que vas a usar luego para acceder a endpoints protegidos.

----------

## ğŸ› ï¸ Â¿QuÃ© hacer si falla?

-   Si devuelve 401 â†’ revisÃ¡ que el `username` y la `password` sean correctos.
    
-   Si lanza otro error â†’ pasame el traceback o error exacto que devuelve la API.
    

----------

## ğŸ§ª Â¿QuerÃ©s que agreguemos ahora un endpoint protegido que use ese JWT?

Por ejemplo, un `/usuarios/me` que devuelva la info del usuario logueado. AsÃ­ probÃ¡s cÃ³mo usar el token.

Â¿Avanzamos con eso?

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTM2Mjc5MzAzNiwtMTgwMjAwNDYxMiw5ND
YwNDY1NjBdfQ==
-->