# **üìå Unidad 4: Dise√±o de Patrones para Programaci√≥n Concurrente**

## üîπ **Definici√≥n e Introducci√≥n a Patrones de Dise√±o**

En la programaci√≥n concurrente, los **patrones de dise√±o** son soluciones reutilizables que nos ayudan a resolver problemas comunes que surgen cuando trabajamos con m√∫ltiples hilos o tareas concurrentes. Estos patrones nos permiten estructurar nuestro c√≥digo de forma m√°s eficiente, reducir el riesgo de errores y mejorar el rendimiento.

Los patrones de dise√±o proporcionan una gu√≠a sobre c√≥mo organizar la interacci√≥n entre los diferentes componentes de un sistema concurrente, haciendo que el c√≥digo sea m√°s claro y f√°cil de mantener.

<br />

## üîπ **üí° Patr√≥n "Pipeline"**

El **Patr√≥n Pipeline** es utilizado cuando los datos necesitan ser procesados en una serie de etapas. Cada etapa en el pipeline procesa una parte de los datos y pasa el resultado a la siguiente etapa.

Este patr√≥n es especialmente √∫til cuando tenemos un flujo de trabajo que puede dividirse en varios pasos, y cada paso puede ejecutarse en paralelo, independientemente de los dem√°s.

**Ejemplo en C#:**

```csharp
using System;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        // Paso 1: Generar datos
        var data = new int[] { 1, 2, 3, 4, 5 };

        // Paso 2: Procesar datos en paralelo (Pipeline)
        var processedData = Task.WhenAll(data.Select(d => Task.Run(() => ProcessData(d))));

        // Esperamos que todos los pasos de procesamiento terminen
        processedData.Wait();
        Console.WriteLine("Procesamiento completado.");
    }

    static int ProcessData(int data)
    {
        // Simulaci√≥n de procesamiento
        Console.WriteLine($"Procesando {data}...");
        return data * 2;
    }
}

```

Este ejemplo demuestra c√≥mo se pueden procesar datos en paralelo usando el patr√≥n Pipeline, donde cada dato se procesa de manera independiente y luego se pasa a la siguiente etapa de procesamiento.

----------

### ¬øQu√© es el patr√≥n Pipeline?

Es un patr√≥n de dise√±o que divide el procesamiento de datos en una serie de etapas independientes, donde la salida de una etapa puede ser la entrada de la siguiente. Aunque tradicionalmente estas etapas est√°n encadenadas, aqu√≠ usamos tareas paralelas para procesar cada elemento individualmente, lo cual es una **forma concurrente del pipeline**.

----------

### Paso a paso del c√≥digo

```csharp
var data = new int[] { 1, 2, 3, 4, 5 };

```

üîπ **Paso 1: Fuente de datos**

-   Se declara un arreglo de enteros que act√∫a como datos de entrada.
    
-   Esto simula, por ejemplo, elementos que deben ser procesados uno a uno.
    

----------

```csharp
var processedData = Task.WhenAll(
    data.Select(d => Task.Run(() => ProcessData(d)))
);

```

üîπ **Paso 2: Lanzar tareas paralelas**

-   `data.Select(...)` transforma cada n√∫mero en una tarea as√≠ncrona con `Task.Run`.
    
-   `ProcessData(d)` simula el procesamiento de cada elemento.
    
-   `Task.WhenAll(...)` espera que **todas las tareas se completen** y devuelve un arreglo de resultados.
    
-   Aqu√≠ estamos aplicando un pipeline _en paralelo_: cada tarea representa una etapa independiente del procesamiento.
    

----------

```csharp
processedData.Wait();

```

üîπ **Paso 3: Esperar el resultado**

-   `Wait()` bloquea el hilo principal hasta que todas las tareas finalicen.
    

----------

```csharp
foreach (var result in processedData.Result)
{
    Console.WriteLine($"Resultado: {result}");
}

```

üîπ **Paso 4: Mostrar los resultados**

-   Se recorren los resultados devueltos por las tareas y se imprime cada uno.
    
-   La propiedad `.Result` accede a los valores retornados por cada tarea.
    

----------

```csharp
static int ProcessData(int data)
{
    Console.WriteLine($"Procesando {data}...");
    return data * 2;
}

```

üîπ **Paso 5: Funci√≥n de procesamiento**

-   Simula una operaci√≥n sobre los datos (multiplicaci√≥n por 2).
    
-   Imprime por consola qu√© dato est√° siendo procesado.
    

----------

### ¬øQu√© logramos con esto?

-   **Paralelismo**: Cada elemento del array se procesa en su propia tarea.
    
-   **Escalabilidad**: Aprovecha varios n√∫cleos del CPU si est√°n disponibles.
    
-   **Simplicidad**: Aunque no hay m√∫ltiples etapas, cada tarea act√∫a como una "etapa" aut√≥noma del pipeline.
    

----------

### ¬øPodr√≠a mejorarse?

Un pipeline m√°s realista podr√≠as tener:

-   M√∫ltiples etapas encadenadas (por ejemplo, map ‚Üí filter ‚Üí reduce).
    
-   Uso de `TPL Dataflow` o `Channels` en lugar de solo `Task.WhenAll`.
    

Perfecto. Vamos a llevar el ejemplo anterior a un **pipeline encadenado m√°s realista**, simulando **m√∫ltiples etapas de procesamiento** (como las que podr√≠as encontrar en procesamiento de datos, im√°genes, o flujo de eventos). Luego, m√°s adelante, podemos profundizar en el patr√≥n **Dataflow**.

----------

### üèóÔ∏è Pipeline Realista con Tareas Encadenadas en C#

Cada dato pasar√° por **tres etapas secuenciales**, pero cada dato se procesa en paralelo con respecto a los dem√°s.

```csharp
using System;
using System.Linq;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        var datos = new int[] { 1, 2, 3, 4, 5 };

        // Ejecutar el pipeline para cada dato en paralelo
        var resultados = await Task.WhenAll(
            datos.Select(async dato =>
            {
                var etapa1 = await Etapa1Async(dato);
                Console.WriteLine($"Dato {dato} ‚Üí Etapa 1: {etapa1}");

                var etapa2 = await Etapa2Async(etapa1);
                Console.WriteLine($"Dato {dato} ‚Üí Etapa 2: {etapa2}");

                var etapa3 = await Etapa3Async(etapa2);
                Console.WriteLine($"Dato {dato} ‚Üí Etapa 3 (resultado final): {etapa3}");

                return etapa3;
            })
        );

        Console.WriteLine("\n=== Resultados finales ===");
        foreach (var resultado in resultados)
        {
            Console.WriteLine($"Resultado: {resultado}");
        }
    }

    static Task<int> Etapa1Async(int valor)
    {
        // Suma 1 al valor
        return Task.FromResult(valor + 1);
    }

    static Task<int> Etapa2Async(int valor)
    {
        // Multiplica por 2
        return Task.FromResult(valor * 2);
    }

    static Task<int> Etapa3Async(int valor)
    {
        // Resta 3
        return Task.FromResult(valor - 3);
    }
}


```

----------

### Detalle de la operaci√≥n concurrente

1.  **Paralelismo entre datos**: Cada dato se procesa en su propia cadena de tareas.
    
2.  **Secuencia dentro del pipeline**: Las etapas se ejecutan en orden para cada dato (Etapa 1 ‚Üí Etapa 2 ‚Üí Etapa 3).
    
3.  **Task.WhenAll(...)** espera que todos los flujos de datos finalicen.
    

----------

### Ejemplo visual del flujo:

```
2 --> Etapa1 (2+1 = 3)
   --> Etapa2 (3*2 = 6)
   --> Etapa3 (6-3 = 3)

```

Esto se hace para todos los datos al mismo tiempo, pero cada uno sigue esa misma cadena.

<br />

## üîπ **üîÑ Patr√≥n "Dataflow"**

El **Patr√≥n Dataflow** es similar al patr√≥n Pipeline, pero m√°s general. Aqu√≠, los datos fluyen a trav√©s de varios nodos (procesos o tareas) y son procesados de forma independiente. Este patr√≥n es √∫til cuando necesitamos que varias tareas puedan consumir los mismos datos, pero a la vez, puedan ejecutarse de forma independiente.

**Ejemplo en C#:**

```csharp
using System;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        // Crear una colecci√≥n de datos
        var data = new int[] { 1, 2, 3, 4, 5 };

        // Tareas paralelas para procesar los datos con Dataflow
        var tasks = data.Select(d => Task.Run(() => ProcessData(d)));

        // Esperar que todas las tareas se completen
        Task.WhenAll(tasks).Wait();

        Console.WriteLine("Procesamiento completo.");
    }

    static void ProcessData(int data)
    {
        Console.WriteLine($"Procesando {data}...");
    }
}

```

En este ejemplo, cada elemento de la colecci√≥n es procesado de manera independiente utilizando el patr√≥n Dataflow. Las tareas se ejecutan en paralelo y permiten un flujo eficiente de datos.

Explicaci√≥n paso a paso de este c√≥digo que simula un **patr√≥n Dataflow**, aunque no usa directamente la librer√≠a `System.Threading.Tasks.Dataflow`, pero s√≠ representa su esencia: **procesamiento paralelo de datos en etapas independientes**.

---

###  Paso a paso del c√≥digo:

#### üîπ 1. **Definici√≥n de los datos**
```csharp
var data = new int[] { 1, 2, 3, 4, 5 };
```
Se crea una colecci√≥n de datos (un arreglo de enteros). Estos son los ‚Äúelementos‚Äù que pasar√°n por el flujo de procesamiento.

---

#### üîπ 2. **Inicio del procesamiento paralelo**
```csharp
var tasks = data.Select(d => Task.Run(() => ProcessData(d)));
```
Cada elemento del arreglo se procesa en paralelo usando `Task.Run()`. Esto lanza una nueva tarea por cada n√∫mero, que se ejecutar√° de forma as√≠ncrona.  
üìå Aqu√≠ cada "nodo" del flujo procesa un dato, como en un bloque de acci√≥n en Dataflow.

---

#### üîπ 3. **Esperar la finalizaci√≥n de todas las tareas**
```csharp
Task.WhenAll(tasks).Wait();
```
Se espera a que **todas las tareas paralelas finalicen** antes de continuar. Este paso sincroniza el flujo, asegurando que el programa no termine antes de tiempo.

---

#### üîπ 4. **Salida final**
```csharp
Console.WriteLine("Procesamiento completo.");
```
Una vez que todo el procesamiento ha terminado, se imprime un mensaje de confirmaci√≥n.

---

#### üîπ 5. **M√©todo de procesamiento**
```csharp
static void ProcessData(int data)
{
    Console.WriteLine($"Procesando {data}...");
}
```
Cada tarea llama a este m√©todo, que simplemente **simula un procesamiento** mostrando qu√© n√∫mero est√° siendo tratado.

---

### ¬øEs realmente Dataflow?

Aunque este ejemplo no usa bloques expl√≠citos como `TransformBlock` o `BufferBlock`, **simula el patr√≥n Dataflow** en su forma m√°s simple:

- Entrada ‚Üí procesamiento independiente ‚Üí sincronizaci√≥n final.
- Usa **paralelismo con tareas** para imitar el flujo de datos asincr√≥nico y segmentado del patr√≥n.

>Se muestra **versi√≥n real del patr√≥n Dataflow** usando la biblioteca `System.Threading.Tasks.Dataflow`, que forma parte del espacio de nombres `System.Threading.Tasks.Dataflow`. Este patr√≥n permite **encadenar bloques de procesamiento asincr√≥nicos y paralelos**, ideal para flujos de trabajo tipo ‚Äúpipeline‚Äù.

---

### Ejemplo usando `Dataflow`

```csharp
using System;
using System.Threading.Tasks;
using System.Threading.Tasks.Dataflow;

class Program
{
    static async Task Main()
    {
        // Paso 1: Crear el bloque de entrada (TransformBlock)
        var transformBlock = new TransformBlock<int, int>(n =>
        {
            Console.WriteLine($"Procesando {n}...");
            return n * 2; // Simulamos procesamiento
        });

        // Paso 2: Crear el bloque de salida (ActionBlock)
        var actionBlock = new ActionBlock<int>(result =>
        {
            Console.WriteLine($"Resultado: {result}");
        });

        // Paso 3: Encadenar bloques (link)
        transformBlock.LinkTo(actionBlock, new DataflowLinkOptions { PropagateCompletion = true });

        // Paso 4: Postear datos al pipeline
        foreach (var n in new[] { 1, 2, 3, 4, 5 })
        {
            transformBlock.Post(n);
        }

        // Paso 5: Se√±alar fin de entrada
        transformBlock.Complete();

        // Paso 6: Esperar a que el pipeline termine
        await actionBlock.Completion;

        Console.WriteLine("Procesamiento completo.");
    }
}
```

---

### Explicaci√≥n paso a paso:

| Paso | Descripci√≥n |
|------|-------------|
| 1. `TransformBlock` | Recibe datos, los procesa (aqu√≠ multiplica por 2), y los pasa al siguiente bloque. |
| 2. `ActionBlock` | Consume el resultado y lo muestra por consola. |
| 3. `LinkTo` | Conecta ambos bloques para que trabajen en flujo continuo. |
| 4. `Post()` | Envia datos al pipeline. |
| 5. `Complete()` | Se√±ala que no se enviar√°n m√°s datos. |
| 6. `await Completion` | Espera que todos los datos se procesen antes de cerrar. |

---

Esto s√≠ implementa el **patr√≥n Dataflow completo**: con bloques enlazados, procesamiento asincr√≥nico y desacople entre etapas.


Patr√≥n **Dataflow** en un escenario m√°s realista y completo. El flujo de procesamiento es para una tienda en l√≠nea, donde cada pedido pasa por varias etapas:

---

### üõí Escenario: Procesamiento de Pedidos

**Etapas:**
1. **Recepci√≥n del pedido**
2. **Validaci√≥n del pedido**
3. **Procesamiento de pago**
4. **Confirmaci√≥n y notificaci√≥n**

---

### üíª Implementaci√≥n con Dataflow

```csharp
using System;
using System.Threading.Tasks;
using System.Threading.Tasks.Dataflow;

class Program
{
    static async Task Main()
    {
        // Etapa 1: Recepci√≥n
        var recepcionBlock = new TransformBlock<string, string>(pedido =>
        {
            Console.WriteLine($"Pedido recibido: {pedido}");
            return pedido;
        });

        // Etapa 2: Validaci√≥n
        var validacionBlock = new TransformBlock<string, string>(pedido =>
        {
            Console.WriteLine($"Validando pedido: {pedido}");
            if (string.IsNullOrWhiteSpace(pedido)) throw new ArgumentException("Pedido inv√°lido");
            return pedido;
        });

        // Etapa 3: Procesamiento de pago
        var pagoBlock = new TransformBlock<string, string>(pedido =>
        {
            Console.WriteLine($"Procesando pago de: {pedido}");
            Task.Delay(500).Wait(); // Simula espera
            return pedido;
        });

        // Etapa 4: Confirmaci√≥n
        var confirmacionBlock = new ActionBlock<string>(pedido =>
        {
            Console.WriteLine($"Pedido confirmado y cliente notificado: {pedido}");
        });

        // Encadenar bloques
        recepcionBlock.LinkTo(validacionBlock, new DataflowLinkOptions { PropagateCompletion = true });
        validacionBlock.LinkTo(pagoBlock, new DataflowLinkOptions { PropagateCompletion = true });
        pagoBlock.LinkTo(confirmacionBlock, new DataflowLinkOptions { PropagateCompletion = true });

        // Enviar pedidos
        foreach (var pedido in new[] { "Pedido #1", "Pedido #2", "Pedido #3" })
        {
            recepcionBlock.Post(pedido);
        }

        // Se√±alar fin del pipeline
        recepcionBlock.Complete();

        // Esperar fin del procesamiento
        await confirmacionBlock.Completion;

        Console.WriteLine("Todos los pedidos han sido procesados.");
    }
}
```

---

### üîé ¬øQu√© estamos simulando aqu√≠?

| Etapa                | Descripci√≥n                                                                 |
|----------------------|------------------------------------------------------------------------------|
| Recepci√≥n            | Se recibe el pedido.                                                        |
| Validaci√≥n           | Se verifica que el pedido sea v√°lido.                                       |
| Procesamiento de pago| Simula una demora para representar la autorizaci√≥n de pago.                 |
| Confirmaci√≥n         | Se notifica al cliente del pedido exitoso.                                  |

---

Este ejemplo simula **un pipeline de procesamiento real**, desacoplado y concurrente.


**Extender el pipeline con manejo de errores y reintentos autom√°ticos**. Esto es muy √∫til en escenarios reales donde, por ejemplo, un pago puede fallar moment√°neamente, o un pedido puede estar mal formado.

----------

###  Requisitos 

1.  **Manejo de errores en etapas cr√≠ticas** (por ejemplo, validaci√≥n y pago).
    
2.  **Reintentos autom√°ticos** si un paso falla temporalmente.
    
3.  **Log de errores en consola** para seguimiento.
    

----------

###  Implementaci√≥n con manejo de errores y reintentos

Aqu√≠ usamos `TransformBlock` con l√≥gica de reintento en el procesamiento de pagos:

```csharp
using System;
using System.Threading.Tasks;
using System.Threading.Tasks.Dataflow;

class Program
{
    static async Task Main()
    {
        var recepcionBlock = new TransformBlock<string, string>(pedido =>
        {
            Console.WriteLine($"Pedido recibido: {pedido}");
            return pedido;
        });

        var validacionBlock = new TransformBlock<string, string>(pedido =>
        {
            Console.WriteLine($"Validando pedido: {pedido}");
            if (pedido == "Pedido inv√°lido") throw new ArgumentException("Pedido inv√°lido");
            return pedido;
        });

        var pagoBlock = new TransformBlock<string, string>(async pedido =>
        {
            int intentos = 0;
            while (true)
            {
                try
                {
                    intentos++;
                    Console.WriteLine($"Procesando pago de: {pedido} (Intento {intentos})");
                    if (pedido.Contains("#2") && intentos < 2)
                        throw new Exception("Error temporal en el pago.");
                    await Task.Delay(500);
                    return pedido;
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error: {ex.Message}");
                    if (intentos >= 3)
                        throw;
                    await Task.Delay(1000); // Espera antes de reintentar
                }
            }
        });

        var confirmacionBlock = new ActionBlock<string>(pedido =>
        {
            Console.WriteLine($"Pedido confirmado: {pedido}");
        });

        // Enlace entre bloques
        var opciones = new DataflowLinkOptions { PropagateCompletion = true };
        recepcionBlock.LinkTo(validacionBlock, opciones);
        validacionBlock.LinkTo(pagoBlock, opciones, pedido => true); // flujo normal
        validacionBlock.LinkTo(DataflowBlock.NullTarget<string>(), pedido => false); // descartar inv√°lidos
        pagoBlock.LinkTo(confirmacionBlock, opciones);

        // Enviar pedidos
        var pedidos = new[] { "Pedido #1", "Pedido #2", "Pedido inv√°lido", "Pedido #3" };
        foreach (var pedido in pedidos)
            recepcionBlock.Post(pedido);

        recepcionBlock.Complete();
        await confirmacionBlock.Completion;

        Console.WriteLine("Pipeline finalizado.");
    }
}

```

----------

###  Requerimientos logrados 

-   Se simulan **reintentos autom√°ticos** en el pago si ocurre un error transitorio.
    
-   Se **descartan pedidos inv√°lidos** sin detener el resto del flujo.
    
-   Se mantiene un **flujo asincr√≥nico y paralelo**.
    


----------

### Cola de errores
Extender el pipeline incluyendo una **cola de errores** para registrar pedidos que no pudieron completarse tras los reintentos.

-   Una nueva etapa (`registroErroresBlock`) que recibe pedidos fallidos.
    
-   Manejo de errores con `Try...Catch` en el bloque de pago para redirigir fallos definitivos.
    

----------

### C√≥digo extendido con cola de errores

```csharp
using System;
using System.Threading.Tasks;
using System.Threading.Tasks.Dataflow;

class Program
{
    static async Task Main()
    {
        var recepcionBlock = new TransformBlock<string, string>(pedido =>
        {
            Console.WriteLine($"Pedido recibido: {pedido}");
            return pedido;
        });

        var validacionBlock = new TransformBlock<string, string>(pedido =>
        {
            Console.WriteLine($"Validando pedido: {pedido}");
            if (pedido == "Pedido inv√°lido") throw new ArgumentException("Pedido inv√°lido");
            return pedido;
        });

        var pagoBlock = new TransformManyBlock<string, string>(async pedido =>
        {
            int intentos = 0;
            while (true)
            {
                try
                {
                    intentos++;
                    Console.WriteLine($"Procesando pago: {pedido} (Intento {intentos})");
                    if (pedido.Contains("#2") && intentos < 2)
                        throw new Exception("Error temporal en pago.");
                    await Task.Delay(500);
                    return new[] { pedido }; // √©xito
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error: {ex.Message}");
                    if (intentos >= 3)
                        return Array.Empty<string>(); // ser√° redirigido a error
                    await Task.Delay(1000);
                }
            }
        });

        var confirmacionBlock = new ActionBlock<string>(pedido =>
        {
            Console.WriteLine($"Pedido confirmado: {pedido}");
        });

        var registroErroresBlock = new ActionBlock<string>(pedido =>
        {
            Console.WriteLine($"Pedido fallido: {pedido}");
        });

        var opciones = new DataflowLinkOptions { PropagateCompletion = true };

        // Flujo principal
        recepcionBlock.LinkTo(validacionBlock, opciones);
        validacionBlock.LinkTo(pagoBlock, opciones);
        pagoBlock.LinkTo(confirmacionBlock, opciones, pedido => !string.IsNullOrWhiteSpace(pedido));
        pagoBlock.LinkTo(registroErroresBlock, opciones, pedido => string.IsNullOrWhiteSpace(pedido));

        // Enviar pedidos
        var pedidos = new[] { "Pedido #1", "Pedido #2", "Pedido inv√°lido", "Pedido #3" };
        foreach (var pedido in pedidos)
            recepcionBlock.Post(pedido);

        recepcionBlock.Complete();
        await Task.WhenAll(confirmacionBlock.Completion, registroErroresBlock.Completion);

        Console.WriteLine("Pipeline finalizado con manejo de errores.");
    }
}

```

----------

###  Ventajas de la implementaci√≥n 

-   Se evitan bloqueos al separar los errores en otro flujo.
    
-   Los pedidos problem√°ticos se registran sin detener el pipeline.
    
-   El flujo completo es resiliente ante fallas puntuales.
    



----------

## üîπ **üöÄ Incrementando el Paralelismo Utilizando el Patr√≥n Pipeline y Dataflow**

Al aplicar los patrones Pipeline y Dataflow, podemos incrementar el paralelismo al dividir las tareas en unidades m√°s peque√±as y ejecutarlas de manera concurrente. Al incrementar el paralelismo, podemos mejorar el rendimiento y reducir el tiempo de procesamiento.

En el caso del patr√≥n **Pipeline**, cada etapa puede ser ejecutada en paralelo, lo que nos permite aumentar la eficiencia del procesamiento de datos. En el caso del patr√≥n **Dataflow**, podemos realizar tareas independientes y concurrentes en diferentes nodos.

----------

## üîπ **üë• Uso de Estructuras de Datos Concurrentes**

Cuando trabajamos con programaci√≥n concurrente, es esencial usar **estructuras de datos concurrentes** que permitan el acceso seguro desde m√∫ltiples hilos. Ejemplos comunes de estas estructuras son las **colas concurrentes** (como `ConcurrentQueue`) y los **diccionarios concurrentes** (`ConcurrentDictionary`).

Estas estructuras nos permiten manejar la sincronizaci√≥n de manera eficiente, sin tener que preocuparnos por los bloqueos manuales.

**Ejemplo de uso de `ConcurrentQueue`:**

```csharp
using System;
using System.Collections.Concurrent;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        var queue = new ConcurrentQueue<int>();
        
        // Insertar elementos en la cola concurrente
        for (int i = 0; i < 10; i++)
        {
            queue.Enqueue(i);
        }

        // Procesar elementos en paralelo
        var tasks = new Task[10];
        for (int i = 0; i < 10; i++)
        {
            tasks[i] = Task.Run(() => ProcessQueue(queue));
        }

        Task.WhenAll(tasks).Wait();
        Console.WriteLine("Procesamiento completado.");
    }

    static void ProcessQueue(ConcurrentQueue<int> queue)
    {
        if (queue.TryDequeue(out var item))
        {
            Console.WriteLine($"Procesando {item}...");
        }
    }
}

```

En este ejemplo, estamos utilizando una `ConcurrentQueue` para almacenar y procesar elementos de forma segura desde m√∫ltiples hilos.

----------

## üîπ **üì¶ Patr√≥n Productor-Consumidor**

El **Patr√≥n Productor-Consumidor** es un patr√≥n cl√°sico en la programaci√≥n concurrente donde hay un productor que genera datos y un consumidor que los procesa. Entre el productor y el consumidor hay una **cola** (o buffer), que almacena los elementos hasta que el consumidor pueda procesarlos.

Este patr√≥n es √∫til cuando hay una desaceleraci√≥n en el procesamiento y el productor sigue generando datos a un ritmo m√°s r√°pido que el consumidor.

**Ejemplo en C#:**

```csharp
using System;
using System.Collections.Concurrent;
using System.Threading;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        var queue = new BlockingCollection<int>();
        
        // Crear y ejecutar el productor
        var producer = Task.Run(() => Produce(queue));
        
        // Crear y ejecutar el consumidor
        var consumer = Task.Run(() => Consume(queue));

        await Task.WhenAll(producer, consumer);
    }

    static void Produce(BlockingCollection<int> queue)
    {
        for (int i = 0; i < 10; i++)
        {
            queue.Add(i);
            Console.WriteLine($"Productor ha agregado {i}.");
            Thread.Sleep(500);
        }
        queue.CompleteAdding();
    }

    static void Consume(BlockingCollection<int> queue)
    {
        foreach (var item in queue.GetConsumingEnumerable())
        {
            Console.WriteLine($"Consumidor est√° procesando {item}.");
            Thread.Sleep(1000);
        }
    }
}

```

En este ejemplo, el **Productor** agrega elementos a la **BlockingCollection** y el **Consumidor** los procesa, uno a uno. La **BlockingCollection** garantiza que los elementos sean manejados de manera segura.

----------

## üîπ **üß© Patr√≥n "Map-Reduce"**

El **Patr√≥n Map-Reduce** es utilizado para dividir tareas grandes en subtareas peque√±as que pueden ser procesadas en paralelo. Una vez procesadas las subtareas, los resultados se combinan (reduce) para obtener el resultado final. Es ideal para procesamiento de grandes vol√∫menes de datos, como an√°lisis de datos y procesamiento de texto.

**Ejemplo en C#:**

```csharp
using System;
using System.Linq;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        var data = new int[] { 1, 2, 3, 4, 5 };

        // Paso 1: Mapeo (cada n√∫mero se multiplica por 2)
        var mappedData = data.AsParallel().Select(x => x * 2);

        // Paso 2: Reducci√≥n (sumar todos los resultados)
        var result = mappedData.Sum();

        Console.WriteLine($"Resultado final de Map-Reduce: {result}");
    }
}

```

En este ejemplo, aplicamos el patr√≥n Map-Reduce en dos pasos: **Map** (multiplicamos los elementos por 2) y **Reduce** (sumamos los resultados).

----------

## **üó∫Ô∏è Mapa Conceptual de la Unidad 4: Dise√±o de Patrones para Programaci√≥n Concurrente**

```
                     +---------------------------------------+
                     |   Dise√±o de Patrones para Programaci√≥n|
                     |            Concurrente               |
                     +---------------------------------------+
                                   |
             +---------------------+---------------------+
             |                                           |
   +-----------------+                          +----------------+
   |  Patr√≥n Pipeline|                          |   Patr√≥n Dataflow|
   |       ‚è≥         |                          |      üîÑ          |
   +-----------------+                          +----------------+
             |                                           |
   +------------------+                          +----------------+
   | Incrementando el |                          | Uso de Estructuras|
   | Paralelismo      |                          | Concurrentes      |
   |   üöÄ             |                          |    üìö            |
   +------------------+                          +----------------+
                                   |
                   +-------------------------------+
                   | Patr√≥n Productor-Consumidor    |
                   |            üë•                   |
                   +-------------------------------+
                                   |
                  +----------------------------------+
                  |       Patr√≥n Map-Reduce         |
                  |              üß©                 |
                  +----------------------------------+

```

----------

### **üó∫Ô∏è Mapa Conceptual Detallado**

**Dise√±o de Patrones para Programaci√≥n Concurrente**  
Este es el concepto principal de la unidad, que cubre la utilizaci√≥n de patrones espec√≠ficos para gestionar la programaci√≥n concurrente de manera m√°s eficiente y organizada.

----------

#### **1. Patr√≥n "Pipeline" ‚è≥**

-   **Objetivo:** Este patr√≥n ayuda a organizar las tareas de procesamiento en etapas que pueden ejecutarse en paralelo.
    
-   **Conexi√≥n con la unidad:** Ayuda a mejorar la eficiencia del procesamiento de datos cuando el flujo de trabajo puede dividirse en pasos independientes.
    

----------

#### **2. Patr√≥n "Dataflow" üîÑ**

-   **Objetivo:** Similar al patr√≥n "Pipeline", pero m√°s flexible. Aqu√≠, los datos fluyen a trav√©s de m√∫ltiples nodos que realizan tareas independientes en paralelo.
    
-   **Conexi√≥n con la unidad:** Facilita el dise√±o de sistemas donde varias tareas concurrentes consumen y producen datos sin depender unas de otras.
    

----------

#### **3. Incrementando el Paralelismo üöÄ**

-   **Objetivo:** El paralelismo se incrementa utilizando los patrones mencionados ("Pipeline" y "Dataflow"), ya que al dividir las tareas en pasos o nodos m√°s peque√±os, podemos ejecutar m√°s operaciones de manera concurrente.
    
-   **Conexi√≥n con la unidad:** Cuando incrementamos el paralelismo, aprovechamos mejor los recursos del sistema y reducimos el tiempo de ejecuci√≥n al realizar tareas simult√°neamente.
    

----------

#### **4. Uso de Estructuras Concurrentes üìö**

-   **Objetivo:** Las estructuras de datos concurrentes como `ConcurrentQueue`, `BlockingCollection` y `ConcurrentDictionary` permiten un acceso seguro desde m√∫ltiples hilos sin necesidad de bloqueos manuales.
    
-   **Conexi√≥n con la unidad:** Permite manejar los datos de manera eficiente cuando estamos trabajando con m√∫ltiples hilos y tareas paralelas, ayudando a evitar errores de concurrencia.
    

----------

#### **5. Patr√≥n Productor-Consumidor üë•**

-   **Objetivo:** Separa las responsabilidades de generar datos (productor) y procesarlos (consumidor). Utiliza una cola para almacenar datos que el consumidor procesar√°.
    
-   **Conexi√≥n con la unidad:** Este patr√≥n permite gestionar el flujo de datos de manera concurrente, manteniendo el sistema eficiente cuando la producci√≥n y el consumo de datos ocurren a diferentes ritmos.
    

----------

#### **6. Patr√≥n "Map-Reduce" üß©**

-   **Objetivo:** Divide una tarea en subtareas peque√±as que se ejecutan en paralelo (Map) y luego combina los resultados (Reduce) para obtener el resultado final.
    
-   **Conexi√≥n con la unidad:** Es muy √∫til cuando necesitamos procesar grandes vol√∫menes de datos y queremos distribuir ese trabajo de manera paralela, aprovechando al m√°ximo los recursos del sistema.
    

----------

### **Conexi√≥n General entre los Conceptos:**

1.  **Patrones de Dise√±o Concurrentes**  
    Los patrones "Pipeline", "Dataflow", "Productor-Consumidor" y "Map-Reduce" est√°n relacionados entre s√≠ porque todos abordan c√≥mo organizar y manejar tareas concurrentes para aprovechar mejor el paralelismo en la programaci√≥n.
    
2.  **Incremento del Paralelismo y Estructuras Concurrentes**  
    Incrementar el paralelismo con los patrones mencionados tambi√©n va de la mano con el uso de estructuras de datos concurrentes, como las colas concurrentes, que permiten un acceso eficiente a los datos de manera segura entre los hilos.
    
3.  **Reducci√≥n de Complejidad**  
    Usar estos patrones ayuda a reducir la complejidad del c√≥digo y hace que el procesamiento concurrente sea m√°s f√°cil de gestionar y escalar, especialmente cuando se trata de manejar grandes vol√∫menes de datos o realizar tareas simult√°neas.
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTM2MTM5MDQ5MF19
-->