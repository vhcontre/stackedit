# **üìå Unidad 3: Estructuras Paralelas y Paralelismo de Datos**

**Introducci√≥n:** En esta unidad vamos a explorar c√≥mo optimizar las tareas paralelas mediante el uso de estructuras especializadas, bucles paralelos y c√≥mo manejar de forma eficiente los datos en entornos concurrentes. Aprenderemos a manejar tareas paralelas con ciclos paralelos, c√≥mo interrumpirlos de manera controlada, gestionar excepciones, y c√≥mo lidiar con problemas de dependencias y reducci√≥n. Finalmente, profundizaremos en las colecciones concurrentes, vitales para manipular datos en aplicaciones multihilo.

----------

### **1. üåÄ Bucles Secuenciales en Tareas Paralelas**

**Explicaci√≥n:** Un **bucle secuencial** ejecuta cada iteraci√≥n uno tras otro. Sin embargo, al aplicar tareas paralelas, podemos dividir un bucle en varias tareas independientes que se ejecuten al mismo tiempo, mejorando as√≠ el rendimiento general.

**Ejemplo en C#:**

```csharp
using System;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        // Secuencial: Imprime los n√∫meros del 1 al 5
        for (int i = 1; i <= 5; i++)
        {
            Console.WriteLine($"N√∫mero secuencial: {i}");
        }

        Console.WriteLine("------------");

        // Paralelo: Ejecuta el mismo bucle en paralelo
        Parallel.For(1, 6, i =>
        {
            Console.WriteLine($"N√∫mero paralelo: {i}");
        });
    }
}

```

**Explicaci√≥n del C√≥digo:**

-   **Secuencial:** El primer bucle `for` imprime los n√∫meros del 1 al 5 uno tras otro.
    
-   **Paralelo:** El bucle `Parallel.For` ejecuta el mismo ciclo de manera paralela, con cada iteraci√≥n corriendo en un hilo separado.
    
----------


#### üåÄ**Bucles Secuenciales vs Paralelos en Tareas**

#### üí° Concepto Ampliado:

En la programaci√≥n tradicional, los bucles como `for`, `while` o `foreach` se ejecutan de manera **secuencial**, es decir, cada iteraci√≥n debe esperar a que la anterior termine. En cambio, usando t√©cnicas de **paralelismo**, como `Parallel.For`, podemos ejecutar varias iteraciones al mismo tiempo (cuando son independientes entre s√≠), aprovechando los n√∫cleos del procesador.

#### üõ† Ejemplo extendido en C#: Procesamiento de im√°genes

Supongamos que ten√©s que aplicar un filtro a una colecci√≥n de im√°genes:

```csharp
string[] imagenes = Directory.GetFiles("imagenes");

Parallel.ForEach(imagenes, imagen =>
{
    ProcesarImagen(imagen); // Aplica un filtro o redimensiona
});
```

‚úÖ Aqu√≠, cada imagen se procesa en paralelo, mejorando el rendimiento **en tareas de I/O o c√≥mputo intensivo**.

---

### üåê Aplicaciones Reales del Paralelismo en la Industria

| Sector                               | Uso t√≠pico del paralelismo                                             |
| ------------------------------------ | ---------------------------------------------------------------------- |
| **Finanzas**                         | C√°lculos simult√°neos de riesgo sobre m√∫ltiples carteras                |
| **Big Data**                         | An√°lisis concurrente de logs o eventos                                 |
| **Videojuegos**                      | Actualizaci√≥n de f√≠sicas, animaciones y l√≥gica en hilos separados      |
| **Inteligencia Artificial**          | Paralelismo en entrenamiento de modelos o preprocesamiento de datos    |
| **Procesamiento de im√°genes/videos** | Compresi√≥n, filtros y an√°lisis aplicados a m√∫ltiples archivos a la vez |
| **Aplicaciones web**                 | Manejo concurrente de solicitudes de usuarios                          |

---

### ‚ö†Ô∏è Consideraciones importantes

* **No todo puede paralelizarse**. Si una iteraci√≥n depende del resultado anterior, el paralelismo puede provocar errores.
* Usar `Parallel.For` es √∫til **cuando las tareas son independientes**, y no hay necesidad de sincronizaci√≥n entre ellas.
* Se debe monitorear el uso de recursos: paralelizar demasiado puede causar saturaci√≥n de CPU.

---

### üì¶ Alternativas modernas

Adem√°s de `Parallel.For`, existen otras formas m√°s robustas de paralelizar tareas:

* `Task.WhenAll()` ‚Üí Para ejecutar m√∫ltiples tareas asincr√≥nicas.
* **TPL Dataflow** ‚Üí Para flujos de trabajo m√°s complejos y en cadena.
* **PLINQ** ‚Üí Permite consultas LINQ paralelas: `source.AsParallel().Where(...)`

---------

### üîπ **PLINQ (Parallel LINQ)**

* Extiende LINQ con capacidades paralelas.
* Ideal para aplicar **operaciones sobre colecciones** (filtros, proyecciones, agrupaciones) usando m√∫ltiples n√∫cleos.
* Facilita el **paralelismo de datos estructurados** con muy poco c√≥digo adicional.

üìå *Ejemplo:*

```csharp
var resultados = datos.AsParallel()
                      .Where(x => x.Valor > 100)
                      .Select(x => Procesar(x));
```

---

### üîπ **TPL Dataflow**

* M√°s flexible y adecuado para **estructuras de procesamiento en cadena o pipelines**.
* Usa *bloques* como `TransformBlock` y `ActionBlock` que permiten configurar flujos as√≠ncronos y paralelos.
* Perfecto para escenarios donde se deben **encadenar etapas de procesamiento** (transformaciones, validaciones, almacenamiento, etc.).

üìå *Ejemplo b√°sico:*

```csharp
var bloque = new TransformBlock<int, int>(n => n * 2);
bloque.Post(5);
```

---

### ‚úÖ ¬øCu√°ndo usar cada uno?

| Caso                                               | PLINQ | TPL Dataflow |
| -------------------------------------------------- | ----- | ------------ |
| Procesamiento paralelo de colecciones inmutables   | ‚úîÔ∏è    |              |
| Flujos din√°micos de procesamiento con dependencias |       | ‚úîÔ∏è           |
| Simulaci√≥n de pipelines                            |       | ‚úîÔ∏è           |
| Filtrar, transformar y agrupar datos r√°pidamente   | ‚úîÔ∏è    |              |

<br />


## üß© Ejemplo de Escenario: Procesamiento de Pedidos

Supongamos que tenemos esta clase:

```csharp
class Pedido
{
    public int Id { get; set; }
    public decimal Monto { get; set; }
}
```

---

#### **1. Soluci√≥n con PLINQ (ideal para procesamiento en lote sin dependencias de estado)**

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

class Program
{
    static void Main()
    {
        var pedidos = new List<Pedido>
        {
            new() { Id = 1, Monto = 100 },
            new() { Id = 2, Monto = 250 },
            new() { Id = 3, Monto = 50 }
        };

        var procesados = pedidos
            .AsParallel()
            .Where(p => p.Monto > 0) // Validaci√≥n simple
            .Select(p => new
            {
                p.Id,
                TotalConImpuesto = p.Monto * 1.21m
            })
            .ToList();

        foreach (var r in procesados)
            Console.WriteLine($"Pedido {r.Id}: ${r.TotalConImpuesto}");
    }
}
```

#### üß† ¬øQu√© hace PLINQ aqu√≠?

* Divide la colecci√≥n en partes.
* Aplica validaci√≥n y transformaci√≥n **en paralelo**.
* Es ideal si las operaciones **no dependen entre s√≠**.

---

####  **2. Soluci√≥n con TPL Dataflow (ideal para flujos encadenados y din√°micos)**

```csharp
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.Threading.Tasks.Dataflow;

class Program
{
    static async Task Main()
    {
        var pedidos = new List<Pedido>
        {
            new() { Id = 1, Monto = 100 },
            new() { Id = 2, Monto = 250 },
            new() { Id = 3, Monto = -10 }
        };

        var validar = new TransformBlock<Pedido, Pedido>(p =>
        {
            if (p.Monto <= 0) return null!;
            return p;
        });

        var calcular = new TransformBlock<Pedido, (int id, decimal total)>(p =>
        {
            return (p.Id, p.Monto * 1.21m);
        });

        var registrar = new ActionBlock<(int id, decimal total)>(r =>
        {
            Console.WriteLine($"Pedido {r.id}: ${r.total}");
        });

        // Conectar bloques
        validar.LinkTo(calcular, new DataflowLinkOptions { PropagateCompletion = true }, p => p != null);
        calcular.LinkTo(registrar, new DataflowLinkOptions { PropagateCompletion = true });

        // Publicar pedidos
        foreach (var pedido in pedidos)
            await validar.SendAsync(pedido);

        validar.Complete();
        await registrar.Completion;
    }
}
```

#### üß† ¬øQu√© hace TPL Dataflow aqu√≠?

* Encadena bloques con l√≥gica diferente.
* Permite agregar condiciones, buffering, concurrencia personalizada.
* Ideal para flujos complejos y **procesamiento por etapas**.

---

#### üÜö Comparaci√≥n R√°pida

| Criterio                  | PLINQ                         | TPL Dataflow                       |
| ------------------------- | ----------------------------- | ---------------------------------- |
| Tipo de procesamiento     | Lote (colecciones completas)  | Flujo por etapas                   |
| Personalizaci√≥n por etapa | Limitada                      | Muy alta (por bloque)              |
| Control de concurrencia   | Autom√°tico                    | Configurable                       |
| Ideal para                | Consultas y filtros paralelos | Pipelines y procesamiento din√°mico |
| Facilidad de uso          | M√°s simple                    | M√°s flexible pero complejo         |

<br />

---

#### **Escenario 1: Procesamiento de Pagos (TPL Dataflow)**

### üéØ Caso real:

Una empresa recibe cientos de pagos por segundo. Cada uno debe:

1. Validarse (datos del cliente, tarjeta, etc.).
2. Autenticarse (con proveedor externo).
3. Confirmarse y registrarse.

#### Soluci√≥n con TPL Dataflow:

```csharp
var validarPago = new TransformBlock<Transaccion, Transaccion>(pago =>
{
    if (string.IsNullOrWhiteSpace(pago.MetodoPago)) return null!;
    return pago;
});

var autenticarPago = new TransformBlock<Transaccion, Transaccion>(pago =>
{
    // Simular autenticaci√≥n
    Task.Delay(100).Wait();
    return pago;
});

var confirmarPago = new ActionBlock<Transaccion>(pago =>
{
    Console.WriteLine($"Pago confirmado para {pago.ClienteId} por ${pago.Monto}");
});

// Pipeline
validarPago.LinkTo(autenticarPago, new DataflowLinkOptions { PropagateCompletion = true }, p => p != null);
autenticarPago.LinkTo(confirmarPago, new DataflowLinkOptions { PropagateCompletion = true });

// Env√≠o de pagos simulados
foreach (var pago in pagos) await validarPago.SendAsync(pago);
validarPago.Complete();
await confirmarPago.Completion;
```

#### Ventajas:

* Cada etapa se procesa de forma independiente y paralela.
* Permite manejar errores por bloque (por ejemplo, rechazar pagos inv√°lidos).
* Escalable: puedes agregar `BoundedCapacity` o `MaxDegreeOfParallelism`.

---

#### üì° **Escenario 2: Eventos de IoT (PLINQ)**

#### Caso real:

Un sistema de sensores env√≠a miles de lecturas por minuto (temperatura, humedad, presi√≥n).

#### Soluci√≥n con PLINQ:

```csharp
var lecturas = ObtenerLecturasDeSensores();

var lecturasProcesadas = lecturas
    .AsParallel()
    .Where(x => x.Valor > 0)
    .Select(x => new
    {
        x.SensorId,
        x.Tipo,
        ValorAjustado = x.Valor * ObtenerFactorDeCorreccion(x.Tipo)
    })
    .ToList();

foreach (var lectura in lecturasProcesadas)
    Console.WriteLine($"{lectura.SensorId}: {lectura.ValorAjustado}");
```

####  Ventajas:

* Ideal para filtrar, transformar y agrupar grandes vol√∫menes de datos r√°pidamente.
* Muy √∫til para an√°lisis en lote: no depende del orden de llegada.

---

## üÜö ¬øCu√°l usar y cu√°ndo?

| Situaci√≥n                                 | ¬øTPL Dataflow? | ¬øPLINQ? |
| ----------------------------------------- | -------------- | ------- |
| Procesamiento de pagos en tiempo real     | ‚úÖ S√≠           | ‚ùå No    |
| An√°lisis de sensores por lotes            | ‚ùå No           | ‚úÖ S√≠    |
| Flujo con m√∫ltiples etapas independientes | ‚úÖ S√≠           | ‚ùå No    |
| Consulta masiva sin l√≥gica por etapa      | ‚ùå No           | ‚úÖ S√≠    |

<br>

---


#### üåê Escenario Integrado: **Dashboard de IoT con Notificaciones y Base de Datos**

Imagina una **f√°brica inteligente** que recoge eventos de sensores (temperatura, humedad, vibraci√≥n). Cada evento debe:

1. Validarse y transformarse.
2. Guardarse en base de datos.
3. Disparar una notificaci√≥n si el valor excede un umbral.
4. Reflejarse en tiempo real en un dashboard.

---

### üîß Arquitectura T√©cnica

**üîπ Entrada de datos:** Simulaci√≥n o stream de sensores (por ejemplo, MQTT o un API).

**üîπ Pipeline con TPL Dataflow:**

* `TransformBlock`: Validar y ajustar los datos.
* `BroadcastBlock`: Dividir flujo a DB y notificaci√≥n.
* `ActionBlock`: Guardar en base de datos.
* `ActionBlock`: Emitir notificaci√≥n (por SignalR o WebSocket).

---

### üß± Ejemplo de implementaci√≥n (simplificado):

```csharp
var procesarEvento = new TransformBlock<EventoSensor, EventoSensor>(evento =>
{
    if (evento.Valor <= 0) return null!;
    evento.Valor *= 1.05; // Ajuste
    return evento;
});

var duplicarFlujo = new BroadcastBlock<EventoSensor>(evento => evento);

var guardarEnDb = new ActionBlock<EventoSensor>(async evento =>
{
    using var db = new SensorDbContext();
    db.Eventos.Add(evento);
    await db.SaveChangesAsync();
});

var notificar = new ActionBlock<EventoSensor>(evento =>
{
    if (evento.Valor > evento.Umbral)
    {
        NotificadorWebSocket.Enviar($"‚ö† Alerta: {evento.SensorId} = {evento.Valor}");
    }
});

// Enlazar bloques
procesarEvento.LinkTo(duplicarFlujo, p => p != null);
duplicarFlujo.LinkTo(guardarEnDb);
duplicarFlujo.LinkTo(notificar);

// Enviar datos simulados
foreach (var e in sensores) await procesarEvento.SendAsync(e);

procesarEvento.Complete();
await Task.WhenAll(guardarEnDb.Completion, notificar.Completion);
```

---

### üìä Visualizaci√≥n en tiempo real

En el frontend:

* Us√°s **SignalR** (ASP.NET Core) o **WebSocket** para recibir alertas en vivo.
* Mostrar en un gr√°fico con librer√≠as como **Chart.js** o **D3.js**.
* Consultas al historial usando LINQ o EF Core sobre la base de datos.

---

### üí° Extensi√≥n con PLINQ para an√°lisis:

Supongamos que quer√©s mostrar promedios por tipo de sensor en el dashboard:

```csharp
var resumen = db.Eventos
    .AsParallel()
    .GroupBy(e => e.Tipo)
    .Select(g => new
    {
        Tipo = g.Key,
        Promedio = g.Average(e => e.Valor)
    })
    .ToList();
```

Esto se usa, por ejemplo, para alimentar un gr√°fico de barras del dashboard.

----------

### **2. ‚öôÔ∏è Evaluaci√≥n de Performance**

**Explicaci√≥n:** Evaluar el rendimiento es fundamental para determinar si la programaci√≥n paralela realmente est√° proporcionando beneficios. En general, la programaci√≥n paralela deber√≠a hacer que la tarea se ejecute m√°s r√°pido. Sin embargo, tambi√©n hay que tener en cuenta el costo de crear y manejar hilos.

**Ejemplo en C#:**

```csharp
using System;
using System.Diagnostics;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        Stopwatch stopwatch = new Stopwatch();

        // Evaluaci√≥n de performance secuencial
        stopwatch.Start();
        for (int i = 0; i < 1000000; i++) { }
        stopwatch.Stop();
        Console.WriteLine($"Tiempo secuencial: {stopwatch.ElapsedMilliseconds} ms");

        // Evaluaci√≥n de performance paralelo
        stopwatch.Restart();
        Parallel.For(0, 1000000, i => { });
        stopwatch.Stop();
        Console.WriteLine($"Tiempo paralelo: {stopwatch.ElapsedMilliseconds} ms");
    }
}

```

**Explicaci√≥n del C√≥digo:**

-   Utilizamos un `Stopwatch` para medir el tiempo de ejecuci√≥n tanto de un bucle secuencial como paralelo.
    
-   Los resultados nos permitir√°n comparar los tiempos de ejecuci√≥n.
    

----------

### **3. üîÑ Ciclo `FOR` Paralelo**

**Explicaci√≥n:** El ciclo `Parallel.For` permite ejecutar iteraciones de un bucle de forma paralela, donde cada iteraci√≥n se ejecuta en un hilo diferente. Esto es √∫til para mejorar el rendimiento en tareas que no dependen entre s√≠.

**Ejemplo en C#:**

```csharp
using System;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        Parallel.For(1, 6, i =>
        {
            Console.WriteLine($"Iteraci√≥n {i} en el hilo {Task.CurrentId}");
        });
    }
}

```

**Explicaci√≥n del C√≥digo:**

-   Cada iteraci√≥n del ciclo `Parallel.For` se ejecuta de manera independiente en un hilo distinto, lo que permite mayor paralelismo y eficiencia.
    

----------

### **4. ‚è∏Ô∏è Interrupci√≥n de `FOR` Paralelo. Manejo de Excepciones**

**Explicaci√≥n:** Cuando trabajamos con ciclos paralelos, puede surgir la necesidad de interrumpir la ejecuci√≥n si se cumplen ciertas condiciones, o manejar excepciones para evitar fallos en el programa.

**Ejemplo en C#:**

```csharp
using System;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        try
        {
            Parallel.For(1, 6, (i, state) =>
            {
                if (i == 3)
                {
                    Console.WriteLine("Interrumpiendo el ciclo en la iteraci√≥n 3.");
                    state.Stop(); // Interrumpe el ciclo
                }
                Console.WriteLine($"Iteraci√≥n {i}");
            });
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

**Explicaci√≥n del C√≥digo:**

-   El ciclo `Parallel.For` se interrumpe en la tercera iteraci√≥n mediante el uso de `state.Stop()`.
    
-   Tambi√©n se incluye un bloque `try-catch` para manejar cualquier excepci√≥n que pueda ocurrir durante la ejecuci√≥n paralela.
    

----------

### **5. üîó Dependencias**

**Explicaci√≥n:** Las **dependencias** ocurren cuando una tarea depende de los resultados de otra tarea. En programaci√≥n paralela, debemos gestionar estas dependencias para evitar que un hilo intente acceder a datos que a√∫n no han sido calculados.

**Ejemplo en C#:**

```csharp
using System;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        int result = 0;

        Parallel.Invoke(
            () => { result += 5; },    // Tarea 1
            () => { result *= 2; }     // Tarea 2, depende de que la tarea 1 termine primero
        );

        Console.WriteLine($"Resultado final: {result}");
    }
}

```

**Explicaci√≥n del C√≥digo:**

-   En este ejemplo, el segundo c√°lculo depende del resultado del primero, por lo que el orden de ejecuci√≥n puede afectar el resultado final.
    

----------

### **6. ‚ûó Reducci√≥n**

**Explicaci√≥n:** La **reducci√≥n** es el proceso de combinar los resultados de las tareas paralelas en un √∫nico valor. Un ejemplo com√∫n es calcular la suma de un conjunto de n√∫meros.

**Ejemplo en C#:**

```csharp
using System;
using System.Linq;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        int[] numbers = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
        int sum = 0;

        Parallel.ForEach(numbers, number =>
        {
            sum += number; // Operaci√≥n de reducci√≥n
        });

        Console.WriteLine($"Suma de los n√∫meros: {sum}");
    }
}

```

**Explicaci√≥n del C√≥digo:**

-   En este ejemplo, usamos un ciclo `Parallel.ForEach` para sumar los elementos del array de manera paralela.
    

----------

### **7. üóÇÔ∏è Colecciones Concurrentes: Utilizaci√≥n y Manejo**

**Explicaci√≥n:** Las **colecciones concurrentes** son estructuras de datos dise√±adas para ser utilizadas por m√∫ltiples hilos simult√°neamente sin que se presenten problemas de consistencia. Son esenciales para evitar condiciones de carrera al manipular datos compartidos entre hilos.


####  **¬øQu√© son las Colecciones Concurrentes?**

Son estructuras de datos de .NET que permiten operaciones **simult√°neas desde m√∫ltiples hilos**, sin necesidad de aplicar manualmente bloqueos (`lock`). Est√°n dise√±adas para **evitar condiciones de carrera**, mejorar la **seguridad del hilo** (thread safety) y facilitar el desarrollo en escenarios **paralelos o asincr√≥nicos**.

#### **Ejemplo en C#**

```csharp
using System;
using System.Collections.Concurrent;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        var concurrentQueue = new ConcurrentQueue<int>();

        // Productores paralelos: agregan elementos a la cola
        Parallel.For(0, 10, i =>
        {
            concurrentQueue.Enqueue(i); // Inserta de manera segura
        });

        // Consumidor: extrae elementos de la cola
        while (!concurrentQueue.IsEmpty)
        {
            if (concurrentQueue.TryDequeue(out int item))
            {
                Console.WriteLine($"Elemento extra√≠do: {item}");
            }
        }
    }
}
```

---

#### **Explicaci√≥n Paso a Paso**

#### üß± `ConcurrentQueue<T>`

* Cola FIFO (First-In-First-Out) **segura para m√∫ltiples hilos**.
* Se encuentra en el espacio de nombres `System.Collections.Concurrent`.

#### üßµ `Parallel.For(0, 10, ...)`

* Lanza m√∫ltiples tareas en paralelo.
* Cada iteraci√≥n representa un **productor** que agrega un n√∫mero a la cola concurrente.

#### üì• `Enqueue(i)`

* Agrega el n√∫mero `i` de forma **at√≥mica** y **segura** a la cola, sin bloquear el acceso a otros hilos.

#### üì§ `TryDequeue(out int item)`

* Extrae de manera segura el primer elemento.
* Devuelve `false` si la cola est√° vac√≠a, evitando excepciones.
* **Patr√≥n recomendado** cuando varios consumidores podr√≠an estar accediendo simult√°neamente.

---

#### **Ventajas del Uso de Colecciones Concurrentes**

| Ventaja            | Detalle                                                           |
| ------------------ | ----------------------------------------------------------------- |
| ‚úÖ Thread-safe      | Evitan bloqueos (`lock`) manuales en escenarios multihilo.        |
| ‚úÖ Escalabilidad    | Soportan m√∫ltiples productores y consumidores.                    |
| ‚úÖ Rendimiento      | Optimizadas internamente para minimizar contenci√≥n entre hilos.   |
| ‚úÖ Facilidad de uso | API intuitiva: `Enqueue`, `TryDequeue`, `TryAdd`, `TryTake`, etc. |

---

#### **Aplicaciones Reales**

1. **Procesamiento de Eventos (IoT, Finanzas)**: Donde m√∫ltiples sensores o servicios generan eventos que se encolan para su an√°lisis.
2. **Cola de Tareas As√≠ncronas**: Implementar un patr√≥n **productor-consumidor** seguro sin necesidad de infraestructura externa.
3. **Crawlers / Scrapers**: Donde varios hilos agregan URLs descubiertas a una cola central.
4. **Sistemas de Mensajer√≠a Interna**: Buffer temporal de mensajes antes de ser entregados.

---

#### **Otras Colecciones Concurrentes en .NET**

| Tipo                        | Descripci√≥n                                                            |
| --------------------------- | ---------------------------------------------------------------------- |
| `ConcurrentQueue<T>`        | Cola FIFO.                                                             |
| `ConcurrentStack<T>`        | Pila LIFO.                                                             |
| `ConcurrentBag<T>`          | Bolsa (sin orden espec√≠fico).                                          |
| `ConcurrentDictionary<K,V>` | Diccionario clave-valor seguro para concurrencia.                      |
| `BlockingCollection<T>`     | Wrapper que permite bloqueo y espera (√∫til para productor-consumidor). |

---

#### Consejo para Producci√≥n

> En entornos de alta concurrencia, las **colecciones concurrentes son preferibles a `List<T>` o `Dictionary<K,V>`**, ya que eliminan la necesidad de sincronizaci√≥n manual y reducen errores por condiciones de carrera.

----------

#### **Sistema de eventos en tiempo real**, usando:

* `BlockingCollection<T>` como **buffer seguro**.
* Un **productor** que simula llegada de eventos (por ejemplo, de sensores o pagos).
* Un **consumidor** que procesa estos eventos de forma **diferida/as√≠ncrona**.
* Soporte para **cancelaci√≥n** y control del flujo.

---

#### Escenario: Buffer de Eventos en Tiempo Real

Imagina una aplicaci√≥n que recibe **eventos IoT** (como temperatura o alertas) y debe procesarlos uno por uno, sin perder datos.

#### C√≥digo completo en C\#

```csharp
// Este programa implementa un sistema de procesamiento de eventos utilizando
// una colecci√≥n bloqueante (BlockingCollection) para manejar la comunicaci√≥n
// entre un productor y un consumidor. El productor genera eventos simulados
// y los coloca en un b√∫fer, mientras que el consumidor procesa estos eventos
// de manera as√≠ncrona. Se utiliza un token de cancelaci√≥n para controlar
// la finalizaci√≥n del procesamiento.

// Dependencias necesarias
using System.Collections.Concurrent;

namespace MiProyecto;

static class Program
{
    // B√∫fer de eventos con capacidad limitada
    static BlockingCollection<string> eventBuffer = new(boundedCapacity: 10);
    // Fuente de token de cancelaci√≥n
    static readonly CancellationTokenSource cts = new();

    static async Task Main(string[] args)
    {
        Console.WriteLine("Iniciando sistema...");

        // Lanzar tarea del consumidor
        var consumerTask = Task.Run(() => ConsumeEvents(cts.Token));

        // Generar eventos simulados (productor)
        for (int i = 1; i <= 20; i++)
        {
            string simulatedEvent = $"Evento #{i} recibido a las {DateTime.Now:HH:mm:ss}";
            eventBuffer.Add(simulatedEvent); // Agregar evento al b√∫fer
            Console.WriteLine($"Producido: {simulatedEvent}");
            await Task.Delay(300); // Simular intervalo de llegada de eventos
        }

        // Finalizar el flujo de eventos
        eventBuffer.CompleteAdding(); // Indicar que no se agregar√°n m√°s eventos
        cts.CancelAfter(5000); // Cancelar el consumidor despu√©s de 5 segundos

        // Esperar a que el consumidor termine
        await consumerTask;

        Console.WriteLine("Procesamiento finalizado.");
    }

    // M√©todo que consume y procesa los eventos
    static void ConsumeEvents(CancellationToken token)
    {
        try
        {
            // Procesar eventos del b√∫fer mientras est√©n disponibles
            foreach (var evt in eventBuffer.GetConsumingEnumerable(token))
            {
                Console.WriteLine($"Procesando: {evt}");
                Thread.Sleep(1000); // Simular procesamiento lento
            }
        }
        catch (OperationCanceledException)
        {
            // Manejar cancelaci√≥n del procesamiento
            Console.WriteLine("Procesamiento cancelado.");
        }
    }
}
```

---

#### Explicaci√≥n del C√≥digo

| Componente                   | Funci√≥n                                                               |
| ---------------------------- | --------------------------------------------------------------------- |
| `BlockingCollection<string>` | Buffer seguro en memoria, con capacidad limitada (10).                |
| `Add(evento)`                | Agrega evento al buffer de forma segura (espera si est√° lleno).       |
| `GetConsumingEnumerable()`   | Permite consumir eventos **bloqueando el hilo** hasta que haya datos. |
| `CompleteAdding()`           | Se√±ala que ya no se producir√°n m√°s eventos.                           |
| `CancellationTokenSource`    | Permite **detener el consumidor** cuando ya no se necesita.           |

---

#### üìà Aplicaciones Reales

* **Sistemas de colas** para procesar datos en background (p. ej., pagos, registros).
* **Procesadores de mensajes** desde sensores o brokers (IoT, Kafka, Azure Event Hub).
* **Procesamiento por lotes** o agregaciones en buffers antes de persistencia.


----------

## **üîö Cierre y Resumen**

En esta unidad, hemos aprendido sobre los bucles paralelos, c√≥mo medir y evaluar el rendimiento, la interrupci√≥n de ciclos paralelos, el manejo de excepciones, dependencias, reducci√≥n, y el uso de colecciones concurrentes. Todos estos conceptos son esenciales para escribir programas paralelos que sean eficientes, seguros y escalables.

¬°Ahora es el momento de practicar! Con los ejemplos proporcionados y las explicaciones, tienes una base s√≥lida para empezar a implementar programaci√≥n paralela en tus proyectos.

----------

### **üåê Mapa Conceptual de la Unidad 3: Estructuras Paralelas y Paralelismo de Datos**

```
                   +-------------------------------+
                   |     Estructuras Paralelas      |
                   |              üåç               |
                   +-------------------------------+
                            |
        +-------------------+-------------------+
        |                                       |
  +-------------+                         +-----------------+
  | Bucles      |                         | Evaluaci√≥n de   |
  | Secuenciales|                         | Performance      |
  | en Tareas   |                         |   üìä            |
  | Paralelas   |                         +-----------------+
  +-------------+                                 |
        |                                       |
  +-------------+                         +-----------------+
  | Ciclo `FOR` |                         | Interrupci√≥n de  |
  | Paralelo    |                         | `FOR` Paralelo   |
  | üîÑ          |                         | ‚èπÔ∏è              |
  +-------------+                         +-----------------+
        |                                       |
  +-------------+                         +-----------------+
  | Dependencias |                         | Reducci√≥n       |
  | üîó           |                         | ‚ûï               |
  +-------------+                         +-----------------+
                            |
        +-------------------+-------------------+
        |                                       |
  +--------------------+                +------------------------+
  | Colecciones        |                | Mecanismos de          |
  | Concurrentes       |                | Sincronizaci√≥n        |
  | üìö                 |                | entre Hilos           |
  +--------------------+                +------------------------+

```

----------

### **Explicaci√≥n del Mapa Conceptual con Emoticones:**

1.  **Estructuras Paralelas üåç**: Aqu√≠ se encuentra el concepto central, que abarca todos los temas relacionados con las estructuras que permiten ejecutar tareas de manera paralela y concurrente.
    
2.  **Bucles Secuenciales en Tareas Paralelas üîÑ**: Compara c√≥mo se ejecutan los bucles de manera secuencial versus de forma paralela.
    
3.  **Evaluaci√≥n de Performance üìä**: Este concepto aborda c√≥mo medir el rendimiento de las tareas paralelas en comparaci√≥n con las secuenciales.
    
4.  **Ciclo `FOR` Paralelo üîÑ**: Aprende c√≥mo utilizar el ciclo `Parallel.For` para ejecutar las iteraciones de manera paralela.
    
5.  **Interrupci√≥n de `FOR` Paralelo ‚èπÔ∏è**: Controla la ejecuci√≥n de ciclos paralelos, permitiendo interrumpir o manejar excepciones dentro de un ciclo paralelo.
    
6.  **Dependencias üîó**: Analiza c√≥mo las tareas paralelas pueden depender unas de otras para poder ejecutarse correctamente.
    
7.  **Reducci√≥n ‚ûï**: Trata de c√≥mo combinar los resultados de varias tareas paralelas en un solo valor, como la suma de un conjunto de elementos.
    
8.  **Colecciones Concurrentes üìö**: Son estructuras de datos dise√±adas para ser manipuladas de manera segura y eficiente por m√∫ltiples hilos en paralelo.
    
9.  **Mecanismos de Sincronizaci√≥n entre Hilos üîí**: Aborda c√≥mo controlar el acceso a recursos compartidos cuando se ejecutan m√∫ltiples hilos concurrentemente.
    

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEwNTc0Njg2MDZdfQ==
-->