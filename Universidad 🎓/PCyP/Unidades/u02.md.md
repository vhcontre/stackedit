# **üìåUnidad 2: Primitivas de Sincronizaci√≥n y el Modelo de Programaci√≥n**

## **üîπ 1. Comunicaci√≥n S√≠ncrona**

**Definici√≥n:** La **comunicaci√≥n s√≠ncrona** implica que un hilo debe esperar hasta que otro hilo haya terminado su tarea antes de continuar. En otras palabras, los hilos se sincronizan y se bloquean esperando a que otro hilo termine su ejecuci√≥n.

**Ejemplo en C#:**

Imagina un escenario donde un hilo necesita recibir datos de otro antes de continuar:

```csharp
// Este programa demuestra el uso de hilos en C#.
// Se crea un hilo secundario que ejecuta la funci√≥n Tarea1,
// mientras que el hilo principal espera a que termine el hilo secundario
// antes de continuar con su ejecuci√≥n.

using System;
using System.Threading;

class Program
{
    static void Main()
    {
        // Crear un nuevo hilo que ejecutar√° el m√©todo Tarea1.
        Thread t1 = new(Tarea1);
        t1.Start(); // Iniciar el hilo.
        t1.Join();  // Esperar a que el hilo t1 termine.

        // Mensaje del hilo principal despu√©s de que Tarea1 haya finalizado.
        Console.WriteLine("Hilo principal despu√©s de Tarea1.");
    }

    static void Tarea1()
    {
        // C√≥digo que se ejecuta en el hilo secundario.
        Console.WriteLine("Tarea1 est√° ejecut√°ndose...");
        Thread.Sleep(1000); // Simular un trabajo con una pausa de 1 segundo.
        Console.WriteLine("Tarea1 termin√≥.");
    }
}

```

En este caso, el hilo principal espera a que `Tarea1` termine antes de continuar, demostrando una ejecuci√≥n s√≠ncrona.

<br/>

## **üîπ 2. Invocaci√≥n Remota de Procedimientos**

**Definici√≥n:** La **invocaci√≥n remota de procedimientos** (RPC - Remote Procedure Call) es el proceso en el que un programa ejecuta una funci√≥n o procedimiento en otro espacio de direcciones, t√≠picamente en una m√°quina diferente, y espera una respuesta.

**Ejemplo en C#:**

Aunque en un entorno real de RPC se utilizan bibliotecas como WCF o gRPC, aqu√≠ te doy una idea de c√≥mo funcionar√≠a una invocaci√≥n remota simplificada:

```csharp
using System;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        string resultado = await InvocarProcedimientoRemoto();
        Console.WriteLine($"Resultado de invocaci√≥n remota: {resultado}");
    }

    static async Task<string> InvocarProcedimientoRemoto()
    {
        await Task.Delay(1000);  // Simula tiempo de espera en red
        return "Respuesta del servidor remoto";
    }
}

```

 üîπ ¬øQu√© hace el programa en general?

Este programa simula una **invocaci√≥n a un procedimiento remoto**, como si estuviera llamando a un servidor a trav√©s de la red. Lo hace de forma **as√≠ncrona**, utilizando `async` y `await`, y luego muestra la respuesta en la consola.

----------

 üîπ An√°lisis l√≠nea por l√≠nea

```csharp
using System;
using System.Threading.Tasks;

```

-   **`using System;`** importa funcionalidades b√°sicas como entrada/salida (por ejemplo, `Console.WriteLine`).
    
-   **`using System.Threading.Tasks;`** permite usar **tareas as√≠ncronas**, como `Task`, `async`, y `await`.
    

----------

```csharp
class Program
{

```

Define una clase llamada `Program`, que es la entrada principal del programa.

----------

```csharp
    static async Task Main()

```

-   Este es el **punto de entrada** del programa.
    
-   La palabra clave `async` indica que este m√©todo ejecuta **c√≥digo as√≠ncrono**.
    
-   `Task` es el tipo de retorno usado para m√©todos as√≠ncronos que no devuelven un valor espec√≠fico (a diferencia de `Task<T>`).
    
-   Desde C# 7.1, se permite que `Main` sea `async`.
    

----------

```csharp
        string resultado = await InvocarProcedimientoRemoto();

```

-   Llama al m√©todo `InvocarProcedimientoRemoto()` y **espera su resultado** (usa `await`).
    
-   La ejecuci√≥n del m√©todo `Main` se **suspende** hasta que la tarea finaliza.
    
-   El valor de retorno (un string) se guarda en la variable `resultado`.
    

----------

```csharp
        Console.WriteLine($"Resultado de invocaci√≥n remota: {resultado}");

```

-   Imprime el resultado en consola, usando **interpolaci√≥n de cadenas** (`$""`).
    

----------

```csharp
    static async Task<string> InvocarProcedimientoRemoto()

```

-   Define un m√©todo as√≠ncrono que retorna un `Task<string>` (una tarea que eventualmente entrega un `string`).
    
-   Simula un llamado a un servidor remoto.
    

----------

```csharp
        await Task.Delay(1000);  // Simula tiempo de espera en red

```

-   Espera 1 segundo (1000 ms) de manera **no bloqueante**.
    
-   Esto representa un **tiempo de respuesta de red simulado** (como si esperara una respuesta del servidor).
    

----------

```csharp
        return "Respuesta del servidor remoto";

```

-   Devuelve una cadena fija, simulando una respuesta desde el servidor.
    

----------

 üß† ¬øQu√© aprendimos?

-   C√≥mo usar `async` y `await` en C#.
    
-   C√≥mo simular operaciones as√≠ncronas como llamadas a servidores.
    
-   C√≥mo escribir un m√©todo `Main` as√≠ncrono en una aplicaci√≥n de consola.
    

----------

 üß™ Resultado en consola

Despu√©s de 1 segundo de espera, el programa imprime:

```
Resultado de invocaci√≥n remota: Respuesta del servidor remoto

```
<br/>

> Lanzaremos varios procedimientos remotos en paralelo y simularemos un error en el servidor. Procedemos a detallar el programa a continuaci√≥n:

<br/>

 ‚úÖ 1. **Varios procedimientos remotos en paralelo**

Usaremos `Task.WhenAll` para lanzar varias tareas al mismo tiempo y esperar sus respuestas.

```csharp
using System;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        // Lanzar 3 invocaciones remotas en paralelo
        Task<string> t1 = InvocarProcedimientoRemoto("Servidor A", 1000);
        Task<string> t2 = InvocarProcedimientoRemoto("Servidor B", 1500);
        Task<string> t3 = InvocarProcedimientoRemoto("Servidor C", 500);

        string[] resultados = await Task.WhenAll(t1, t2, t3);

        for (int i = 0; i < resultados.Length; i++)
        {
            Console.WriteLine($"Resultado {i + 1}: {resultados[i]}");
        }
    }

    static async Task<string> InvocarProcedimientoRemoto(string nombreServidor, int delay)
    {
        await Task.Delay(delay);
        return $"Respuesta de {nombreServidor} despu√©s de {delay} ms";
    }
}

```

 üîç **¬øQu√© hace este c√≥digo?**

-   Lanza 3 tareas **en paralelo**.
    
-   Cada tarea espera un tiempo distinto (simulando servidores con diferentes velocidades).
    
-   Usa `Task.WhenAll` para esperar a que **todas terminen**.
    
-   Luego imprime los resultados.
    

----------

 ‚ùå 2. **Simular un error del servidor**

Usamos `try-catch` para manejar errores simulados. Aqu√≠ una de las tareas lanza una excepci√≥n.

```csharp
using System;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        try
        {
            string resultado = await InvocarProcedimientoRemoto("Servidor X", 1000, true);
            Console.WriteLine($"Resultado exitoso: {resultado}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"¬°Error durante la invocaci√≥n remota! Detalles: {ex.Message}");
        }
    }

    static async Task<string> InvocarProcedimientoRemoto(string nombreServidor, int delay, bool lanzarError)
    {
        await Task.Delay(delay);

        if (lanzarError)
        {
            throw new Exception($"Error al contactar a {nombreServidor}");
        }

        return $"Respuesta de {nombreServidor}";
    }
}

```

 üîç **¬øQu√© pasa aqu√≠?**

-   Simula un servidor que **lanza un error** despu√©s de un delay.
    
-   El `try-catch` en `Main` captura la excepci√≥n y muestra un mensaje de error.
    

<br/>

>Lanzar **m√∫ltiples invocaciones remotas en paralelo**, manejar **errores individualmente**, y c√≥mo mostrar los resultados de cada una, ya sea √©xito o fallo.

<br/>

üéì **Explicaci√≥n paso a paso**

üß© ¬øQu√© aprenderemos aqu√≠?

1.  C√≥mo **ejecutar m√∫ltiples tareas as√≠ncronas en paralelo**.
    
2.  C√≥mo **manejar errores en tareas individuales sin detener todo el programa**.
    
3.  C√≥mo mostrar los **resultados exitosos** y los **errores capturados** uno por uno.
    

----------

üíª C√≥digo explicado

```csharp
using System;
using System.Threading.Tasks;
using System.Collections.Generic;

class Program
{
    // Punto de entrada del programa
    static async Task Main()
    {
        // Lista de nombres de servidores para simular m√∫ltiples llamadas
        var servidores = new List<(string nombre, int delay, bool falla)>
        {
            ("Servidor A", 1000, false), // Este responde bien
            ("Servidor B", 1500, true),  // Este lanza un error
            ("Servidor C", 700, false),  // Este responde bien
            ("Servidor D", 1200, true),  // Este lanza un error
            ("Servidor E", 900, false),  // Este responde bien
        };

        // Lista para guardar todas las tareas en paralelo
        var tareas = new List<Task<ResultadoRemoto>>();

        // Iniciar cada tarea asincr√≥nica
        foreach (var servidor in servidores)
        {
            tareas.Add(InvocarProcedimientoRemotoSeguro(servidor.nombre, servidor.delay, servidor.falla));
        }

        // Esperamos a que todas las tareas finalicen
        ResultadoRemoto[] resultados = await Task.WhenAll(tareas);

        // Mostramos los resultados, diferenciando √©xito y error
        Console.WriteLine("\n=== RESULTADOS ===");
        foreach (var resultado in resultados)
        {
            if (resultado.Exitoso)
            {
                Console.WriteLine($"{resultado.Servidor}: {resultado.Mensaje}");
            }
            else
            {
                Console.WriteLine($"{resultado.Servidor}: Error -> {resultado.Mensaje}");
            }
        }
    }

    /// <summary>
    /// Estructura que representa el resultado de una invocaci√≥n remota.
    /// Puede ser exitoso o contener un error.
    /// </summary>
    class ResultadoRemoto
    {
        public string Servidor { get; set; }
        public bool Exitoso { get; set; }
        public string Mensaje { get; set; }
    }

    /// <summary>
    /// Invoca un procedimiento remoto simulado, y captura errores si ocurren.
    /// Siempre devuelve un ResultadoRemoto, exitoso o no.
    /// </summary>
    static async Task<ResultadoRemoto> InvocarProcedimientoRemotoSeguro(string nombreServidor, int delay, bool debeFallar)
    {
        try
        {
            // Simula un retardo (como tiempo de red)
            await Task.Delay(delay);

            // Si debe fallar, lanzamos una excepci√≥n
            if (debeFallar)
                throw new Exception("No se pudo establecer conexi√≥n");

            // Si no falla, se devuelve una respuesta exitosa
            return new ResultadoRemoto
            {
                Servidor = nombreServidor,
                Exitoso = true,
                Mensaje = $"Respuesta recibida despu√©s de {delay} ms"
            };
        }
        catch (Exception ex)
        {
            // En caso de error, devolvemos un resultado con la informaci√≥n del fallo
            return new ResultadoRemoto
            {
                Servidor = nombreServidor,
                Exitoso = false,
                Mensaje = ex.Message
            };
        }
    }
}

```

----------

üìå Resultado esperado en consola

```text
=== RESULTADOS ===
‚úÖ Servidor A: Respuesta recibida despu√©s de 1000 ms
‚ùå Servidor B: Error -> No se pudo establecer conexi√≥n
‚úÖ Servidor C: Respuesta recibida despu√©s de 700 ms
‚ùå Servidor D: Error -> No se pudo establecer conexi√≥n
‚úÖ Servidor E: Respuesta recibida despu√©s de 900 ms

```

----------

‚úÖ Ventajas de este enfoque

-   **No se cae todo el sistema si un servidor falla**: cada error es controlado.
    
-   **Resultados parciales √∫tiles**: aunque algunas tareas fallen, seguimos obteniendo lo que s√≠ funcion√≥.
    
-   **Escalabilidad**: puedes agregar m√°s servidores o llamadas sin cambiar la estructura.
    

<br/>

>Vamos a implementar una mejora realista y muy √∫til: **reintentar autom√°ticamente** cuando un servidor falla. Esto es algo com√∫n en redes inestables o APIs poco confiables.

<br/>

üéØ **Objetivo**

-   Si una llamada remota falla, **reintentar hasta 3 veces** (con un peque√±o retraso entre intentos).
    
-   Si falla las 3 veces, se considera error definitivo.
    
-   Todo debe seguir siendo **as√≠ncrono, limpio y claro**.
    

----------

üßë‚Äçüè´ Explicaci√≥n de la l√≥gica de reintentos

üîÅ ¬øC√≥mo funciona un reintento?

1.  Se intenta ejecutar una acci√≥n.
    
2.  Si falla (lanza excepci√≥n), se espera un poco y se intenta de nuevo.
    
3.  Esto se repite hasta que se logre o se alcance el **n√∫mero m√°ximo de intentos**.
    

----------

üíª C√≥digo completo con reintentos autom√°ticos

```csharp
using System;
using System.Threading.Tasks;
using System.Collections.Generic;

class Program
{
    static async Task Main()
    {
        var servidores = new List<(string nombre, int delay, bool falla)>
        {
            ("Servidor A", 1000, false),
            ("Servidor B", 1500, true),
            ("Servidor C", 700, false),
            ("Servidor D", 1200, true),
            ("Servidor E", 900, false),
        };

        var tareas = new List<Task<ResultadoRemoto>>();

        foreach (var servidor in servidores)
        {
            // Se intenta con 3 reintentos (m√°x)
            tareas.Add(InvocarConReintentos(servidor.nombre, servidor.delay, servidor.falla, maxIntentos: 3));
        }

        ResultadoRemoto[] resultados = await Task.WhenAll(tareas);

        Console.WriteLine("\n=== RESULTADOS ===");
        foreach (var resultado in resultados)
        {
            if (resultado.Exitoso)
                Console.WriteLine($"{resultado.Servidor}: {resultado.Mensaje}");
            else
                Console.WriteLine($"{resultado.Servidor}: Error tras {resultado.Intentos} intentos -> {resultado.Mensaje}");
        }
    }

    /// <summary>
    /// Resultado de una invocaci√≥n remota, exitosa o fallida.
    /// </summary>
    class ResultadoRemoto
    {
        public string Servidor { get; set; }
        public bool Exitoso { get; set; }
        public int Intentos { get; set; }
        public string Mensaje { get; set; }
    }

    /// <summary>
    /// Invoca un procedimiento remoto con l√≥gica de reintentos en caso de fallo.
    /// </summary>
    static async Task<ResultadoRemoto> InvocarConReintentos(string nombreServidor, int delay, bool debeFallar, int maxIntentos)
    {
        int intento = 0;

        while (intento < maxIntentos)
        {
            intento++;

            try
            {
                await Task.Delay(delay);

                if (debeFallar && intento < maxIntentos)
                    throw new Exception("Simulando fallo");  // Falla solo si no es el √∫ltimo intento

                return new ResultadoRemoto
                {
                    Servidor = nombreServidor,
                    Exitoso = true,
                    Intentos = intento,
                    Mensaje = $"Respuesta exitosa despu√©s de {delay} ms (intento {intento})"
                };
            }
            catch (Exception ex)
            {
                // Si es el √∫ltimo intento, devolvemos el error
                if (intento == maxIntentos)
                {
                    return new ResultadoRemoto
                    {
                        Servidor = nombreServidor,
                        Exitoso = false,
                        Intentos = intento,
                        Mensaje = ex.Message
                    };
                }

                // Peque√±o retraso antes de reintentar
                await Task.Delay(500);
            }
        }

        // Esta parte nunca deber√≠a alcanzarse, pero es un fallback por seguridad
        return new ResultadoRemoto
        {
            Servidor = nombreServidor,
            Exitoso = false,
            Intentos = intento,
            Mensaje = "Error desconocido"
        };
    }
}

```

----------

üß™ Ejemplo de salida

```text
=== RESULTADOS ===
‚úÖ Servidor A: Respuesta exitosa despu√©s de 1000 ms (intento 1)
‚ùå Servidor B: Error tras 3 intentos -> Simulando fallo
‚úÖ Servidor C: Respuesta exitosa despu√©s de 700 ms (intento 1)
‚ùå Servidor D: Error tras 3 intentos -> Simulando fallo
‚úÖ Servidor E: Respuesta exitosa despu√©s de 900 ms (intento 1)

```

----------

üß† ¬øQu√© aprendimos?

-   C√≥mo manejar **reintentos autom√°ticos** en llamadas remotas.
    
-   C√≥mo controlar los **intentos fallidos sin frenar toda la ejecuci√≥n**.
    
-   C√≥mo aplicar **patrones robustos y tolerantes a fallos** en sistemas distribuidos.
    
<br/>

## **üîπ 3. Sem√°foros**

**Definici√≥n:** Un **sem√°foro** es una variable que se utiliza para controlar el acceso a recursos compartidos entre varios hilos. Puede tener un valor binario (0 o 1) o m√∫ltiple (cuando varios hilos pueden acceder al recurso al mismo tiempo).

‚úÖ **C√≥digo** ‚Äì Control de concurrencia con `Semaphore`

```csharp
using System;
using System.Threading;

class Program
{
    // Declaramos un sem√°foro que permite el acceso a un solo hilo al mismo tiempo.
    // Primer par√°metro (initialCount): n√∫mero de permisos disponibles inicialmente.
    // Segundo par√°metro (maximumCount): n√∫mero m√°ximo de permisos permitidos.
    static Semaphore semaforo = new Semaphore(1, 1);

    static void Main()
    {
        // Creamos dos hilos que intentar√°n acceder al recurso compartido
        Thread t1 = new Thread(AccederRecurso);
        Thread t2 = new Thread(AccederRecurso);

        // Iniciamos ambos hilos. Solo uno podr√° entrar a la vez al recurso.
        t1.Start();
        t2.Start();
    }

    /// <summary>
    /// M√©todo que simula el acceso a un recurso compartido controlado por un sem√°foro.
    /// </summary>
    static void AccederRecurso()
    {
        // Espera hasta que el sem√°foro est√© disponible. Esto bloquea el hilo si otro ya est√° dentro.
        semaforo.WaitOne();

        // Desde aqu√≠, el hilo tiene acceso exclusivo al recurso.
        Console.WriteLine($"{Thread.CurrentThread.ManagedThreadId} accediendo al recurso...");

        // Simula una operaci√≥n que toma tiempo (por ejemplo, escribir en un archivo, acceso a base de datos, etc.)
        Thread.Sleep(1000);

        // Libera el sem√°foro, permitiendo que otro hilo pueda entrar.
        semaforo.Release();

        // Informa que el hilo ha terminado su trabajo.
        Console.WriteLine($"{Thread.CurrentThread.ManagedThreadId} termin√≥ su tarea.");
    }
}


```

 üß† **¬øQu√© aprendimos?**

-   **Semaphore (Sem√°foro)**: mecanismo de sincronizaci√≥n que limita el n√∫mero de hilos que pueden acceder simult√°neamente a una secci√≥n cr√≠tica.
    
-   **Acceso exclusivo (mutua exclusi√≥n)**: como el sem√°foro tiene capacidad 1, s√≥lo un hilo puede entrar a la vez. Es similar a un `Mutex`.
    
-   **Uso de hilos** (`Thread`): se crean y ejecutan dos tareas en paralelo.
    
-   **`Thread.Sleep`**: simula una tarea que toma tiempo.
    
- En este caso, un sem√°foro garantiza que solo un hilo pueda acceder al recurso al mismo tiempo.
----------

üõ†Ô∏è **Casos de uso reales**

-   Control de acceso a recursos como archivos, bases de datos, sockets.
    
-   Limitar concurrencia a un n√∫mero m√°ximo de usuarios.
    
-   Simulaci√≥n de sistemas donde m√∫ltiples procesos compiten por un recurso escaso.
<br>    

> Vamos a construir un escenario m√°s realista, **totalmente documentado**, usando un `Semaphore` para controlar el acceso **concurrente de m√∫ltiples hilos** a un recurso compartido con **capacidad limitada**.

---

üß† **Escenario pr√°ctico: ‚ÄúCajeros en un banco‚Äù**

Imagin√° que ten√©s un banco con **3 cajeros disponibles**. Varias personas (clientes) llegan y quieren ser atendidas.  
Solo pueden ser atendidas 3 personas al mismo tiempo. Si llegan m√°s, tienen que esperar a que un cajero quede libre.

Usaremos un `Semaphore` con capacidad de 3 para simular esta situaci√≥n.

----------

üíª C√≥digo

```csharp
using System;
using System.Threading;

class Program
{
    // El sem√°foro permite hasta 3 accesos simult√°neos (simulando 3 cajeros disponibles)
    static Semaphore cajeros = new Semaphore(3, 3);

    static void Main()
    {
        // Creamos 10 clientes (hilos) que intentar√°n ser atendidos
        for (int i = 1; i <= 10; i++)
        {
            int clienteId = i;  // Necesario para evitar problemas con variables capturadas
            Thread cliente = new Thread(() => AtenderCliente(clienteId));
            cliente.Start();
        }
    }

    /// <summary>
    /// Simula a un cliente intentando acceder a un cajero del banco.
    /// </summary>
    /// <param name="id">Identificador del cliente</param>
    static void AtenderCliente(int id)
    {
        Console.WriteLine($"Cliente {id} est√° esperando un cajero...");

        // Espera a que haya un cajero disponible (se adquiere un permiso del sem√°foro)
        cajeros.WaitOne();

        Console.WriteLine($"Cliente {id} est√° siendo atendido (por un cajero disponible)");

        // Simula el tiempo de atenci√≥n (ej: transacci√≥n bancaria)
        Thread.Sleep(new Random().Next(1000, 3000));

        Console.WriteLine($"Cliente {id} termin√≥ y deja el cajero libre");

        // Libera el permiso, permitiendo que otro cliente acceda
        cajeros.Release();
    }
}

```

----------

üîç **¬øQu√© estamos simulando aqu√≠?**

Este programa usa un `Semaphore` para simular una situaci√≥n donde m√∫ltiples clientes (hilos) intentan acceder a un recurso limitado (cajeros del banco). Solo un n√∫mero limitado de clientes puede ser atendido a la vez. El resto debe esperar su turno.

| Elemento del mundo real | Representaci√≥n en c√≥digo      | Descripci√≥n                                                                          |
|-------------------------|-------------------------------|--------------------------------------------------------------------------------------|
| Cajeros                 | `Semaphore(3, 3)`             | Controla el n√∫mero m√°ximo de clientes que pueden ser atendidos simult√°neamente.     |
| Clientes                | `Thread`                      | Cada hilo simula a un cliente que espera para ser atendido.                         |
| Atenci√≥n al cliente     | `Thread.Sleep()`              | Simula el tiempo que un cajero tarda en atender a un cliente.                       |
| Cola de espera          | `semaforo.WaitOne()`          | Si todos los cajeros est√°n ocupados, el cliente espera hasta que haya lugar.        |
| Fin de atenci√≥n         | `semaforo.Release()`          | El cliente libera el cajero una vez finalizada la atenci√≥n.                         |

<br />

üìà ** Salida esperada (resumida)**

```text
Cliente 1 est√° esperando un cajero...
Cliente 2 est√° esperando un cajero...
Cliente 3 est√° esperando un cajero...
Cliente 1 est√° siendo atendido (por un cajero disponible)
Cliente 2 est√° siendo atendido (por un cajero disponible)
Cliente 3 est√° siendo atendido (por un cajero disponible)
Cliente 4 est√° esperando un cajero...
Cliente 5 est√° esperando un cajero...
...
üèÅ Cliente 2 termin√≥ y deja el cajero libre
‚úÖ Cliente 4 est√° siendo atendido (por un cajero disponible)
...

```

----------

üß† Claves

1.  **Sincronizaci√≥n realista**: Limitamos la cantidad de operaciones concurrentes (como lo har√≠as en un servidor o API).
    
2.  **Cola de espera autom√°tica**: Los hilos que no consiguen acceso quedan bloqueados en `WaitOne()`.
    
3.  **Simulaci√≥n de procesos reales**: F√°cil de adaptar a escenarios como salas de espera, acceso a servidores, estaciones de impresi√≥n, etc.
    

----------

üõ†Ô∏è**Posibles mejoras**

Podemos:

-   Agregar un **tiempo m√°ximo de espera** para que un cliente se canse y se vaya.
    
-   Usar `ThreadPool` o `Task` en lugar de `Thread` para una mejor pr√°ctica moderna.
    
-   Registrar **cu√°ntos clientes se atendieron y cu√°ntos se fueron sin ser atendidos**.
    
<br/>

üéØ **Objetivo del nuevo programa**

Queremos simular un banco con estas reglas:

-   Hay **3 cajeros disponibles** (concurrencia limitada).
    
-   **10 clientes** intentan ser atendidos.
    
-   Si un cliente **espera m√°s de cierto tiempo**, se cansa y se va.
    
-   Usamos **`Task` + `ThreadPool`** (en vez de `Thread`) para c√≥digo m√°s moderno.
    
-   Al final mostramos:
    
    -   ‚úÖ Cu√°ntos fueron atendidos.
        
    -   ‚ùå Cu√°ntos se fueron sin ser atendidos.
        

----------

 üíª C√≥digo

```csharp
using System;
using System.Threading;
using System.Threading.Tasks;

class Program
{
    // Sem√°foro con 3 "cajeros" disponibles
    static SemaphoreSlim cajeros = new SemaphoreSlim(3, 3);

    // Contadores compartidos
    static int clientesAtendidos = 0;
    static int clientesQueSeFueron = 0;

    static async Task Main()
    {
        var tareas = new Task[10]; // Simulamos 10 clientes

        for (int i = 0; i < 10; i++)
        {
            int idCliente = i + 1;
            tareas[i] = Task.Run(() => AtenderCliente(idCliente));
        }

        await Task.WhenAll(tareas);

        // Mostramos resultados al final
        Console.WriteLine($"\nResumen final:");
        Console.WriteLine($"Clientes atendidos: {clientesAtendidos}");
        Console.WriteLine($"Clientes que se fueron sin ser atendidos: {clientesQueSeFueron}");
    }

    static async Task AtenderCliente(int id)
    {
        Console.WriteLine($"Cliente {id} est√° esperando un cajero...");

        // Tiempo m√°ximo de espera: 2 segundos
        if (await cajeros.WaitAsync(TimeSpan.FromSeconds(2)))
        {
            try
            {
                Console.WriteLine($"Cliente {id} est√° siendo atendido...");
                Interlocked.Increment(ref clientesAtendidos);

                // Simulamos el tiempo de atenci√≥n (1 a 3 segundos)
                await Task.Delay(new Random().Next(1000, 3000));

                Console.WriteLine($"Cliente {id} termin√≥ y deja el cajero.");
            }
            finally
            {
                cajeros.Release(); // Libera el cajero
            }
        }
        else
        {
            Console.WriteLine($"Cliente {id} se cans√≥ de esperar y se fue.");
            Interlocked.Increment(ref clientesQueSeFueron);
        }
    }
}

```

<br/>

üîç **¬øQu√© mejoras se implementaron?**

| Mejora                        | Implementaci√≥n                                                                 |
|------------------------------|---------------------------------------------------------------------------------|
| Uso moderno de hilos         | Se utiliza `Task.Run()` en lugar de `Thread`, lo cual es m√°s eficiente y escalable. |
| Tiempo m√°ximo de espera      | Se implementa con `WaitAsync(TimeSpan)` para permitir que un cliente se canse de esperar. |
| Contadores seguros           | `Interlocked.Increment()` asegura que las estad√≠sticas sean correctas en entornos multihilo. |
| Liberaci√≥n garantizada       | Se usa `try/finally` para garantizar que el sem√°foro siempre se libere, incluso ante errores. |


----------

üìã **Salida de ejemplo (simulada)**

```text
Cliente 1 est√° esperando un cajero...
Cliente 2 est√° esperando un cajero...
Cliente 3 est√° esperando un cajero...
Cliente 1 est√° siendo atendido...
Cliente 2 est√° siendo atendido...
Cliente 3 est√° siendo atendido...
Cliente 4 est√° esperando un cajero...
Cliente 5 est√° esperando un cajero...
Cliente 6 se cans√≥ de esperar y se fue.
...
üèÅ Resumen final:
‚úÖ Clientes atendidos: 7
‚ùå Clientes que se fueron sin ser atendidos: 3

```

<br/>

## **üîπ 4. Regiones Cr√≠ticas**

**Definici√≥n:** Las **regiones cr√≠ticas** son secciones del c√≥digo donde un solo hilo debe acceder a un recurso compartido para evitar condiciones de carrera. Se deben proteger con mecanismos de sincronizaci√≥n como sem√°foros o bloqueos.

**Ejemplo en C#:**

```csharp
using System;
using System.Threading;

class Program
{
    static object bloqueo = new object();

    static void Main()
    {
        Thread t1 = new Thread(AccederRecursoCritico);
        Thread t2 = new Thread(AccederRecursoCritico);

        t1.Start();
        t2.Start();
    }

    static void AccederRecursoCritico()
    {
        lock (bloqueo)  // Protege la regi√≥n cr√≠tica
        {
            Console.WriteLine($"{Thread.CurrentThread.ManagedThreadId} accediendo a la regi√≥n cr√≠tica...");
            Thread.Sleep(1000);  // Simula trabajo
        }
        Console.WriteLine($"{Thread.CurrentThread.ManagedThreadId} termin√≥ su tarea.");
    }
}

```

## **üîπ 5. Monitores**

**Definici√≥n:** Un **monitor** es un mecanismo de sincronizaci√≥n que permite que un hilo acceda a una regi√≥n cr√≠tica de manera exclusiva. En C#, el `lock` es una forma de monitor, ya que asegura que solo un hilo pueda ejecutar una secci√≥n cr√≠tica a la vez.

**Ejemplo en C#:**

Ya vimos el uso de `lock` en el ejemplo anterior, el cual act√∫a como un monitor.



## **üîπ 6. Invocaci√≥n de Servicios, Eventos y Notificaciones**

**Definici√≥n:** Los **eventos** y las **notificaciones** se utilizan para la comunicaci√≥n entre hilos, donde un hilo notifica a otro cuando un evento ha ocurrido.

**Ejemplo en C#:**

```csharp
using System;
using System.Threading;

class Program
{
    static AutoResetEvent evento = new AutoResetEvent(false);  // Evento de notificaci√≥n

    static void Main()
    {
        Thread t1 = new Thread(EsperarEvento);
        t1.Start();

        // Simula trabajo en el hilo principal
        Thread.Sleep(2000);  
        evento.Set();  // Notifica que el evento ha ocurrido

        t1.Join();
    }

    static void EsperarEvento()
    {
        Console.WriteLine("Esperando evento...");
        evento.WaitOne();  // Espera a que se dispare el evento
        Console.WriteLine("Evento recibido, hilo despertado.");
    }
}

```

## **üîπ 7. Introducci√≥n a la Programaci√≥n Paralela y Paralelismo**

**Definici√≥n:** El **paralelismo** es el enfoque que permite la ejecuci√≥n simult√°nea de varias tareas, aprovechando m√∫ltiples n√∫cleos de la CPU. Mientras que la **programaci√≥n concurrente** permite que varias tareas se intercalen, el paralelismo las ejecuta simult√°neamente.

**Ejemplo en C#:**

```csharp
using System;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        // Ejecutando dos tareas de manera paralela
        Task t1 = Task.Run(() => RealizarTrabajo("Tarea 1"));
        Task t2 = Task.Run(() => RealizarTrabajo("Tarea 2"));

        Task.WhenAll(t1, t2).Wait(); // Espera a que ambas tareas finalicen

        Console.WriteLine("Ambas tareas finalizaron.");
    }

    static void RealizarTrabajo(string tarea)
    {
        Console.WriteLine($"{tarea} est√° comenzando.");
        System.Threading.Thread.Sleep(1000); // Simula trabajo
        Console.WriteLine($"{tarea} termin√≥.");
    }
}

```

En este ejemplo, las tareas `Tarea 1` y `Tarea 2` se ejecutan **paralelamente**, ya que se aprovechan varios n√∫cleos de la CPU para ejecutarse al mismo tiempo.


## **üîπ 8. Objetivos del Procesamiento Paralelo: Speedup y Eficiencia**

**Definici√≥n:**

-   **Speedup** es el incremento en la velocidad de ejecuci√≥n al usar procesamiento paralelo comparado con el secuencial.
    
-   **Eficiencia** es c√≥mo de bien se utilizan los recursos disponibles.
    

**Ejemplo en C#:**

```csharp
using System;
using System.Diagnostics;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        Stopwatch stopwatch = new Stopwatch();

        // Medir tiempo de ejecuci√≥n secuencial
        stopwatch.Start();
        EjecutarTrabajoSecuencial();
        stopwatch.Stop();
        long tiempoSecuencial = stopwatch.ElapsedMilliseconds;
        Console.WriteLine($"Tiempo de ejecuci√≥n secuencial: {tiempoSecuencial} ms");

        // Medir tiempo de ejecuci√≥n paralelo
        stopwatch.Restart();
        EjecutarTrabajoParalelo().Wait();
        stopwatch.Stop();
        long tiempoParalelo = stopwatch.ElapsedMilliseconds;
        Console.WriteLine($"Tiempo de ejecuci√≥n paralelo: {tiempoParalelo} ms");

        // Calcular Speedup
        double speedup = (double)tiempoSecuencial / tiempoParalelo;
        Console.WriteLine($"Speedup: {speedup}");
    }

    static void EjecutarTrabajoSecuencial()
    {
        RealizarTrabajo("Trabajo secuencial 1");
        RealizarTrabajo("Trabajo secuencial 2");
    }

    static async Task EjecutarTrabajoParalelo()
    {
        Task t1 = Task.Run(() => RealizarTrabajo("Trabajo paralelo 1"));
        Task t2 = Task.Run(() => RealizarTrabajo("Trabajo paralelo 2"));
        await Task.WhenAll(t1, t2);  // Espera a que ambas tareas finalicen
    }

    static void RealizarTrabajo(string trabajo)
    {
        Console.WriteLine($"{trabajo} est√° comenzando.");
        System.Threading.Thread.Sleep(1000); // Simula trabajo
        Console.WriteLine($"{trabajo} termin√≥.");
    }
}

```

En este caso, calculamos el **speedup** comparando el tiempo de ejecuci√≥n de una versi√≥n secuencial y paralela del mismo trabajo.


## **üîπ 9. Concepto de Escalabilidad**

**Definici√≥n:** La **escalabilidad** es la capacidad de un sistema de manejar el aumento de carga (m√°s tareas o m√°s datos) al agregar m√°s recursos (por ejemplo, m√°s n√∫cleos de CPU). En programaci√≥n paralela, un sistema escalable deber√≠a ser capaz de aumentar su rendimiento conforme aumentan los recursos.

**Ejemplo en C#:**

Aqu√≠ no hay un ejemplo directo, pero puedes usar el ejemplo anterior para mostrar c√≥mo el tiempo de ejecuci√≥n se reduce al utilizar m√°s recursos de CPU (n√∫cleos) al ejecutar tareas en paralelo.


## **üîπ 10. Creaci√≥n, Propiedades y Ciclo de Vida de los Hilos de Concurrencia**

**Definici√≥n:** Los **hilos de concurrencia** son unidades de ejecuci√≥n que se ejecutan de manera independiente. Cada hilo tiene propiedades como su estado, prioridad y ciclo de vida.

**Ejemplo en C#:**

```csharp
using System;
using System.Threading;

class Program
{
    static void Main()
    {
        Thread hilo = new Thread(Trabajar);
        hilo.Start();
        Console.WriteLine($"Estado inicial del hilo: {hilo.ThreadState}");
        hilo.Join();  // Espera a que el hilo termine
        Console.WriteLine($"Estado final del hilo: {hilo.ThreadState}");
    }

    static void Trabajar()
    {
        Console.WriteLine("Hilo est√° trabajando...");
        Thread.Sleep(1000);  // Simula trabajo
    }
}

```

Este ejemplo muestra c√≥mo se crea un hilo, se obtiene su estado, y c√≥mo cambia el estado durante su ciclo de vida. El estado del hilo cambia de **Unstarted** a **Running** y finalmente a **Stopped**.


## **üîπ 11. Mecanismos de Sincronizaci√≥n entre Hilos Concurrentes**

**Definici√≥n:** Los mecanismos de sincronizaci√≥n son herramientas que permiten coordinar la ejecuci√≥n de varios hilos para evitar condiciones de carrera al acceder a recursos compartidos.

**Ejemplo en C#:**

Usamos un **Mutex** para sincronizar el acceso entre hilos a una regi√≥n cr√≠tica.

```csharp
using System;
using System.Threading;

class Program
{
    static Mutex mutex = new Mutex();

    static void Main()
    {
        Thread t1 = new Thread(AccederRecurso);
        Thread t2 = new Thread(AccederRecurso);

        t1.Start();
        t2.Start();

        t1.Join();
        t2.Join();
    }

    static void AccederRecurso()
    {
        Console.WriteLine($"{Thread.CurrentThread.ManagedThreadId} esperando para acceder al recurso...");
        mutex.WaitOne();  // Adquiere el mutex
        Console.WriteLine($"{Thread.CurrentThread.ManagedThreadId} accediendo al recurso...");
        Thread.Sleep(1000);  // Simula trabajo
        mutex.ReleaseMutex();  // Libera el mutex
        Console.WriteLine($"{Thread.CurrentThread.ManagedThreadId} termin√≥ su tarea.");
    }
}

```

Aqu√≠ usamos un **Mutex** para asegurar que solo un hilo pueda acceder a la regi√≥n cr√≠tica a la vez.


## **üîπ 12. Jerarqu√≠a de Hilos**

**Definici√≥n:** La jerarqu√≠a de hilos describe c√≥mo se organizan los hilos en un programa. Un hilo principal puede crear hilos secundarios para realizar tareas paralelas. Estos hilos secundarios pueden ser gestionados de manera independiente.

**Ejemplo en C#:**

```csharp
using System;
using System.Threading;

class Program
{
    static void Main()
    {
        Console.WriteLine("Hilo principal comenzando.");

        Thread t1 = new Thread(TareaSecundaria);
        Thread t2 = new Thread(TareaSecundaria);

        t1.Start();
        t2.Start();

        // Espera que los hilos secundarios terminen antes de continuar
        t1.Join();
        t2.Join();

        Console.WriteLine("Hilo principal termin√≥.");
    }

    static void TareaSecundaria()
    {
        Console.WriteLine($"Hilo {Thread.CurrentThread.ManagedThreadId} ejecutando tarea secundaria.");
        Thread.Sleep(1000);  // Simula trabajo
    }
}

```

Este ejemplo muestra la **jerarqu√≠a de hilos** donde el hilo principal crea dos hilos secundarios (`t1` y `t2`) que realizan tareas paralelas. El hilo principal espera a que ambos hilos terminen antes de finalizar.



## **Cierre y Preguntas**

### ¬øC√≥mo diferencian las primitivas de sincronizaci√≥n como los sem√°foros y los monitores?

-   **Sem√°foros** permiten un control de acceso m√°s flexible, permitiendo que varios hilos accedan a recursos al mismo tiempo, mientras que los **monitores** permiten que solo un hilo acceda a la secci√≥n cr√≠tica a la vez.
    

### ¬øPor qu√© es importante la programaci√≥n paralela y qu√© objetivos tiene?

-   La programaci√≥n paralela busca mejorar la eficiencia y el **speedup**, aprovechando m√∫ltiples n√∫cleos de CPU para ejecutar tareas simult√°neamente, lo cual es clave en el procesamiento de grandes vol√∫menes de datos.
    

----------

### **üß† Mapa Conceptual: Unidad 2 - Primitivas de Sincronizaci√≥n y Modelo de Programaci√≥n**

```plaintext
                   üßë‚Äçüíª Programaci√≥n Paralela üßë‚Äçüíª
                           |
        -----------------------------------------
        |                                       |
      üïπÔ∏è Procesamiento Paralelo               üö¶ Sincronizaci√≥n entre Hilos
        |                                       |
   ‚è© Speedup y Eficiencia                      üîí Sem√°foros
        |                                       |
   üìà Escalabilidad                            üîê Regiones Cr√≠ticas
        |                                       |
   üßë‚Äçüè≠ Creaci√≥n y Ciclo de Hilos                üë®‚Äçüî¨ Monitores
        |                                       |
   üèÉ‚Äç‚ôÇÔ∏è Propiedades de Hilos                    üì≤ Eventos y Notificaciones
        |
     üîÑ Mecanismos de Sincronizaci√≥n 

```

----------

### **Explicaci√≥n**

-   **üßë‚Äçüíª Programaci√≥n Paralela:** Concepto central que aborda la ejecuci√≥n simult√°nea de tareas. El paralelismo mejora la eficiencia y el rendimiento al aprovechar m√∫ltiples n√∫cleos de la CPU.
    
-   **üïπÔ∏è Procesamiento Paralelo:** El uso de procesamiento simult√°neo para tareas que pueden ejecutarse en paralelo, maximizando la capacidad de los recursos.
    
-   **üö¶ Sincronizaci√≥n entre Hilos:** Coordina la ejecuci√≥n de los hilos para evitar conflictos de acceso a recursos compartidos, garantizando que los datos no se corrompan.
    
-   **üîí Sem√°foros:** Herramientas para controlar el acceso a recursos compartidos, permitiendo que varios hilos interact√∫en sin interferencias.
    
-   **üîê Regiones Cr√≠ticas:** Secci√≥n de c√≥digo donde se deben controlar los accesos concurrentes a recursos compartidos para evitar condiciones de carrera.
    
-   **üë®‚Äçüî¨ Monitores:** Estructuras que combinan sem√°foros y regiones cr√≠ticas para gestionar el acceso a los recursos de manera m√°s f√°cil y eficiente.
    
-   **üì≤ Eventos y Notificaciones:** Se utilizan para notificar a los hilos cuando ocurren ciertos eventos, permitiendo la comunicaci√≥n efectiva entre ellos.
    
-   **üìà Escalabilidad:** La capacidad de un sistema de manejar un aumento en la carga de trabajo agregando m√°s recursos.
    
-   **üèÉ‚Äç‚ôÇÔ∏è Creaci√≥n y Ciclo de Hilos:** C√≥mo se crean, inician y gestionan los hilos dentro del programa para realizar tareas concurrentes.
    
-   **üîÑ Mecanismos de Sincronizaci√≥n:** Herramientas y t√©cnicas utilizadas para coordinar y controlar la ejecuci√≥n de m√∫ltiples hilos concurrentes.
    



<!--stackedit_data:
eyJoaXN0b3J5IjpbLTUzNDYyNzQxMF19
-->