# **ğŸ“Œ Unidad  1: IntroducciÃ³n a la ProgramaciÃ³n Concurrente**

## **ğŸ‘¨â€ğŸ« 1. MotivaciÃ³n de la ProgramaciÃ³n Concurrente**

Cuando programamos, normalmente estamos acostumbrados a escribir cÃ³digo que se ejecuta **de forma secuencial**. Es decir, una tarea debe **terminar completamente** antes de que comience la siguiente.

Sin embargo, en muchos casos, esta forma de ejecuciÃ³n no es eficiente. Veamos algunos ejemplos:

### **ğŸ”¹ Â¿CuÃ¡ndo necesitamos concurrencia?**

âœ… **Aplicaciones web:** Un servidor maneja mÃºltiples peticiones de usuarios al mismo tiempo.  
âœ… **Aplicaciones de escritorio y mÃ³viles:** Un programa no debe quedarse "congelado" mientras realiza cÃ¡lculos.  
âœ… **Sistemas en tiempo real:** Juegos, simulaciones, robÃ³tica, procesamiento de video.  
âœ… **Procesamiento de grandes volÃºmenes de datos:** Aplicaciones que realizan anÃ¡lisis complejos en paralelo.

### **ğŸ”¹ Ejemplo en C# (EjecuciÃ³n Secuencial vs Concurrente)**

**ğŸ”´ EjecuciÃ³n Secuencial (Tareas una tras otra)**

```csharp
using System;
using System.Diagnostics;

class Program
{
    static void Main()
    {
        Stopwatch sw = Stopwatch.StartNew();
        RealizarTareaLenta("Tarea 1");
        RealizarTareaLenta("Tarea 2");
        sw.Stop();
        Console.WriteLine($"Tiempo total: {sw.ElapsedMilliseconds}ms");
    }

    static void RealizarTareaLenta(string nombre)
    {
        Console.WriteLine($"{nombre} iniciada...");
        System.Threading.Thread.Sleep(2000); // Simula una tarea de 2 segundos
        Console.WriteLine($"{nombre} finalizada.");
    }
}

```

â³ **Tiempo total:** 4 segundos (porque las tareas se ejecutan una tras otra).

**ğŸŸ¢ EjecuciÃ³n Concurrente (Las tareas se ejecutan en paralelo)**

```csharp
using System;
using System.Diagnostics;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        Stopwatch sw = Stopwatch.StartNew();
        Task tarea1 = RealizarTareaLenta("Tarea 1");
        Task tarea2 = RealizarTareaLenta("Tarea 2");

        await Task.WhenAll(tarea1, tarea2);
        sw.Stop();
        Console.WriteLine($"Tiempo total: {sw.ElapsedMilliseconds}ms");
    }

    static async Task RealizarTareaLenta(string nombre)
    {
        Console.WriteLine($"{nombre} iniciada...");
        await Task.Delay(2000); // Simula una tarea de 2 segundos
        Console.WriteLine($"{nombre} finalizada.");
    }
}

```

â³ **Tiempo total:** 2 segundos (ambas tareas corren simultÃ¡neamente).

ğŸ“Œ **ConclusiÃ³n:** Con concurrencia, reducimos el tiempo de ejecuciÃ³n al aprovechar mejor los recursos.

----------

## **ğŸ›  2. Recursos para ProgramaciÃ³n Concurrente**

En C# tenemos varias herramientas para manejar concurrencia:

### **ğŸ”¹ Hilos (`Thread`)**

Un hilo es la unidad mÃ¡s pequeÃ±a de ejecuciÃ³n en un programa. Permite ejecutar mÃºltiples tareas al mismo tiempo.

ğŸ“Œ **Ejemplo en C#: Crear y ejecutar hilos**

```csharp
using System;
using System.Threading;

class Program
{
    static void Main()
    {
        Thread hilo1 = new Thread(() => ImprimirMensaje("Hola desde el hilo 1"));
        Thread hilo2 = new Thread(() => ImprimirMensaje("Hola desde el hilo 2"));

        hilo1.Start();
        hilo2.Start();

        hilo1.Join();
        hilo2.Join();
    }

    static void ImprimirMensaje(string mensaje)
    {
        Console.WriteLine(mensaje);
    }
}

```

ğŸ“Œ **ConclusiÃ³n:** Con `Thread`, podemos ejecutar cÃ³digo en paralelo, pero tenemos que gestionar la sincronizaciÃ³n manualmente.

### **ğŸ”¹ `Task` y `Parallel`**

âœ… `Task`: Es una forma mÃ¡s moderna y flexible de manejar tareas en C#.  
âœ… `Parallel.For`: Permite ejecutar bucles en paralelo, aprovechando mÃºltiples nÃºcleos de CPU.

ğŸ“Œ **Ejemplo en C#: Uso de `Parallel.ForEach`**

```csharp
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        List<int> numeros = new List<int> { 1, 2, 3, 4, 5 };

        Parallel.ForEach(numeros, numero =>
        {
            Console.WriteLine($"Procesando nÃºmero {numero} en el hilo {Task.CurrentId}");
        });
    }
}

```

ğŸ“Œ **ConclusiÃ³n:** `Parallel` facilita la ejecuciÃ³n de operaciones en paralelo sin necesidad de manejar hilos manualmente.

----------

## **ğŸ”„ 3. InteracciÃ³n entre Procesos en un Programa Concurrente**

Cuando varios procesos corren al mismo tiempo, pueden necesitar **compartir informaciÃ³n** o **sincronizarse**. Hay dos formas principales de hacerlo:

### **ğŸ”¹ Memoria Compartida**

Varios hilos acceden a la misma variable. **Debe manejarse con cuidado** para evitar problemas de concurrencia.

ğŸ“Œ **Ejemplo en C#: Usando `ConcurrentQueue` para memoria compartida**

```csharp
using System;
using System.Collections.Concurrent;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        ConcurrentQueue<int> cola = new ConcurrentQueue<int>();

        Task productor = Task.Run(() =>
        {
            for (int i = 1; i <= 5; i++)
            {
                cola.Enqueue(i);
                Console.WriteLine($"Producto {i} agregado");
            }
        });

        Task consumidor = Task.Run(() =>
        {
            while (!cola.IsEmpty)
            {
                if (cola.TryDequeue(out int item))
                {
                    Console.WriteLine($"Consumidor procesando: {item}");
                }
            }
        });

        Task.WaitAll(productor, consumidor);
    }
}

```

ğŸ“Œ **ConclusiÃ³n:** `ConcurrentQueue` permite que varios hilos accedan a la misma estructura sin generar errores.

----------

## **ğŸš¨ 4. PatologÃ­as de los Programas Concurrentes**

Cuando trabajamos con concurrencia, pueden surgir **problemas difÃ­ciles de detectar**, como:

ğŸ”´ **Condiciones de carrera:** Dos hilos modifican la misma variable al mismo tiempo.  
ğŸ”´ **Interbloqueo (Deadlock):** Dos procesos esperan indefinidamente un recurso que el otro bloquea.  
ğŸ”´ **InaniciÃ³n (Starvation):** Un proceso nunca recibe recursos porque otros los acaparan.

ğŸ“Œ **Ejemplo en C#: Evitando condiciÃ³n de carrera con `lock`**

```csharp
using System;
using System.Threading;

class Program
{
    static int contador = 0;
    static object bloqueo = new object();

    static void Incrementar()
    {
        for (int i = 0; i < 1000; i++)
        {
            lock (bloqueo) // ExclusiÃ³n mutua
            {
                contador++;
            }
        }
    }

    static void Main()
    {
        Thread hilo1 = new Thread(Incrementar);
        Thread hilo2 = new Thread(Incrementar);

        hilo1.Start();
        hilo2.Start();
        hilo1.Join();
        hilo2.Join();

        Console.WriteLine($"Valor final del contador: {contador}");
    }
}

```

ğŸ“Œ **ConclusiÃ³n:** El uso de `lock` evita que varios hilos modifiquen `contador` al mismo tiempo.

----------

## **ğŸ¤ Cierre y Preguntas para la Clase**

### **1ï¸âƒ£ Â¿QuÃ© diferencias encontraron entre la ejecuciÃ³n secuencial y la paralela?**

ğŸ“Œ La ejecuciÃ³n secuencial es mÃ¡s sencilla, pero mÃ¡s lenta.  
ğŸ“Œ La ejecuciÃ³n paralela aprovecha mejor los recursos y es mÃ¡s rÃ¡pida.

### **2ï¸âƒ£ Â¿CÃ³mo podrÃ­an aplicar estos conceptos en aplicaciones reales?**

âœ… En servidores web para manejar mÃºltiples peticiones.  
âœ… En juegos y simulaciones para procesar mÃºltiples eventos a la vez.


Â¡Buena pregunta, VÃ­ctor! Vamos a desarrollarla en detalle.

----------

## **ğŸ” 3ï¸âƒ£ Â¿QuÃ© dudas tienen sobre `Task` y `Parallel.For`?**

En C#, tenemos varias formas de manejar la concurrencia, y dos de las mÃ¡s comunes son:

1.  **`Task`** (para manejar tareas asincrÃ³nicas)
    
2.  **`Parallel.For`** (para ejecutar bucles en paralelo)
    

### **ğŸ”¹ `Task`: ProgramaciÃ³n AsincrÃ³nica y Concurrente**

âœ… `Task` permite ejecutar cÃ³digo en segundo plano sin bloquear el hilo principal.  
âœ… Es muy Ãºtil para operaciones como llamadas a bases de datos, consultas a APIs, o cÃ¡lculos pesados.  
âœ… Se usa junto con `async` y `await` para una mejor legibilidad.

ğŸ“Œ **Ejemplo en C#: Uso de `Task` para realizar mÃºltiples operaciones en paralelo**

```csharp
using System;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        Task<int> tarea1 = CalcularCuadrado(5);
        Task<int> tarea2 = CalcularCuadrado(10);

        int resultado1 = await tarea1;
        int resultado2 = await tarea2;

        Console.WriteLine($"Cuadrado de 5: {resultado1}");
        Console.WriteLine($"Cuadrado de 10: {resultado2}");
    }

    static async Task<int> CalcularCuadrado(int numero)
    {
        await Task.Delay(2000); // Simula una operaciÃ³n lenta
        return numero * numero;
    }
}

```

ğŸ“Œ **ConclusiÃ³n:** `Task` permite ejecutar varias operaciones al mismo tiempo y esperar los resultados sin bloquear el programa.

----------

### **ğŸ”¹ `Parallel.For`: EjecuciÃ³n de Bucles en Paralelo**

âœ… `Parallel.For` permite ejecutar iteraciones de un bucle `for` en paralelo.  
âœ… Usa mÃºltiples nÃºcleos del procesador para mejorar el rendimiento en tareas repetitivas.  
âœ… Es Ãºtil cuando hay muchas operaciones independientes entre sÃ­.

ğŸ“Œ **Ejemplo en C#: Uso de `Parallel.For` para calcular el cuadrado de varios nÃºmeros**

```csharp
using System;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        Parallel.For(1, 6, i =>
        {
            Console.WriteLine($"NÃºmero: {i}, Cuadrado: {i * i} (Hilo: {Task.CurrentId})");
        });
    }
}

```

ğŸ“Œ **ConclusiÃ³n:** `Parallel.For` divide automÃ¡ticamente el trabajo entre los nÃºcleos del procesador, haciendo que el bucle se ejecute mÃ¡s rÃ¡pido en comparaciÃ³n con un `for` tradicional.

----------

## **ğŸ¤” Â¿CuÃ¡ndo usar `Task` y cuÃ¡ndo usar `Parallel.For`?**

ğŸ“Œ **Usa `Task` cuando...**  
âœ… Tienes operaciones que pueden tardar y quieres mantener la UI o el servidor respondiendo.  
âœ… Necesitas ejecutar tareas en paralelo y esperar sus resultados con `await`.

ğŸ“Œ **Usa `Parallel.For` cuando...**  
âœ… Necesitas procesar grandes volÃºmenes de datos rÃ¡pidamente.  
âœ… Tienes un bucle con muchas iteraciones independientes entre sÃ­.

----------

## **ğŸ“ Preguntas Claves**

1.  Â¿Por quÃ© `Task` usa `async` y `await`, mientras que `Parallel.For` no?  
    â Porque `Task` maneja operaciones asÃ­ncronas, mientras que `Parallel.For` solo distribuye la carga en mÃºltiples hilos.
    
2.  Â¿`Parallel.For` siempre es mÃ¡s rÃ¡pido que un `for` normal?  
    â No siempre. Si el nÃºmero de iteraciones es bajo o si hay dependencias entre ellas, puede no ser eficiente.
    
3.  Â¿Puedo usar `Parallel.For` dentro de una funciÃ³n `async`?  
    â No directamente, porque `Parallel.For` no es asÃ­ncrono, sino concurrente. Para tareas asÃ­ncronas es mejor `Task`.
    
---------
Â¡Claro! AquÃ­ tienes el mapa conceptual en formato texto con los emoticones, para que coincida con el texto que te di antes.

----------

### ğŸ—ºï¸ **Mapa Conceptual - Unidad 1: IntroducciÃ³n a la ProgramaciÃ³n Concurrente**

```
                            +-------------------------------------------+
                            |         IntroducciÃ³n a la ProgramaciÃ³n   |
                            |                  Concurrente             |
                            +-------------------------------------------+
                                         |
        +-------------------------------+-------------------------------+
        |                               |                               |
  +--------------+              +---------------+               +----------------+
  | ğŸ’¡ MotivaciÃ³n   |              | ğŸ› ï¸ Recursos      |               | ğŸ”„ InteracciÃ³n     |
  | ProgramaciÃ³n   |              | para Programar|               | entre Procesos  |
  | Concurrente  |              | Concurrente   |               | Concurrentes    |
  +--------------+              +---------------+               +----------------+
        |                               |                               |
 +-----------------+         +-------------------+          +--------------------+
 | âš ï¸ PatologÃ­as     |         | ğŸ” SincronizaciÃ³n    |          | ğŸ“¬ ComunicaciÃ³n por    |
 | de Programas   |         | por ExclusiÃ³n     |          | Memoria Compartida  |
 | Concurrentes   |         | Mutua y por       |          | y por Mensajes      |
 +-----------------+         | CondiciÃ³n         |          +--------------------+
        |                     +-------------------+
        |                              |
  +--------------+               +-----------------------+
  | ğŸ” Paradigmas   |               | âš™ï¸ Concurrencia y        |
  | de ResoluciÃ³n|               | SincronizaciÃ³n        |
  | de Programas |               +-----------------------+
  +--------------+                         |
        |                        +--------------------+
        |                        | â– Aspectos de         |
        |                        | ProgramaciÃ³n        |
        |                        | Secuencial          |
        |                        +--------------------+
        |
  +-------------------------------+
  | ğŸ“œ EspecificaciÃ³n y SemÃ¡ntica    |
  | de la EjecuciÃ³n Concurrente   |
  +-------------------------------+

```
----------

### ğŸ—ºï¸ **Mapa Conceptual - Unidad 1: IntroducciÃ³n a la ProgramaciÃ³n Concurrente**

----------

#### **1. MotivaciÃ³n de la ProgramaciÃ³n Concurrente ğŸ’¡**

-   **Objetivo:** La programaciÃ³n concurrente permite que mÃºltiples tareas se ejecuten simultÃ¡neamente, aprovechando los recursos del sistema y mejorando la eficiencia.
    
-   **ConexiÃ³n:** A medida que los sistemas se vuelven mÃ¡s complejos, necesitamos ejecutar varias tareas al mismo tiempo para mejorar la velocidad y el rendimiento.
    

----------

#### **2. Recursos para ProgramaciÃ³n Concurrente ğŸ› ï¸**

-   **Objetivo:** Herramientas y tecnologÃ­as (como hilos, procesos y recursos compartidos) que permiten ejecutar tareas concurrentemente.
    
-   **ConexiÃ³n:** Los recursos incluyen procesadores multinÃºcleo, bibliotecas especÃ­ficas y lenguajes de programaciÃ³n que facilitan la concurrencia.
    

----------

#### **3. InteracciÃ³n entre Procesos de un Programa Concurrente ğŸ”„**

-   **Objetivo:** En programas concurrentes, los procesos deben comunicarse y compartir datos de manera eficiente y segura.
    
-   **ConexiÃ³n:** Los procesos pueden interactuar a travÃ©s de memoria compartida o mediante el paso de mensajes.
    

----------

#### **4. PatologÃ­as de Programas Concurrentes âš ï¸**

-   **Objetivo:** Errores o problemas que surgen cuando no se manejan correctamente las condiciones de concurrencia.
    
-   **ConexiÃ³n:** Ejemplos comunes incluyen el **deadlock** (bloqueo mutuo) y las **condiciones de carrera** (race conditions), que afectan el comportamiento de un programa concurrente.
    

----------

#### **5. SincronizaciÃ³n por ExclusiÃ³n Mutua y por CondiciÃ³n ğŸ”**

-   **Objetivo:** Los mecanismos de sincronizaciÃ³n permiten controlar el acceso a recursos compartidos, evitando problemas como el acceso simultÃ¡neo no controlado.
    
-   **ConexiÃ³n:**
    
    -   **ExclusiÃ³n mutua:** Asegura que solo un hilo acceda a un recurso a la vez.
        
    -   **CondiciÃ³n:** Sincroniza la ejecuciÃ³n de los hilos para coordinar sus interacciones.
        

----------

#### **6. ComunicaciÃ³n por Memoria Compartida y por Mensajes ğŸ“¬**

-   **Objetivo:** Los procesos concurrentes pueden comunicarse utilizando memoria compartida o pasÃ¡ndose mensajes.
    
-   **ConexiÃ³n:**
    
    -   **Memoria compartida:** Varias entidades pueden acceder a la misma memoria para leer y escribir datos.
        
    -   **Mensajes:** Los procesos pueden enviar y recibir mensajes para compartir informaciÃ³n de manera mÃ¡s aislada.
        

----------

#### **7. Paradigmas de ResoluciÃ³n de Programas Concurrentes ğŸ”**

-   **Objetivo:** Los paradigmas como la **ProgramaciÃ³n Orientada a Hilos** y **ProgramaciÃ³n por Eventos** se utilizan para resolver problemas concurrentes de manera eficiente.
    
-   **ConexiÃ³n:** Estos paradigmas definen cÃ³mo estructurar un programa para que sus tareas puedan ejecutarse en paralelo de forma coherente.
    

----------

#### **8. Concurrencia y SincronizaciÃ³n âš™ï¸**

-   **Objetivo:** La concurrencia implica ejecutar mÃºltiples tareas al mismo tiempo, mientras que la sincronizaciÃ³n asegura que estas tareas se coordinen correctamente.
    
-   **ConexiÃ³n:** Sincronizar las tareas concurrentes es esencial para evitar errores y asegurar que el flujo de ejecuciÃ³n sea correcto.
    

----------

#### **9. Aspectos de ProgramaciÃ³n Secuencial â–**

-   **Objetivo:** La programaciÃ³n secuencial se refiere a la ejecuciÃ³n de una tarea a la vez, sin concurrencia.
    
-   **ConexiÃ³n:** Aunque la concurrencia mejora el rendimiento, entender la programaciÃ³n secuencial es fundamental para los fundamentos de programaciÃ³n.
    

----------

#### **10. EspecificaciÃ³n y SemÃ¡ntica de la EjecuciÃ³n Concurrente ğŸ“œ**

-   **Objetivo:** Definir cÃ³mo se especifican y se interpretan las ejecuciones concurrentes.
    
-   **ConexiÃ³n:** La semÃ¡ntica nos ayuda a entender cÃ³mo se comportan los programas concurrentes y las interacciones entre los hilos.
    

----------


<!--stackedit_data:
eyJoaXN0b3J5IjpbNTkyNjU1MzAyXX0=
-->